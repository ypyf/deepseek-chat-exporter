/**
 * DeepSeek Chat Exporter - Content Script
 *
 * This script monitors the DeepSeek chat interface, extracts messages,
 * and provides functionality to export conversations as JSON.
 */

// DOM Selectors
const SELECTORS = {
  // åŸºäºè¯­ä¹‰å’Œç»“æ„æ¨¡å¼çš„é€‰æ‹©å™¨
  CHAT_CONTAINER: 'main, [role="main"], .chat-container, .conversation, body',
  MESSAGE_CONTAINER: '[role="log"], .messages, .conversation-container, .ds-conversation',
  USER_MESSAGE_PATTERNS: ['user', 'human', 'you', 'question', 'query', 'input', 'e214291b', 'fbb737a4'],
  AI_MESSAGE_PATTERNS: ['ai', 'assistant', 'bot', 'chatbot', 'answer', 'response', 'generated', 'c92459f0', 'ds-markdown', 'ds-markdown--block'],
  AI_COT_PATTERNS: ['ba94db8a'], // Chain of thought reasoning
  CONTENT_PATTERNS: ['content', 'text', 'message', 'chat-content', 'c92459f0', 'e214291b', 'fbb737a4', 'ds-markdown', 'ds-markdown--block', 'ba94db8a'],
  AI_FOOTER_PATTERNS: ['AI-generated', 'Generated by AI', 'AI ç”Ÿæˆ', 'AI-generated, for reference only'],
  // ç›´æ¥é€‰æ‹©å™¨
  USER_ELEMENTS: '[data-role="user"], .e214291b, .fbb737a4'
};

// Fallback selectors to try if primary selectors fail
const FALLBACK_SELECTORS = [
  // Chat container fallbacks
  'div.ds-conversation',
  '.ds-chat-container',
  'div[class*="conversation"]',
  'div[class*="chat"]',
  '.cbcaa82c',

  // Message item fallbacks
  'div[class*="message"]',
  'div[class*="chat-item"]',
  '.e214291b', // User message container
  '.c92459f0', // AI message container

  // Content text fallbacks
  'div[class*="content"]',
  'div[class*="text"]',
  '.e214291b textarea', // User input
  '.c92459f0' // AI response
];

// Cache of processed messages to prevent duplicates
let processedMessages = new WeakMap();

// Current session data
let currentSessionId = generateSessionId();
let lastStorageUpdate = 0;
const STORAGE_THROTTLE = 1000; // Limit storage updates to once per second

/**
 * Check if the current page is a DeepSeek chat page
 * @returns {boolean} True if the page is a DeepSeek chat page
 */
function isDeepSeekChatPage() {
  // æ£€æŸ¥URL
  const url = window.location.href;

  // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰DeepSeekç‰¹å®šçš„å…ƒç´ 
  if (document.querySelector('.e214291b, .c92459f0, .cbcaa82c, .ds-conversation, #chat-input') !== null) {
    return true;
  }

  // æ£€æŸ¥æ˜¯å¦æœ‰data-role="user"å…ƒç´ 
    if (document.querySelectorAll('[data-role="user"]').length > 0) {
      return true;
    }

    // å¦‚æœURLåŒ…å«deepseekï¼Œè¿›è¡Œæ›´è¯¦ç»†çš„æ£€æŸ¥
    if (url.includes('deepseek.com') || url.includes('deepseek.ai')) {
      // æ£€æŸ¥é¡µé¢æ˜¯å¦åŒ…å«èŠå¤©ç•Œé¢çš„ç‰¹å¾
      const hasChatElements =
        // æ£€æŸ¥æ˜¯å¦æœ‰å¯¹è¯å®¹å™¨
        document.querySelector('[role="log"]') !== null ||
        // æ£€æŸ¥æ˜¯å¦æœ‰AIç”Ÿæˆå†…å®¹çš„æŒ‡ç¤º
        Array.from(document.querySelectorAll('div')).some(div =>
          SELECTORS.AI_FOOTER_PATTERNS.some(pattern =>
            div.textContent.includes(pattern)
          )
        ) ||
        // æ£€æŸ¥æ˜¯å¦æœ‰è¾“å…¥æ¡†
        document.querySelector('textarea, [role="textbox"]') !== null;

      return hasChatElements;
    }

  return false;
}

/**
 * Debug the message structure on the page
 */
function debugMessageStructure() {

  try {
    // 1. æŸ¥æ‰¾å¯¹è¯å®¹å™¨
    const conversationContainer = document.querySelector('.ds-conversation, .cbcaa82c');

    if (conversationContainer) {
      // 2. è®°å½•å®¹å™¨çš„å­å…ƒç´ 

      // 3. æ£€æŸ¥æ¯ä¸ªå­å…ƒç´ çš„ç±»åå’Œç»“æ„
      Array.from(conversationContainer.children).forEach((child, index) => {

        // 4. æ£€æŸ¥æ˜¯å¦åŒ…å«ç”¨æˆ·/AIæ¶ˆæ¯ç‰¹å¾
        const hasUserClass = child.querySelector('.fbb737a4, .e214291b') !== null ||
                            child.classList.contains('fbb737a4') ||
                            child.classList.contains('e214291b');

        const hasAIClass = child.querySelector('.ds-markdown, .ds-markdown--block, .c92459f0') !== null ||
                          child.classList.contains('ds-markdown') ||
                          child.classList.contains('ds-markdown--block') ||
                          child.classList.contains('c92459f0');

        const hasCOTClass = child.querySelector('.ba94db8a') !== null ||
                           child.classList.contains('ba94db8a');


        // 5. å°è¯•æå–å†…å®¹
        const content = extractMessageContent(child);
      });
    }

    // 6. æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„ç”¨æˆ·æ¶ˆæ¯å…ƒç´ 
    const userElements = document.querySelectorAll('.fbb737a4, .e214291b, [data-role="user"]');
    userElements.forEach((el, i) => {
    });

    // 7. æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„AIæ¶ˆæ¯å…ƒç´ 
    const aiElements = document.querySelectorAll('.ds-markdown, .ds-markdown--block, .c92459f0, [data-role="assistant"]');
    aiElements.forEach((el, i) => {
    });

    // 8. æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„æ€è€ƒè¿‡ç¨‹å…ƒç´ 
    const cotElements = document.querySelectorAll('.ba94db8a');
    cotElements.forEach((el, i) => {
    });

    // 9. è®°å½•é¡µé¢ä¸Šæ‰€æœ‰ç±»åï¼Œå¸®åŠ©è¯†åˆ«æ–°çš„æ¨¡å¼
    const allClasses = new Set();
    document.querySelectorAll('*').forEach(el => {
      if (el.className && typeof el.className === 'string') {
        el.className.split(' ').forEach(cls => {
          if (cls) allClasses.add(cls);
        });
      }
    });
  } catch (error) {
    console.error('Error debugging message structure:', error);
  }
}

/**
 * Initialize the extension
 */
function init() {
  try {

    // æ£€æŸ¥æ˜¯å¦æ˜¯DeepSeekèŠå¤©é¡µé¢
    if (!isDeepSeekChatPage()) {
      return;
    }


    // æ³¨å…¥å¯¼å‡ºæŒ‰é’®
    setTimeout(() => {
      try {
        injectExportButton();
      } catch (buttonError) {
        console.error('Error injecting export button:', buttonError);
        // Try again with a simpler approach
        try {
          const simpleButton = document.createElement('button');
          simpleButton.id = 'deepseek-export-btn-simple';
          simpleButton.textContent = 'Export Chat';
          simpleButton.style.cssText = 'position:fixed;top:20px;right:20px;z-index:9999999;background:#4285f4;color:white;border:none;border-radius:12px;padding:10px 16px;font-size:14px;cursor:pointer;';
          simpleButton.onclick = () => exportChat('json');
          document.body.appendChild(simpleButton);
        } catch (simpleButtonError) {
          console.error('Failed to inject simple button:', simpleButtonError);
        }
      }
    }, 1000);

    // é¦–å…ˆè¿›è¡Œä¸€æ¬¡è°ƒè¯•ï¼Œäº†è§£é¡µé¢ç»“æ„
    debugMessageStructure();

    // è®¾ç½®è§‚å¯Ÿå™¨æ¥ç›‘è§†é¡µé¢å˜åŒ–ï¼Œç‰¹åˆ«æ˜¯èŠå¤©æ¶ˆæ¯çš„å˜åŒ–
    const observer = new MutationObserver(debounce(() => {

      // å½“é¡µé¢å†…å®¹å˜åŒ–æ—¶ï¼Œå°è¯•æå–æ–°æ¶ˆæ¯
      const messages = extractAllMessagesFromPage();
      if (messages.length > 0) {
      } else {
      }
    }, 1000));

    // æŸ¥æ‰¾èŠå¤©å®¹å™¨
    const chatContainer = document.querySelector('.ds-conversation, .cbcaa82c');

    if (chatContainer) {
      observer.observe(chatContainer, {
        childList: true,
        subtree: true,
        characterData: true,
        attributes: true
      });
    } else {
      console.warn('Chat container not found, observing body');
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
    }

    // åˆå§‹æå–æ¶ˆæ¯
    setTimeout(() => {
      const messages = extractAllMessagesFromPage();

      if (messages.length > 0) {
      } else {
        console.warn('No messages found on initial load');
        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ¶ˆæ¯ï¼Œå†æ¬¡è°ƒè¯•é¡µé¢ç»“æ„
        debugMessageStructure();
      }
    }, 2000);
  } catch (error) {
    console.error('Error initializing extension:', error);
    // Try to recover by at least injecting the export button
    try {
      setTimeout(() => {
        injectExportButton();
      }, 2000);
    } catch (buttonError) {
      console.error('Failed to inject export button:', buttonError);
    }
  }
}

/**
 * Find the chat container with multiple fallback attempts
 * @returns {Promise<Element|null>} The chat container element or null if not found
 */
function findChatContainer() {
  return new Promise(resolve => {
    // First try the primary selector
    let container = document.querySelector(SELECTORS.CHAT_CONTAINER);

    if (container) {
      resolve(container);
      return;
    }

    // Try fallback selectors
    for (const selector of FALLBACK_SELECTORS) {
      container = document.querySelector(selector);
      if (container) {
        // Update the selector for future use
        SELECTORS.CHAT_CONTAINER = selector;
        resolve(container);
        return;
      }
    }

    // If still not found, try again after a delay (page might be loading)
    console.warn('Chat container not found. Retrying in 2 seconds...');
    setTimeout(() => {
      // One last attempt with body as fallback
      const lastResort = document.body;
      resolve(lastResort);
    }, 2000);
  });
}

/**
 * Generate a unique session ID based on timestamp
 */
function generateSessionId() {
  return `session_${Date.now()}`;
}

/**
 * Create a simple hash for message deduplication
 */
function createHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash.toString(16);
}

/**
 * Inject the export button with dropdown menu into the page
 */
function injectExportButton() {
  // Check if button already exists
  if (document.getElementById('deepseek-export-btn')) {
    return;
  }

  // Create container for the button and dropdown
  const container = document.createElement('div');
  container.id = 'deepseek-export-container';
  container.className = 'deepseek-export-container';

  // Create the main export button
  const exportButton = document.createElement('button');
  exportButton.id = 'deepseek-export-btn';
  exportButton.className = 'deepseek-export-btn';

  // æ·»åŠ æ–‡æœ¬å’Œç®­å¤´å›¾æ ‡
  const buttonText = document.createElement('span');
  buttonText.textContent = chrome.i18n.getMessage('exportButtonText') || 'Export Chat';

  // åˆ›å»º SVG ç®­å¤´å›¾æ ‡ - ä½¿ç”¨ç”¨æˆ·æä¾›çš„SVG
  const arrowIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  arrowIcon.classList.add('arrow-icon');
  arrowIcon.setAttribute('viewBox', '0 0 24 24');
  arrowIcon.setAttribute('fill', 'none');
  arrowIcon.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('d', 'M12 15.5L7 10.5L8.41 9.09L12 12.67L15.59 9.09L17 10.5L12 15.5Z');
  path.setAttribute('fill', 'currentColor');
  path.setAttribute('stroke-linejoin', 'round');

  arrowIcon.appendChild(path);

  // å°†æ–‡æœ¬å’Œå›¾æ ‡æ·»åŠ åˆ°æŒ‰é’®
  exportButton.appendChild(buttonText);
  exportButton.appendChild(arrowIcon);

  // Create the dropdown menu
  const dropdownMenu = document.createElement('div');
  dropdownMenu.id = 'deepseek-export-dropdown';
  dropdownMenu.className = 'deepseek-export-dropdown';
  dropdownMenu.style.display = 'none';

  // Create export as JSON option
  const jsonOption = document.createElement('div');
  jsonOption.className = 'deepseek-export-option';
  jsonOption.textContent = chrome.i18n.getMessage('exportAsJSON') || 'Export as JSON';
  jsonOption.addEventListener('click', (e) => {
    e.stopPropagation();
    exportChat('json');
    dropdownMenu.style.display = 'none';
  });

  // Create export as Markdown option
  const markdownOption = document.createElement('div');
  markdownOption.className = 'deepseek-export-option';
  markdownOption.textContent = chrome.i18n.getMessage('exportAsMarkdown') || 'Export as Markdown';
  markdownOption.addEventListener('click', (e) => {
    e.stopPropagation();
    exportChat('markdown');
    dropdownMenu.style.display = 'none';
  });

  // Create export as Text option
  const textOption = document.createElement('div');
  textOption.className = 'deepseek-export-option';
  textOption.textContent = chrome.i18n.getMessage('exportAsText') || 'Export as Plain Text';
  textOption.addEventListener('click', (e) => {
    e.stopPropagation();
    exportChat('text');
    dropdownMenu.style.display = 'none';
  });

  // Create export as HTML option
  const htmlOption = document.createElement('div');
  htmlOption.className = 'deepseek-export-option';
  htmlOption.textContent = chrome.i18n.getMessage('exportAsHTML') || 'Export as HTML';
  htmlOption.addEventListener('click', (e) => {
    e.stopPropagation();
    exportChat('html');
    dropdownMenu.style.display = 'none';
  });

  // Add options to dropdown menu
  dropdownMenu.appendChild(jsonOption);
  dropdownMenu.appendChild(markdownOption);
  dropdownMenu.appendChild(textOption);
  dropdownMenu.appendChild(htmlOption);

  // Toggle dropdown menu when clicking the export button
  exportButton.addEventListener('click', (event) => {
    event.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
    const isVisible = dropdownMenu.style.display === 'block';
    dropdownMenu.style.display = isVisible ? 'none' : 'block';

    const arrowIcon = exportButton.querySelector('.arrow-icon');
    if (arrowIcon) {
      arrowIcon.style.transform = isVisible ? 'rotate(0deg)' : 'rotate(180deg)';
    }

  });

  // Prevent dropdown clicks from closing the dropdown
  dropdownMenu.addEventListener('click', (event) => {
    event.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
  });

  // Close dropdown when clicking outside
  document.addEventListener('click', () => {
    if (dropdownMenu.style.display === 'block') {
      dropdownMenu.style.display = 'none';

      // æ¢å¤ç®­å¤´å›¾æ ‡æ–¹å‘
      const arrowIcon = exportButton.querySelector('.arrow-icon');
      if (arrowIcon) {
        arrowIcon.style.transform = 'rotate(0deg)';
      }

    }
  });

  // Add button and dropdown to container
  container.appendChild(exportButton);
  container.appendChild(dropdownMenu);

  // Remove any existing containers with the same ID to avoid conflicts
  const existingContainer = document.getElementById('deepseek-export-container');
  if (existingContainer) {
    existingContainer.remove();
  }

  // Add container to page
  document.body.appendChild(container);

  // Add CSS styles for the dropdown
  addExportStyles();

}

/**
 * Add CSS styles for the export button and dropdown
 */
function addExportStyles() {
  // Check if styles already exist
  if (document.getElementById('deepseek-export-styles')) {
    return;
  }

  // Create a link element to load the external CSS file
  const link = document.createElement('link');
  link.id = 'deepseek-export-styles';
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = chrome.runtime.getURL('styles.css');

  // Add the link to the document head
  document.head.appendChild(link);

}

/**
 * Set up MutationObserver to watch for new messages
 */
function setupChatObserver(chatContainer) {
  if (!chatContainer) {
    console.warn('No chat container provided for observer');
    return;
  }

  // Create a debounced message processor using the utility function
  const debouncedProcessMessages = debounce(processExistingMessages, 500);

  // Set up the observer
  const observer = new MutationObserver((mutations) => {
    let shouldProcess = false;

    for (const mutation of mutations) {
      if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
        shouldProcess = true;
        break;
      }
    }

    if (shouldProcess) {
      debouncedProcessMessages();
    }
  });

  // Start observing
  observer.observe(chatContainer, {
    childList: true,
    subtree: true
  });

}

/**
 * Process all existing messages in the chat
 */
function processExistingMessages() {
  // Try multiple selectors to find messages
  let messages = [];

  // Try primary selector first
  messages = document.querySelectorAll(SELECTORS.MESSAGE_CONTAINER);

  // If no messages found, try fallback selectors
  if (messages.length === 0) {
    for (const selector of FALLBACK_SELECTORS.filter(s => s.includes('message') || s.includes('chat-item'))) {
      messages = document.querySelectorAll(selector);
      if (messages.length > 0) {
        SELECTORS.MESSAGE_CONTAINER = selector; // Update for future use
        break;
      }
    }
  }

  // Special handling for DeepSeek's structure
  if (messages.length === 0) {
    // Look for AI response footers and their parent containers
    const aiFooters = document.querySelectorAll('div.fcaa63f8');
    if (aiFooters.length > 0) {

      aiFooters.forEach(footer => {
        // For each footer, find the parent message container
        let parent = footer.parentElement;
        while (parent && !parent.classList.contains('message-item') && parent.tagName !== 'BODY') {
          parent = parent.parentElement;
        }

        if (parent && parent.tagName !== 'BODY') {
          messages = [...messages, parent];
        }

        // Also add the footer itself as it contains the AI response text
        if (footer.textContent.trim() !== 'AI-generated, for reference only' &&
            !footer.textContent.includes('å†…å®¹ç”± AI ç”Ÿæˆ')) {
          messages = [...messages, footer];
        }
      });
    }
  }

  // If still no messages, try a very broad selector
  if (messages.length === 0) {
    messages = document.querySelectorAll('div');
  }

  if (messages.length === 0) {
    console.warn('No messages found to process');
    return;
  }


  const messageData = [];

  messages.forEach((messageNode) => {
    // Skip if already processed
    if (processedMessages.has(messageNode)) {
      return;
    }

    const messageObj = extractMessageData(messageNode);
    if (messageObj) {
      messageData.push(messageObj);
      processedMessages.set(messageNode, true);
    }
  });

  if (messageData.length > 0) {
    saveMessages(messageData);
  }
}

/**
 * Clean up the content extracted from a message
 * @param {string} content - The raw content
 * @param {string} role - The role of the message (user or assistant)
 * @returns {string} The cleaned content
 */
function cleanMessageContent(content, role) {
  if (!content) return '';

  // ç§»é™¤å¸¸è§çš„AIç”Ÿæˆé¡µè„šæ–‡æœ¬ï¼ˆä½¿ç”¨æ›´é€šç”¨çš„æ¨¡å¼ï¼‰
  let cleaned = content;

  // ç§»é™¤ä¸­æ–‡AIç”Ÿæˆæç¤º
  cleaned = cleaned.replace(/å†…å®¹ç”±\s*AI\s*ç”Ÿæˆ[ï¼Œ,]?.*?(?=\n|$)/g, '');

  // ç§»é™¤è‹±æ–‡AIç”Ÿæˆæç¤º
  cleaned = cleaned.replace(/(?:Generated by AI|AI-generated).*?(?=\n|$)/g, '');

  // ç§»é™¤DeepSeekç‰¹å®šçš„AIç”Ÿæˆæç¤º
  cleaned = cleaned.replace(/AI-generated, for reference only/g, '');

  // ç§»é™¤å…¶ä»–å¯èƒ½çš„AIæç¤º
  cleaned = cleaned.replace(/AI.*?generated.*?(?=\n|$)/g, '');

  // ç§»é™¤"New chat"æŒ‰é’®æ–‡æœ¬
  cleaned = cleaned.replace(/New chat/g, '');

  // ç§»é™¤å¯èƒ½çš„æŒ‰é’®å’ŒUIå…ƒç´ æ–‡æœ¬
  cleaned = cleaned.replace(/DeepThink \(R1\)/g, '');
  cleaned = cleaned.replace(/Search/g, '');
  cleaned = cleaned.replace(/Message DeepSeek/g, '');

  // ç§»é™¤å¤åˆ¶æŒ‰é’®æ–‡æœ¬
  cleaned = cleaned.replace(/Copy code/g, '');
  cleaned = cleaned.replace(/å¤åˆ¶ä»£ç /g, '');

  // ç§»é™¤å¯èƒ½çš„é¡µè„šå…ƒç´ 
  cleaned = cleaned.replace(/fcaa63f8/g, '');

  // ç§»é™¤å¤šä½™ç©ºç™½å’Œæ¢è¡Œ
  cleaned = cleaned.replace(/\n\s*\n/g, '\n');
  cleaned = cleaned.trim();

  return cleaned;
}

/**
 * Extract data from a message node
 */
function extractMessageData(messageNode) {
  try {
    // è·³è¿‡éšè—æ¶ˆæ¯
    if (messageNode.offsetParent === null) {
      return null;
    }

    // ä½¿ç”¨åŸºäºè¯­ä¹‰çš„æ–¹æ³•ç¡®å®šè§’è‰²
    const role = determineRoleBySemantics(messageNode);

    // å­˜å‚¨è§’è‰²ä»¥ä¾›å°†æ¥å‚è€ƒ
    messageNode.dataset.role = role;

    // æå–å†…å®¹ - ä½¿ç”¨è¯­ä¹‰åˆ†æ
    let content = '';

    // 1. å°è¯•æ‰¾åˆ°æ˜æ˜¾çš„å†…å®¹èŠ‚ç‚¹
    const contentNode = findContentNode(messageNode);
    if (contentNode) {
      content = contentNode.innerText || contentNode.textContent;
    } else {
      // 2. å¦‚æœæ²¡æœ‰æ˜æ˜¾çš„å†…å®¹èŠ‚ç‚¹ï¼Œä½¿ç”¨æ¶ˆæ¯èŠ‚ç‚¹çš„æ–‡æœ¬
      content = messageNode.innerText || messageNode.textContent;

      // 3. ç§»é™¤å¯èƒ½çš„AIç”Ÿæˆæ ‡è®°
      content = removeAIFooters(messageNode, content);
    }

    // æ¸…ç†å†…å®¹
    content = cleanMessageContent(content, role);

    // Skip empty messages
    if (!content) {
      return null;
    }

    // Generate element ID for reference
    const elementId = `chat-item-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

    return {
      role,
      content,
      element_id: elementId,
      hash: createHash(content + Date.now())
    };
  } catch (error) {
    console.error('Error extracting message data:', error);
    return null;
  }
}

/**
 * Save messages to chrome.storage.local
 */
function saveMessages(messages) {
  // Throttle storage updates
  const now = Date.now();
  if (now - lastStorageUpdate < STORAGE_THROTTLE) {
    return;
  }
  lastStorageUpdate = now;

  chrome.storage.local.get(['chatData'], (result) => {
    const chatData = result.chatData || {};

    // Initialize session if needed
    if (!chatData[currentSessionId]) {
      chatData[currentSessionId] = {
        messages: [],
        hashes: [],
        meta: {
          start_time: new Date().toISOString(),
          page_url: window.location.href,
          last_updated: now
        }
      };
    }

    // Add new messages, avoiding duplicates
    let newMessagesAdded = false;
    messages.forEach((message) => {
      if (!chatData[currentSessionId].hashes.includes(message.hash)) {
        chatData[currentSessionId].messages.push(message);
        chatData[currentSessionId].hashes.push(message.hash);
        newMessagesAdded = true;
      }
    });

    if (newMessagesAdded) {
      chatData[currentSessionId].meta.last_updated = now;

      // Notify background script about new messages
      chrome.runtime.sendMessage({
        action: 'newMessagesDetected',
        count: messages.length
      }, (response) => {
        // Handle response if needed
        if (chrome.runtime.lastError) {
          // Ignore errors from message sending
        }
      });

      chrome.storage.local.set({ chatData }, () => {
        if (chrome.runtime.lastError) {
          console.error('Error saving chat data:', chrome.runtime.lastError);
          // Retry with exponential backoff could be implemented here
        } else {
        }
      });
    }
  });
}

/**
 * Export the chat to a file in the specified format
 * @param {string} format - The format to export ('json', 'markdown', or 'text')
 */
function exportChat(format = 'json') {
  try {

    // ç›´æ¥ä»é¡µé¢æå–æœ€æ–°æ¶ˆæ¯
    const latestMessages = extractAllMessagesFromPage();

    if (latestMessages.length > 0) {
    }

    if (latestMessages.length === 0) {
      alert(chrome.i18n.getMessage('noMessagesFound'));
      return;
    }

    // å‡†å¤‡å¯¼å‡ºæ•°æ®
    const exportData = {
      title: `DeepSeek Chat - ${new Date().toLocaleString()}`,
      url: window.location.href,
      date: new Date().toISOString(),
      messages: latestMessages
    };

    // ä½¿ç”¨å¯¼å‡ºå‡½æ•°ä¸‹è½½èŠå¤©æ•°æ®
    downloadChat(exportData, format);
  } catch (error) {
    console.error('Error during export:', error);
    alert(chrome.i18n.getMessage('exportError'));
  }
}

/**
 * Download chat data as a file in the specified format
 * @param {Object} exportData - The data to export
 * @param {string} format - The format to export ('json', 'markdown', 'text', or 'html')
 */
function downloadChat(exportData, format = 'json') {
  try {
    // ç¡®ä¿æœ‰æ¶ˆæ¯è¦å¯¼å‡º
    if (!exportData.messages || exportData.messages.length === 0) {
      alert(chrome.i18n.getMessage('noMessagesOnPage'));
      return;
    }


    // æ£€æŸ¥æ˜¯å¦æœ‰åŒ…å«chain_of_thoughtçš„æ¶ˆæ¯
    const hasCOT = exportData.messages.some(msg => msg.chain_of_thought);

    // æ ¼å¼åŒ–å¯¼å‡ºæ•°æ®ï¼Œç¡®ä¿åŒ…å«ç”¨æˆ·é—®é¢˜ã€AIå›ç­”å’Œæ€è€ƒè¿‡ç¨‹
    // æ³¨æ„ï¼šä¿æŒåŸå§‹æ¶ˆæ¯æ•°ç»„çš„é¡ºåºä¸å˜
    const formattedData = {
      title: exportData.title,
      url: exportData.url,
      date: exportData.date,
      messages: exportData.messages.map(msg => {
        const formattedMsg = {
          role: msg.role,
          content: msg.content
        };

        // å¦‚æœæœ‰æ€è€ƒè¿‡ç¨‹ï¼Œæ·»åŠ åˆ°å¯¼å‡ºæ¶ˆæ¯ä¸­
        if (msg.chain_of_thought) {
          formattedMsg.chain_of_thought = msg.chain_of_thought;
        }

        return formattedMsg;
      })
    };

    let blob, filename, contentType;

    // æ ¹æ®æ ¼å¼å¤„ç†å¯¼å‡º
    if (format === 'markdown') {
      // è½¬æ¢ä¸ºMarkdownæ ¼å¼
      const markdownContent = convertToMarkdown(formattedData);
      blob = new Blob([markdownContent], { type: 'text/markdown' });
      contentType = 'text/markdown';
      filename = `deepseek-chat-${new Date().toISOString().replace(/[:.]/g, '-')}.md`;
    } else if (format === 'text') {
      // è½¬æ¢ä¸ºçº¯æ–‡æœ¬æ ¼å¼
      const textContent = convertToPlainText(formattedData);
      blob = new Blob([textContent], { type: 'text/plain' });
      contentType = 'text/plain';
      filename = `deepseek-chat-${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
    } else if (format === 'html') {
      // è½¬æ¢ä¸ºHTMLæ ¼å¼
      const htmlContent = convertToHTML(formattedData);
      blob = new Blob([htmlContent], { type: 'text/html' });
      contentType = 'text/html';
      filename = `deepseek-chat-${new Date().toISOString().replace(/[:.]/g, '-')}.html`;
    } else {
      // é»˜è®¤ä¸ºJSONæ ¼å¼
      blob = new Blob([JSON.stringify(formattedData, null, 2)], { type: 'application/json' });
      contentType = 'application/json';
      filename = `deepseek-chat-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
    }

    // åˆ›å»ºå¹¶ä¸‹è½½æ–‡ä»¶
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();

    // æ¸…ç†
    setTimeout(() => URL.revokeObjectURL(url), 100);

    // æ·»åŠ è§†è§‰åé¦ˆ
    const exportButton = document.getElementById('deepseek-export-btn');
    if (exportButton) {
      exportButton.classList.add('pulse');
      setTimeout(() => exportButton.classList.remove('pulse'), 500);
    }

  } catch (error) {
    console.error('Error exporting chat:', error);
    alert(chrome.i18n.getMessage('exportFailed'));
  }
}

/**
 * Convert chat data to Markdown format
 * @param {Object} data - The chat data to convert
 * @returns {string} - The Markdown content
 */
function convertToMarkdown(data) {

  // Create the header with metadata
  let markdown = `# ${data.title}\n\n`;
  markdown += `- **URL**: ${data.url}\n`;
  markdown += `- **Date**: ${new Date(data.date).toLocaleString()}\n\n`;
  markdown += `---\n\n`;

  // Process each message
  data.messages.forEach((msg, index) => {
    // Format the role header
    const roleIcon = msg.role === 'user' ? 'ğŸ§‘' : 'ğŸ¤–';
    const roleName = msg.role === 'user' ? 'User' : 'DeepSeek AI';
    markdown += `## ${roleIcon} ${roleName}\n\n`;

    // Process the content with special handling for code blocks
    const formattedContent = formatMessageContent(msg.content);
    markdown += `${formattedContent}\n\n`;

    // Add chain of thought if available
    if (msg.chain_of_thought) {
      markdown += `<details>\n<summary>Chain of Thought</summary>\n\n`;
      const formattedCOT = formatMessageContent(msg.chain_of_thought);
      markdown += `${formattedCOT}\n\n`;
      markdown += `</details>\n\n`;
    }

    // Add separator between messages
    if (index < data.messages.length - 1) {
      markdown += `---\n\n`;
    }
  });

  return markdown;
}

/**
 * Format message content for Markdown, with special handling for code blocks
 * @param {string} content - The message content to format
 * @returns {string} - The formatted content
 */
function formatMessageContent(content) {
  if (!content) return '';

  // Replace HTML tags with their Markdown equivalents
  let formatted = content
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<p>(.*?)<\/p>/gi, '$1\n\n')
    .replace(/<strong>(.*?)<\/strong>/gi, '**$1**')
    .replace(/<em>(.*?)<\/em>/gi, '*$1*')
    .replace(/<h1>(.*?)<\/h1>/gi, '# $1\n')
    .replace(/<h2>(.*?)<\/h2>/gi, '## $1\n')
    .replace(/<h3>(.*?)<\/h3>/gi, '### $1\n')
    .replace(/<h4>(.*?)<\/h4>/gi, '#### $1\n')
    .replace(/<h5>(.*?)<\/h5>/gi, '##### $1\n')
    .replace(/<h6>(.*?)<\/h6>/gi, '###### $1\n')
    .replace(/<ul>(.*?)<\/ul>/gis, (match, p1) => {
      return p1.replace(/<li>(.*?)<\/li>/gi, '- $1\n');
    })
    .replace(/<ol>(.*?)<\/ol>/gis, (match, p1) => {
      let index = 1;
      return p1.replace(/<li>(.*?)<\/li>/gi, () => {
        return `${index++}. $1\n`;
      });
    });

  // Handle code blocks
  // First, handle fenced code blocks with language specification
  formatted = formatted.replace(/<pre><code class="language-([a-zA-Z0-9]+)">([\s\S]*?)<\/code><\/pre>/gi, (match, language, code) => {
    return `\`\`\`${language}\n${code.trim()}\n\`\`\`\n`;
  });

  // Handle DeepSeek specific code blocks with language
  formatted = formatted.replace(/<div class="ds-code-block".*?data-language="([a-zA-Z0-9]+)".*?>([\s\S]*?)<\/div>/gi, (match, language, code) => {
    // Extract the actual code content, removing any nested elements like copy buttons
    const codeContent = code.replace(/<button.*?<\/button>/gi, '')
                            .replace(/<div class="ds-code-header".*?<\/div>/gi, '')
                            .replace(/<div class="ds-code-content".*?>([\s\S]*?)<\/div>/gi, '$1')
                            .trim();
    return `\`\`\`${language}\n${codeContent}\n\`\`\`\n`;
  });

  // Handle DeepSeek specific code blocks without language
  formatted = formatted.replace(/<div class="ds-code-block".*?>([\s\S]*?)<\/div>/gi, (match, code) => {
    // Extract the actual code content, removing any nested elements
    const codeContent = code.replace(/<button.*?<\/button>/gi, '')
                            .replace(/<div class="ds-code-header".*?<\/div>/gi, '')
                            .replace(/<div class="ds-code-content".*?>([\s\S]*?)<\/div>/gi, '$1')
                            .trim();
    return `\`\`\`\n${codeContent}\n\`\`\`\n`;
  });

  // Then, handle regular code blocks
  formatted = formatted.replace(/<pre><code>([\s\S]*?)<\/code><\/pre>/gi, (match, code) => {
    return `\`\`\`\n${code.trim()}\n\`\`\`\n`;
  });

  // Handle code blocks that might be in a different format (DeepSeek specific)
  formatted = formatted.replace(/<div class="[^"]*code[^"]*".*?>([\s\S]*?)<\/div>/gi, (match, code) => {
    // Check if this is likely a code block by looking for common indicators
    if (match.includes('code-block') ||
        match.includes('language-') ||
        match.includes('syntax-') ||
        match.includes('ds-code')) {
      // Extract the language if available
      const langMatch = match.match(/language-([a-zA-Z0-9]+)/i) || match.match(/data-language="([a-zA-Z0-9]+)"/i);
      const language = langMatch ? langMatch[1] : '';

      // Clean up the code content
      const cleanCode = code.replace(/<[^>]*>/g, '').trim();

      return language ?
        `\`\`\`${language}\n${cleanCode}\n\`\`\`\n` :
        `\`\`\`\n${cleanCode}\n\`\`\`\n`;
    }
    return match; // Not a code block, leave it unchanged
  });

  // Handle inline code
  formatted = formatted.replace(/<code>(.*?)<\/code>/gi, '`$1`');
  formatted = formatted.replace(/<span class="[^"]*code[^"]*">(.*?)<\/span>/gi, '`$1`');

  // Handle links
  formatted = formatted.replace(/<a href="(.*?)".*?>(.*?)<\/a>/gi, '[$2]($1)');

  // Handle images
  formatted = formatted.replace(/<img src="(.*?)".*?>/gi, '![]($1)');

  // Handle blockquotes
  formatted = formatted.replace(/<blockquote>([\s\S]*?)<\/blockquote>/gi, (match, quote) => {
    return quote.split('\n').map(line => `> ${line}`).join('\n');
  });

  // Handle tables (simplified)
  formatted = formatted.replace(/<table>([\s\S]*?)<\/table>/gi, (match, tableContent) => {
    let mdTable = '';

    // Extract header
    const headerMatch = tableContent.match(/<thead>([\s\S]*?)<\/thead>/i);
    if (headerMatch) {
      const headerCells = headerMatch[1].match(/<th>(.*?)<\/th>/gi);
      if (headerCells) {
        mdTable += '| ' + headerCells.map(cell => cell.replace(/<\/?th>/gi, '').trim()).join(' | ') + ' |\n';
        mdTable += '| ' + headerCells.map(() => '---').join(' | ') + ' |\n';
      }
    }

    // Extract body
    const bodyMatch = tableContent.match(/<tbody>([\s\S]*?)<\/tbody>/i);
    if (bodyMatch) {
      const rows = bodyMatch[1].match(/<tr>([\s\S]*?)<\/tr>/gi);
      if (rows) {
        rows.forEach(row => {
          const cells = row.match(/<td>(.*?)<\/td>/gi);
          if (cells) {
            mdTable += '| ' + cells.map(cell => cell.replace(/<\/?td>/gi, '').trim()).join(' | ') + ' |\n';
          }
        });
      }
    }

    return mdTable;
  });

  // Handle DeepSeek specific markdown blocks
  formatted = formatted.replace(/<div class="ds-markdown.*?">([\s\S]*?)<\/div>/gi, '$1');
  formatted = formatted.replace(/<div class="ds-markdown--block.*?">([\s\S]*?)<\/div>/gi, '$1');

  // Special handling for code blocks that might be in plain text with indentation
  // Look for patterns like multiple lines starting with spaces or tabs
  const lines = formatted.split('\n');
  let inCodeBlock = false;
  let codeBlockContent = [];
  let processedLines = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const nextLine = i < lines.length - 1 ? lines[i + 1] : '';

    // Check if this line looks like code (starts with spaces/tabs and has code-like content)
    const isCodeLike = /^(\s{4,}|\t+)/.test(line) &&
                      (/[=(){}\[\];]/.test(line) || // Has code symbols
                       /\b(function|const|let|var|if|else|for|while|return|import|export)\b/.test(line)); // Has code keywords

    // Check if we're entering a code block
    if (!inCodeBlock && isCodeLike && /^(\s{4,}|\t+)/.test(nextLine)) {
      inCodeBlock = true;
      codeBlockContent = [line];
      continue;
    }

    // Continue collecting code block content
    if (inCodeBlock) {
      if (isCodeLike || line.trim() === '') {
        codeBlockContent.push(line);
      } else {
        // End of code block
        processedLines.push('```');
        processedLines.push(...codeBlockContent);
        processedLines.push('```');
        processedLines.push(line);
        inCodeBlock = false;
        codeBlockContent = [];
      }
    } else {
      processedLines.push(line);
    }
  }

  // Handle any remaining code block
  if (inCodeBlock) {
    processedLines.push('```');
    processedLines.push(...codeBlockContent);
    processedLines.push('```');
  }

  // Rejoin the processed lines
  formatted = processedLines.join('\n');

  // Remove any remaining HTML tags
  formatted = formatted.replace(/<[^>]*>/g, '');

  // Decode HTML entities
  formatted = formatted
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'");

  return formatted;
}

/**
 * Convert chat data to plain text format
 * @param {Object} data - The chat data to convert
 * @returns {string} - The plain text content
 */
function convertToPlainText(data) {
  // Create the header with metadata
  let text = `${data.title}\n\n`;
  text += `URL: ${data.url}\n`;
  text += `Date: ${new Date(data.date).toLocaleString()}\n\n`;
  text += `----------------------------------------\n\n`;

  // Process each message
  data.messages.forEach((msg, index) => {
    // Format the role header
    const roleName = msg.role === 'user' ? 'User' : 'DeepSeek AI';
    text += `${roleName}:\n\n`;

    // Add the content, stripping HTML and preserving code blocks
    const plainContent = msg.content
      .replace(/<br\s*\/?>/gi, '\n')  // Replace <br> with newlines
      .replace(/<\/p>/gi, '\n\n')     // Replace </p> with double newlines
      .replace(/<[^>]*>/g, '')        // Remove all other HTML tags
      .replace(/&nbsp;/g, ' ')        // Replace &nbsp; with spaces
      .replace(/&lt;/g, '<')          // Replace &lt; with <
      .replace(/&gt;/g, '>')          // Replace &gt; with >
      .replace(/&amp;/g, '&')         // Replace &amp; with &
      .replace(/&quot;/g, '"')        // Replace &quot; with "
      .replace(/&apos;/g, "'")        // Replace &apos; with '
      .trim();                        // Trim whitespace

    text += `${plainContent}\n\n`;

    // Add chain of thought if available
    if (msg.chain_of_thought) {
      text += `Thinking process:\n\n`;
      const plainCOT = msg.chain_of_thought
        .replace(/<br\s*\/?>/gi, '\n')
        .replace(/<\/p>/gi, '\n\n')
        .replace(/<[^>]*>/g, '')
        .replace(/&nbsp;/g, ' ')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&')
        .replace(/&quot;/g, '"')
        .replace(/&apos;/g, "'")
        .trim();
      text += `${plainCOT}\n\n`;
    }

    // Add separator between messages
    if (index < data.messages.length - 1) {
      text += `----------------------------------------\n\n`;
    }
  });

  return text;
}

/**
 * ä»é¡µé¢ä¸­æå–æ‰€æœ‰æ¶ˆæ¯
 * @returns {Array} æ¶ˆæ¯æ•°ç»„
 */
function extractAllMessagesFromPage() {

  try {
    // 1. æŸ¥æ‰¾ç”¨æˆ·é—®é¢˜ (ä½¿ç”¨ .fbb737a4 ç±»)
    const userQuestions = document.querySelectorAll('.fbb737a4');

    // 2. æŸ¥æ‰¾AIå›ç­” (ä½¿ç”¨ .ds-markdown å’Œ .ds-markdown--block ç±»)
    const aiResponses = document.querySelectorAll('.ds-markdown, .ds-markdown--block');

    // 3. æŸ¥æ‰¾æ€è€ƒè¿‡ç¨‹å®¹å™¨ (ä½¿ç”¨ .e1675d8b ç±»)
    const cotContainers = document.querySelectorAll('.e1675d8b');

    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•æ¶ˆæ¯ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ³•
    if (userQuestions.length === 0 && aiResponses.length === 0 && cotContainers.length === 0) {
      return findMessagesByPattern();
    }

    // åˆ›å»ºä¸€ä¸ªæ•°ç»„æ¥å­˜å‚¨æ‰€æœ‰æ¶ˆæ¯å…ƒç´ åŠå…¶ç±»å‹å’Œä½ç½®
    const allElements = [];

    // æ·»åŠ ç”¨æˆ·é—®é¢˜
    userQuestions.forEach(el => {
      allElements.push({
        element: el,
        type: 'user',
        position: getElementPosition(el)
      });
    });

    // æ·»åŠ AIå›ç­”
    aiResponses.forEach(el => {
      allElements.push({
        element: el,
        type: 'ai',
        position: getElementPosition(el)
      });
    });

    // æ·»åŠ æ€è€ƒè¿‡ç¨‹å®¹å™¨
    cotContainers.forEach(el => {
      allElements.push({
        element: el,
        type: 'cot_container',
        position: getElementPosition(el)
      });
    });

    // æŒ‰ç…§å…ƒç´ åœ¨DOMä¸­çš„ä½ç½®æ’åº
    allElements.sort((a, b) => {
      return a.position - b.position;
    });


    // å¤„ç†æ’åºåçš„å…ƒç´ 
    const messages = [];
    let lastAiMessageIndex = -1;
    let pendingCOT = null; // å­˜å‚¨ç­‰å¾…å…³è”çš„COTå†…å®¹
    let currentUserQuestion = null;

    allElements.forEach((item, index) => {
      const { element, type } = item;
      const content = extractMessageContent(element);

      if (!content) return;

      if (type === 'user') {
        // å¤„ç†ç”¨æˆ·é—®é¢˜
        currentUserQuestion = {
          role: 'user',
          content: cleanMessageContent(content, 'user'),
          element_id: element.id || `user-${index}-${Date.now()}`
        };

        messages.push(currentUserQuestion);
        lastAiMessageIndex = -1; // é‡ç½®æœ€åä¸€ä¸ªAIæ¶ˆæ¯çš„ç´¢å¼•
      }
      else if (type === 'ai') {
        // å¤„ç†AIå›ç­”
        const aiMessage = {
          role: 'assistant',
          content: cleanMessageContent(content, 'assistant'),
          element_id: element.id || `ai-${index}-${Date.now()}`
        };

        // å¦‚æœæœ‰å¾…å¤„ç†çš„COTï¼Œå°†å…¶æ·»åŠ åˆ°è¿™ä¸ªAIæ¶ˆæ¯ä¸­
        if (pendingCOT) {
          aiMessage.chain_of_thought = pendingCOT;
          pendingCOT = null; // æ¸…é™¤å¾…å¤„ç†çš„COT
        }

        messages.push(aiMessage);
        lastAiMessageIndex = messages.length - 1;
      }
      else if (type === 'cot_container') {
        // å¤„ç†æ€è€ƒè¿‡ç¨‹å®¹å™¨
        const cotContent = extractCOTFromContainer(element);

        if (cotContent) {
          // å¦‚æœæœ‰æœ€è¿‘çš„AIæ¶ˆæ¯ï¼Œå°†æ€è€ƒè¿‡ç¨‹æ·»åŠ åˆ°è¯¥æ¶ˆæ¯
          if (lastAiMessageIndex >= 0) {
            messages[lastAiMessageIndex].chain_of_thought = cotContent;
          }
          // å¦‚æœæ²¡æœ‰æœ€è¿‘çš„AIæ¶ˆæ¯ï¼Œå­˜å‚¨COTä»¥ä¾¿ä¸ä¸‹ä¸€ä¸ªAIæ¶ˆæ¯å…³è”
          else {
            pendingCOT = cotContent;
          }
        }
      }
    });

    // å¤„ç†æœ€åå¯èƒ½å‰©ä½™çš„å¾…å¤„ç†COT
    if (pendingCOT && messages.length > 0) {
      // å°è¯•æ‰¾åˆ°æœ€åä¸€æ¡æ¶ˆæ¯
      const lastMessage = messages[messages.length - 1];

      // å¦‚æœæœ€åä¸€æ¡æ¶ˆæ¯æ˜¯AIæ¶ˆæ¯ï¼Œå°†COTæ·»åŠ åˆ°è¯¥æ¶ˆæ¯
      if (lastMessage.role === 'assistant') {
        lastMessage.chain_of_thought = pendingCOT;
      }
      // å¦‚æœæœ€åä¸€æ¡æ¶ˆæ¯æ˜¯ç”¨æˆ·æ¶ˆæ¯ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„AIæ¶ˆæ¯
      else if (lastMessage.role === 'user') {
        const aiMessage = {
          role: 'assistant',
          content: "See chain of thought reasoning below:",
          element_id: `ai-final-${Date.now()}`,
          chain_of_thought: pendingCOT
        };

        messages.push(aiMessage);
      }
    }

    return messages;
  } catch (error) {
    console.error('Error extracting messages from page:', error);
    return findMessagesByPattern();
  }
}

/**
 * ä»æ€è€ƒè¿‡ç¨‹å®¹å™¨ä¸­æå–å†…å®¹
 * @param {Element} container - æ€è€ƒè¿‡ç¨‹å®¹å™¨å…ƒç´ 
 * @returns {string} æ¸…ç†åçš„æ€è€ƒè¿‡ç¨‹å†…å®¹
 */
function extractCOTFromContainer(container) {
  try {
    if (!container) return '';

    // é¦–å…ˆå°è¯•æŸ¥æ‰¾æ‰€æœ‰ .ba94db8a å…ƒç´ 
    const cotElements = container.querySelectorAll('.ba94db8a');

    if (cotElements && cotElements.length > 0) {
      // å¦‚æœæ‰¾åˆ°äº† .ba94db8a å…ƒç´ ï¼Œæå–å®ƒä»¬çš„å†…å®¹
      const cotTexts = [];
      cotElements.forEach(el => {
        const text = el.textContent.trim();
        if (text) {
          cotTexts.push(text);
        }
      });

      // å°†æ‰€æœ‰å†…å®¹åˆå¹¶ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²
      const combinedText = cotTexts.join('\n\n');
      return cleanMessageContent(combinedText, 'assistant');
    }

    // å¦‚æœæ²¡æœ‰æ‰¾åˆ° .ba94db8a å…ƒç´ ï¼Œå°è¯•æŸ¥æ‰¾æ‰€æœ‰æ®µè½å…ƒç´ 
    const paragraphs = container.querySelectorAll('p');
    if (paragraphs && paragraphs.length > 0) {
      const paragraphTexts = [];
      paragraphs.forEach(p => {
        const text = p.textContent.trim();
        if (text) {
          paragraphTexts.push(text);
        }
      });

      if (paragraphTexts.length > 0) {
        const combinedText = paragraphTexts.join('\n\n');
        return cleanMessageContent(combinedText, 'assistant');
      }
    }

    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ®µè½å…ƒç´ ï¼Œå°è¯•ç›´æ¥æå–å®¹å™¨çš„å†…å®¹
    const directContent = container.textContent.trim();
    if (directContent) {
      return cleanMessageContent(directContent, 'assistant');
    }

    return '';
  } catch (error) {
    console.error('Error extracting COT content:', error);
    return '';
  }
}

/**
 * è·å–å…ƒç´ åœ¨DOMä¸­çš„ä½ç½®
 * @param {Element} element - è¦è·å–ä½ç½®çš„å…ƒç´ 
 * @returns {number} å…ƒç´ çš„ä½ç½®å€¼
 */
function getElementPosition(element) {
  // ä½¿ç”¨TreeWalkeréå†DOMæ ‘ï¼Œæ‰¾åˆ°å…ƒç´ çš„ä½ç½®
  const treeWalker = document.createTreeWalker(
    document.body,
    NodeFilter.SHOW_ELEMENT,
    null,
    false
  );

  let position = 0;
  let found = false;

  while (treeWalker.nextNode()) {
    position++;
    if (treeWalker.currentNode === element) {
      found = true;
      break;
    }
  }

  return found ? position : Number.MAX_SAFE_INTEGER;
}

/**
 * åŸºäºå†…å®¹æ¨¡å¼æŸ¥æ‰¾æ¶ˆæ¯
 * @returns {Array} æ¶ˆæ¯å…ƒç´ æ•°ç»„
 */
function findMessagesByPattern() {
  const extractedMessages = [];

  try {
    // 1. æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„ç”¨æˆ·æ¶ˆæ¯å®¹å™¨
    const userContainers = document.querySelectorAll('.fbb737a4, .e214291b, [data-role="user"]');

    // 2. æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„AIæ¶ˆæ¯å®¹å™¨
    const aiContainers = document.querySelectorAll('.ds-markdown, .ds-markdown--block, .c92459f0, [data-role="assistant"]');

    // 3. æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„æ€è€ƒè¿‡ç¨‹å®¹å™¨
    const cotContainers = document.querySelectorAll('.e1675d8b');
    const cotElements = document.querySelectorAll('.ba94db8a');

    // åˆ›å»ºä¸€ä¸ªæ•°ç»„æ¥å­˜å‚¨æ‰€æœ‰æ¶ˆæ¯å…ƒç´ åŠå…¶ç±»å‹å’Œä½ç½®
    const allElements = [];

    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
    userContainers.forEach(el => {
      allElements.push({
        element: el,
        type: 'user',
        position: getElementPosition(el)
      });
    });

    // æ·»åŠ AIæ¶ˆæ¯
    aiContainers.forEach(el => {
      allElements.push({
        element: el,
        type: 'ai',
        position: getElementPosition(el)
      });
    });

    // æ·»åŠ æ€è€ƒè¿‡ç¨‹å®¹å™¨
    cotContainers.forEach(el => {
      allElements.push({
        element: el,
        type: 'cot_container',
        position: getElementPosition(el)
      });
    });

    // æŒ‰ç…§å…ƒç´ åœ¨DOMä¸­çš„ä½ç½®æ’åº
    allElements.sort((a, b) => {
      return a.position - b.position;
    });


    // å¤„ç†æ’åºåçš„å…ƒç´ 
    let lastAiMessageIndex = -1;
    let pendingCOT = null; // å­˜å‚¨ç­‰å¾…å…³è”çš„COTå†…å®¹
    let currentUserQuestion = null;

    allElements.forEach((item, index) => {
      const { element, type } = item;
      const content = extractMessageContent(element);

      if (!content) return;

      if (type === 'user') {
        // å¤„ç†ç”¨æˆ·æ¶ˆæ¯
        currentUserQuestion = {
          role: 'user',
          content: cleanMessageContent(content, 'user'),
          element_id: element.id || `user-${index}-${Date.now()}`
        };

        extractedMessages.push(currentUserQuestion);
        lastAiMessageIndex = -1; // é‡ç½®æœ€åä¸€ä¸ªAIæ¶ˆæ¯çš„ç´¢å¼•
      }
      else if (type === 'ai') {
        // å¤„ç†AIæ¶ˆæ¯
        const aiMessage = {
          role: 'assistant',
          content: cleanMessageContent(content, 'assistant'),
          element_id: element.id || `ai-${index}-${Date.now()}`
        };

        // å¦‚æœæœ‰å¾…å¤„ç†çš„COTï¼Œå°†å…¶æ·»åŠ åˆ°è¿™ä¸ªAIæ¶ˆæ¯ä¸­
        if (pendingCOT) {
          aiMessage.chain_of_thought = pendingCOT;
          pendingCOT = null; // æ¸…é™¤å¾…å¤„ç†çš„COT
        }

        extractedMessages.push(aiMessage);
        lastAiMessageIndex = extractedMessages.length - 1;
      }
      else if (type === 'cot_container') {
        // å¤„ç†æ€è€ƒè¿‡ç¨‹å®¹å™¨
        const cotContent = extractCOTFromContainer(element);

        if (cotContent) {
          // å¦‚æœæœ‰æœ€è¿‘çš„AIæ¶ˆæ¯ï¼Œå°†æ€è€ƒè¿‡ç¨‹æ·»åŠ åˆ°è¯¥æ¶ˆæ¯
          if (lastAiMessageIndex >= 0) {
            extractedMessages[lastAiMessageIndex].chain_of_thought = cotContent;
          }
          // å¦‚æœæ²¡æœ‰æœ€è¿‘çš„AIæ¶ˆæ¯ï¼Œå­˜å‚¨COTä»¥ä¾¿ä¸ä¸‹ä¸€ä¸ªAIæ¶ˆæ¯å…³è”
          else {
            pendingCOT = cotContent;
          }
        }
      }
    });

    // å¤„ç†æœ€åå¯èƒ½å‰©ä½™çš„å¾…å¤„ç†COT
    if (pendingCOT && extractedMessages.length > 0) {
      // å°è¯•æ‰¾åˆ°æœ€åä¸€æ¡æ¶ˆæ¯
      const lastMessage = extractedMessages[extractedMessages.length - 1];

      // å¦‚æœæœ€åä¸€æ¡æ¶ˆæ¯æ˜¯AIæ¶ˆæ¯ï¼Œå°†COTæ·»åŠ åˆ°è¯¥æ¶ˆæ¯
      if (lastMessage.role === 'assistant') {
        lastMessage.chain_of_thought = pendingCOT;
      }
      // å¦‚æœæœ€åä¸€æ¡æ¶ˆæ¯æ˜¯ç”¨æˆ·æ¶ˆæ¯ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„AIæ¶ˆæ¯
      else if (lastMessage.role === 'user') {
        const aiMessage = {
          role: 'assistant',
          content: "See chain of thought reasoning below:",
          element_id: `ai-final-${Date.now()}`,
          chain_of_thought: pendingCOT
        };

        extractedMessages.push(aiMessage);
      }
    }

    // å¦‚æœä»ç„¶æ²¡æœ‰æ‰¾åˆ°æ¶ˆæ¯ï¼Œå°è¯•æ›´å¹¿æ³›çš„æœç´¢
    if (extractedMessages.length === 0) {

      // æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½åŒ…å«æ–‡æœ¬çš„å…ƒç´ 
      const allTextElements = document.querySelectorAll('div, p, section, article');
      const potentialMessages = Array.from(allTextElements).filter(el => {
        const text = el.textContent.trim();
        // è¿‡æ»¤æ‰å¤ªçŸ­çš„æ–‡æœ¬å’Œæ˜æ˜¾çš„UIå…ƒç´ 
        return text.length > 20 &&
               !text.includes('New chat') &&
               !text.includes('Sign in') &&
               !text.includes('Sign up') &&
               el.offsetParent !== null; // ç¡®ä¿å…ƒç´ å¯è§
      });


      // å°è¯•ç¡®å®šæ¯ä¸ªå…ƒç´ çš„è§’è‰²å¹¶æå–å†…å®¹
      potentialMessages.forEach((element, index) => {
        const role = determineRoleBySemantics(element);
        const content = extractMessageContent(element);

        if (content && role !== 'unknown') {
          extractedMessages.push({
            role,
            content: cleanMessageContent(content, role),
            element_id: element.id || `potential-message-${index}-${Date.now()}`
          });
        }
      });
    }

  } catch (error) {
    console.error('Error in pattern-based message extraction:', error);
  }

  return extractedMessages;
}

/**
 * æŸ¥æ‰¾æ¶ˆæ¯ä¸­çš„å†…å®¹èŠ‚ç‚¹
 * @param {Element} messageNode - æ¶ˆæ¯èŠ‚ç‚¹
 * @returns {Element|null} å†…å®¹èŠ‚ç‚¹æˆ–null
 */
function findContentNode(messageNode) {
  // æ£€æŸ¥æ˜¯å¦æ˜¯DeepSeekç‰¹å®šçš„æ¶ˆæ¯ç»“æ„
  if (messageNode.classList.contains('e214291b')) {
    // ç”¨æˆ·æ¶ˆæ¯ - æŸ¥æ‰¾textarea
    const textarea = messageNode.querySelector('textarea');
    if (textarea) {
      return textarea;
    }
  }

  // æ£€æŸ¥ç”¨æˆ·é—®é¢˜ç±»
  if (messageNode.classList.contains('fbb737a4')) {
    return messageNode;
  }

  // æ£€æŸ¥AIå›å¤ç±»
  if (messageNode.classList.contains('c92459f0') ||
      messageNode.classList.contains('ds-markdown') ||
      messageNode.classList.contains('ds-markdown--block')) {
    return messageNode;
  }

  // æ£€æŸ¥AIæ€è€ƒè¿‡ç¨‹ç±»
  if (messageNode.classList.contains('ba94db8a')) {
    return messageNode;
  }

  // æ£€æŸ¥æ˜¯å¦æœ‰IDä¸ºchat-inputçš„å…ƒç´ ï¼ˆç”¨æˆ·è¾“å…¥æ¡†ï¼‰
  const chatInput = messageNode.querySelector('#chat-input');
  if (chatInput) {
    return chatInput;
  }

  // æ£€æŸ¥æ˜¯å¦åŒ…å«ç‰¹å®šç±»çš„å­å…ƒç´ 
  const userContentNode = messageNode.querySelector('.fbb737a4');
  if (userContentNode) {
    return userContentNode;
  }

  const aiContentNode = messageNode.querySelector('.ds-markdown, .ds-markdown--block');
  if (aiContentNode) {
    return aiContentNode;
  }

  const cotContentNode = messageNode.querySelector('.ba94db8a');
  if (cotContentNode) {
    return cotContentNode;
  }

  // 1. æŸ¥æ‰¾å…·æœ‰å†…å®¹ç›¸å…³ç±»åçš„å…ƒç´ 
  for (const pattern of SELECTORS.CONTENT_PATTERNS) {
    const contentNodes = messageNode.querySelectorAll(`[class*="${pattern}"]`);
    if (contentNodes.length > 0) {
      // è¿”å›æœ€å¯èƒ½çš„å†…å®¹èŠ‚ç‚¹ï¼ˆé€šå¸¸æ˜¯æœ€å¤§çš„æ–‡æœ¬èŠ‚ç‚¹ï¼‰
      return Array.from(contentNodes).sort((a, b) =>
        b.textContent.length - a.textContent.length
      )[0];
    }
  }

  // 2. æŸ¥æ‰¾å…·æœ‰æ®µè½æˆ–æ–‡æœ¬ç‰¹å¾çš„å…ƒç´ 
  const textElements = messageNode.querySelectorAll('p, div > div:only-child');
  if (textElements.length > 0) {
    return Array.from(textElements).sort((a, b) =>
      b.textContent.length - a.textContent.length
    )[0];
  }

  // 3. å¦‚æœæ¶ˆæ¯èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­å…ƒç´ ï¼Œå¯èƒ½æ˜¯å†…å®¹èŠ‚ç‚¹
  if (messageNode.children.length === 1) {
    return messageNode.children[0];
  }

  return null;
}

/**
 * ç§»é™¤AIç”Ÿæˆçš„é¡µè„šæ–‡æœ¬
 * @param {Element} messageNode - æ¶ˆæ¯èŠ‚ç‚¹
 * @param {string} content - åŸå§‹å†…å®¹
 * @returns {string} æ¸…ç†åçš„å†…å®¹
 */
function removeAIFooters(messageNode, content) {
  // æŸ¥æ‰¾å¯èƒ½çš„AIé¡µè„šå…ƒç´ 
  const footerElements = Array.from(messageNode.querySelectorAll('div, p, span, .fcaa63f8'))
    .filter(el => {
      const text = el.textContent.toLowerCase();
      return SELECTORS.AI_FOOTER_PATTERNS.some(pattern =>
        text.includes(pattern.toLowerCase())
      );
    });

  // ä»å†…å®¹ä¸­ç§»é™¤é¡µè„šæ–‡æœ¬
  let cleanedContent = content;

  // ç‰¹åˆ«å¤„ç†DeepSeekçš„AIç”Ÿæˆé¡µè„š
  const deepseekFooter = messageNode.querySelector('.fcaa63f8');
  if (deepseekFooter) {
    cleanedContent = cleanedContent.replace(deepseekFooter.textContent, '');
  }

  footerElements.forEach(footer => {
    cleanedContent = cleanedContent.replace(footer.textContent, '');
  });

  // ç§»é™¤å¸¸è§çš„AIç”Ÿæˆé¡µè„šæ–‡æœ¬
  cleanedContent = cleanedContent.replace(/AI-generated, for reference only/gi, '');
  cleanedContent = cleanedContent.replace(/AI-generated/gi, '');
  cleanedContent = cleanedContent.replace(/Generated by AI/gi, '');
  cleanedContent = cleanedContent.replace(/å†…å®¹ç”±\s*AI\s*ç”Ÿæˆ/gi, '');

  return cleanedContent;
}

/**
 * åŸºäºè¯­ä¹‰ç¡®å®šæ¶ˆæ¯çš„è§’è‰²
 * @param {Element} messageNode - The message node
 * @returns {string} The role of the message ('user', 'assistant', or 'unknown')
 */
function determineRoleBySemantics(messageNode) {
  // æ£€æŸ¥data-roleå±æ€§
  if (messageNode.dataset.role === 'user') {
    return 'user';
  } else if (messageNode.dataset.role === 'assistant') {
    return 'assistant';
  }

  // æ£€æŸ¥ç‰¹å®šçš„ç±»å
  if (messageNode.classList.contains('e214291b') ||
      messageNode.classList.contains('fbb737a4') ||
      messageNode.closest('.e214291b, .fbb737a4') !== null) {
    return 'user';
  }

  if (messageNode.classList.contains('c92459f0') ||
      messageNode.classList.contains('ds-markdown') ||
      messageNode.classList.contains('ds-markdown--block') ||
      messageNode.closest('.c92459f0, .ds-markdown, .ds-markdown--block') !== null) {
    return 'assistant';
  }

  // æ£€æŸ¥æ˜¯å¦åŒ…å«æ€è€ƒè¿‡ç¨‹å…ƒç´ 
  if (messageNode.classList.contains('ba94db8a') ||
      messageNode.closest('.ba94db8a') !== null ||
      messageNode.querySelector('.ba94db8a') !== null) {
    return 'assistant';
  }

  // 1. æ£€æŸ¥ç±»åå’Œå±æ€§ä¸­çš„è§’è‰²æŒ‡ç¤º
  const classAndAttrs = messageNode.className + ' ' +
                        (messageNode.getAttribute('role') || '') + ' ' +
                        (messageNode.getAttribute('aria-label') || '');

  const classString = classAndAttrs.toLowerCase();

  // æ£€æŸ¥ç”¨æˆ·è§’è‰²æŒ‡ç¤º
  const hasUserIndicator = SELECTORS.USER_MESSAGE_PATTERNS.some(pattern =>
    classString.includes(pattern)
  );

  // æ£€æŸ¥AIè§’è‰²æŒ‡ç¤º
  const hasAIIndicator = SELECTORS.AI_MESSAGE_PATTERNS.some(pattern =>
    classString.includes(pattern)
  );

  // æ£€æŸ¥AIæ€è€ƒè¿‡ç¨‹æŒ‡ç¤º
  const hasCOTIndicator = SELECTORS.AI_COT_PATTERNS.some(pattern =>
    classString.includes(pattern)
  );

  if (hasUserIndicator && !hasAIIndicator && !hasCOTIndicator) return 'user';
  if ((hasAIIndicator || hasCOTIndicator) && !hasUserIndicator) return 'assistant';

  // 2. æ£€æŸ¥å†…å®¹ä¸­çš„AIç”ŸæˆæŒ‡ç¤º
  const content = messageNode.textContent.toLowerCase();
  const hasAIFooter = SELECTORS.AI_FOOTER_PATTERNS.some(pattern =>
    content.includes(pattern.toLowerCase())
  );

  if (hasAIFooter) return 'assistant';

  // 3. æ£€æŸ¥å­å…ƒç´ ä¸­çš„AIæŒ‡ç¤º
  const hasAIFooterElement = Array.from(messageNode.querySelectorAll('*')).some(el =>
    SELECTORS.AI_FOOTER_PATTERNS.some(pattern =>
      el.textContent.toLowerCase().includes(pattern.toLowerCase())
    )
  );

  if (hasAIFooterElement) return 'assistant';

  // æ£€æŸ¥å­å…ƒç´ ä¸­çš„ç‰¹å®šç±»
  const hasUserClass = messageNode.querySelector('.fbb737a4') !== null;
  const hasAIClass = messageNode.querySelector('.ds-markdown, .ds-markdown--block') !== null;
  const hasCOTClass = messageNode.querySelector('.ba94db8a') !== null;

  if (hasUserClass && !hasAIClass && !hasCOTClass) return 'user';
  if ((hasAIClass || hasCOTClass) && !hasUserClass) return 'assistant';

  // 4. ä½¿ç”¨äº¤æ›¿æ¨¡å¼
  const prevRole = document.querySelector('[data-role]')?.dataset.role;

  if (prevRole === 'user') {
    return 'assistant';
  } else if (prevRole === 'assistant' || prevRole === null) {
    return 'user';
  }

  // é»˜è®¤ä¸ºç”¨æˆ·æ¶ˆæ¯
  return 'user';
}

/**
 * åˆ†æé¡µé¢ç»“æ„ä»¥è¯†åˆ«èŠå¤©æ¨¡å¼
 */
function analyzePageStructure() {

  // æ£€æŸ¥æ˜¯å¦æœ‰å¸¦æœ‰data-role="user"çš„å…ƒç´ 
  const userRoleElements = document.querySelectorAll('[data-role="user"]');
  if (userRoleElements.length > 0) {
    return;
  }

  // 1. è¯†åˆ«å¯èƒ½çš„æ¶ˆæ¯å®¹å™¨
  const possibleContainers = findPossibleMessageContainers();

  // 2. è¯†åˆ«å¯¹è¯æ¨¡å¼
  identifyConversationPattern(possibleContainers);
}

/**
 * æŸ¥æ‰¾å¯èƒ½åŒ…å«æ¶ˆæ¯çš„å®¹å™¨
 * @returns {Array} å¯èƒ½çš„æ¶ˆæ¯å®¹å™¨å…ƒç´ æ•°ç»„
 */
function findPossibleMessageContainers() {
  // å¯»æ‰¾å…·æœ‰é‡å¤ç»“æ„çš„å®¹å™¨
  const allDivs = Array.from(document.querySelectorAll('div'));
  const containers = [];

  // æŸ¥æ‰¾åŒ…å«å¤šä¸ªå­å…ƒç´ ä¸”ç»“æ„ç›¸ä¼¼çš„å®¹å™¨
  allDivs.forEach(div => {
    const children = Array.from(div.children);

    // è‡³å°‘æœ‰2ä¸ªå­å…ƒç´ çš„å®¹å™¨
    if (children.length >= 2) {
      // æ£€æŸ¥å­å…ƒç´ æ˜¯å¦æœ‰ç›¸ä¼¼çš„ç»“æ„
      const similarStructure = children.filter(child =>
        child.tagName === children[0].tagName &&
        child.className === children[0].className
      ).length >= 2;

      if (similarStructure) {
        containers.push(div);
      }
    }
  });

  return containers;
}

/**
 * è¯†åˆ«å¯¹è¯æ¨¡å¼
 * @param {Array} containers å¯èƒ½çš„æ¶ˆæ¯å®¹å™¨
 */
function identifyConversationPattern(containers) {
  // å¯¹äºæ¯ä¸ªå®¹å™¨ï¼Œå°è¯•è¯†åˆ«ç”¨æˆ·/AIæ¶ˆæ¯çš„æ¨¡å¼
  containers.forEach(container => {
    const children = Array.from(container.children);

    // æ£€æŸ¥æ˜¯å¦æœ‰äº¤æ›¿çš„ç”¨æˆ·/AIæ¶ˆæ¯æ¨¡å¼
    let userMessages = 0;
    let aiMessages = 0;

    children.forEach(child => {
      const text = child.textContent.toLowerCase();
      const classList = child.className.toLowerCase();

      // æ£€æŸ¥æ˜¯å¦æ˜¯ç”¨æˆ·æ¶ˆæ¯
      const isUserMessage = SELECTORS.USER_MESSAGE_PATTERNS.some(pattern =>
        classList.includes(pattern) || text.includes(pattern)
      );

      // æ£€æŸ¥æ˜¯å¦æ˜¯AIæ¶ˆæ¯
      const isAIMessage = SELECTORS.AI_MESSAGE_PATTERNS.some(pattern =>
        classList.includes(pattern) || text.includes(pattern)
      ) || SELECTORS.AI_FOOTER_PATTERNS.some(pattern => text.includes(pattern));

      if (isUserMessage) userMessages++;
      if (isAIMessage) aiMessages++;
    });

    // å¦‚æœåŒæ—¶æœ‰ç”¨æˆ·å’ŒAIæ¶ˆæ¯ï¼Œè¿™å¯èƒ½æ˜¯ä¸€ä¸ªå¯¹è¯å®¹å™¨
    if (userMessages > 0 && aiMessages > 0) {
      // æ›´æ–°é€‰æ‹©å™¨ä»¥ä½¿ç”¨è¿™ä¸ªå®¹å™¨
      SELECTORS.IDENTIFIED_CONTAINER = container;
    }
  });
}

/**
 * Process a message element and extract its content
 * @param {Element} messageElement - The message element to process
 * @returns {Object|null} - The processed message or null if processing failed
 */
function processMessage(messageElement) {
  if (!messageElement) return null;

  try {
    // ç¡®å®šæ¶ˆæ¯è§’è‰²
    const role = determineRoleBySemantics(messageElement);

    // æŸ¥æ‰¾å†…å®¹èŠ‚ç‚¹
    const contentNode = findContentNode(messageElement);
    if (!contentNode) {
      console.warn('Could not find content node for message:', messageElement);
      return null;
    }

    // æå–æ¶ˆæ¯å†…å®¹
    let content = extractMessageContent(contentNode);
    if (!content) {
      console.warn('Could not extract content for message:', messageElement);
      return null;
    }

    // æ¸…ç†æ¶ˆæ¯å†…å®¹
    content = cleanMessageContent(content, role);

    // ç”Ÿæˆæ¶ˆæ¯çš„å”¯ä¸€æ ‡è¯†
    const elementId = messageElement.id || generateUniqueId();

    // åˆ›å»ºæ¶ˆæ¯å¯¹è±¡
    const message = {
      role,
      content,
      element_id: elementId
    };

    // å¦‚æœæ˜¯AIæ¶ˆæ¯ï¼Œå°è¯•æå–æ€è€ƒè¿‡ç¨‹
    if (role === 'assistant') {
      // æŸ¥æ‰¾ç›¸å…³çš„æ€è€ƒè¿‡ç¨‹å…ƒç´ 
      const cotElements = Array.from(messageElement.querySelectorAll('.ba94db8a'));

      // å¦‚æœåœ¨å½“å‰å…ƒç´ ä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œå°è¯•åœ¨ç›¸é‚»å…ƒç´ ä¸­æŸ¥æ‰¾
      if (cotElements.length === 0) {
        // æŸ¥æ‰¾æ¶ˆæ¯å®¹å™¨
        const messageContainer = messageElement.closest('.message-container') || messageElement.parentElement;
        if (messageContainer) {
          // æŸ¥æ‰¾åŒä¸€å®¹å™¨ä¸­çš„æ€è€ƒè¿‡ç¨‹å…ƒç´ 
          const containerCotElements = Array.from(messageContainer.querySelectorAll('.ba94db8a'));
          cotElements.push(...containerCotElements);
        }

        // æŸ¥æ‰¾ç´§éšå…¶åçš„æ€è€ƒè¿‡ç¨‹å…ƒç´ 
        let nextElement = messageElement.nextElementSibling;
        while (nextElement && cotElements.length === 0) {
          if (nextElement.classList.contains('ba94db8a') || nextElement.querySelector('.ba94db8a')) {
            cotElements.push(nextElement.classList.contains('ba94db8a') ?
              nextElement : nextElement.querySelector('.ba94db8a'));
          }
          nextElement = nextElement.nextElementSibling;
        }
      }

      // å¤„ç†æ‰¾åˆ°çš„æ€è€ƒè¿‡ç¨‹å…ƒç´ 
      if (cotElements.length > 0) {

        // åˆå¹¶æ‰€æœ‰æ€è€ƒè¿‡ç¨‹å†…å®¹
        const cotContents = cotElements.map(cotElement => {
          const cotContent = extractMessageContent(cotElement);
          return cotContent ? cleanMessageContent(cotContent, 'assistant') : '';
        }).filter(Boolean);

        if (cotContents.length > 0) {
          message.chain_of_thought = cotContents.join('\n\n');
        }
      }
    }

    return message;
  } catch (error) {
    console.error('Error processing message:', error);
    return null;
  }
}

/**
 * Extract the text content from a message node
 * @param {Element} node - The node to extract content from
 * @returns {string} - The extracted content
 */
function extractMessageContent(node) {
  if (!node) return '';

  try {
    // å¦‚æœæ˜¯è¾“å…¥å…ƒç´ ï¼Œè·å–å…¶å€¼
    if (node.tagName === 'INPUT' || node.tagName === 'TEXTAREA') {
      return node.value.trim();
    }

    // åˆ›å»ºèŠ‚ç‚¹çš„å…‹éš†ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥ä¿®æ”¹å®ƒè€Œä¸å½±å“åŸå§‹DOM
    const clone = node.cloneNode(true);

    // ç§»é™¤æ‰€æœ‰ä»£ç å—çš„å¤åˆ¶æŒ‰é’®
    clone.querySelectorAll('button').forEach(button => {
      if (button.textContent.includes('Copy') ||
          button.textContent.includes('å¤åˆ¶') ||
          button.classList.contains('copy-button')) {
        button.remove();
      }
    });

    // ç§»é™¤æ‰€æœ‰ä¸å¯è§å…ƒç´ 
    clone.querySelectorAll('*').forEach(el => {
      const style = window.getComputedStyle(el);
      if (style.display === 'none' || style.visibility === 'hidden') {
        el.remove();
      }
    });

    // è·å–æ–‡æœ¬å†…å®¹
    let content = clone.textContent.trim();

    // å¦‚æœå†…å®¹ä¸ºç©ºï¼Œå°è¯•è·å–innerHTML
    if (!content && node.innerHTML) {
      // åˆ›å»ºä¸´æ—¶å…ƒç´ æ¥è§£æHTML
      const temp = document.createElement('div');
      temp.innerHTML = node.innerHTML;

      // ç§»é™¤æ‰€æœ‰è„šæœ¬å’Œæ ·å¼æ ‡ç­¾
      temp.querySelectorAll('script, style').forEach(el => el.remove());

      content = temp.textContent.trim();
    }

    return content;
  } catch (error) {
    console.error('Error extracting message content:', error);
    return '';
  }
}

/**
 * Generate a unique ID for a message
 * @returns {string} - A unique ID
 */
function generateUniqueId() {
  return 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
}

/**
 * Detect if a DOM element is a code block in DeepSeek's format
 * @param {Element} element - The element to check
 * @returns {Object|null} - Code block info or null if not a code block
 */
function detectDeepSeekCodeBlock(element) {
  if (!element) return null;

  try {
    // Check for DeepSeek specific code block classes
    if (element.classList.contains('ds-code-block') ||
        element.classList.contains('code-block') ||
        element.querySelector('.ds-code-block, .code-block')) {

      // Find the target element (either this element or a child)
      const targetElement = element.classList.contains('ds-code-block') || element.classList.contains('code-block')
        ? element
        : element.querySelector('.ds-code-block, .code-block');

      if (!targetElement) return null;

      // Try to find the language
      let language = '';

      // Check data-language attribute
      if (targetElement.hasAttribute('data-language')) {
        language = targetElement.getAttribute('data-language');
      }

      // Check for language in class names
      if (!language) {
        const classMatch = Array.from(targetElement.classList).find(cls => cls.startsWith('language-'));
        if (classMatch) {
          language = classMatch.replace('language-', '');
        }
      }

      // Find the code content
      let codeContent = '';

      // First try to find a specific code content container
      const codeContentElement = targetElement.querySelector('.ds-code-content, .code-content');
      if (codeContentElement) {
        codeContent = codeContentElement.textContent;
      } else {
        // Otherwise use the element's text content, excluding any buttons or headers
        const clone = targetElement.cloneNode(true);

        // Remove copy buttons and headers
        clone.querySelectorAll('button, .ds-code-header, .code-header').forEach(el => el.remove());

        codeContent = clone.textContent;
      }

      return {
        language,
        content: codeContent.trim()
      };
    }

    // Check for pre/code elements
    const preElement = element.tagName === 'PRE' ? element : element.querySelector('pre');
    if (preElement) {
      const codeElement = preElement.querySelector('code');
      if (codeElement) {
        // Check for language class
        let language = '';
        const classMatch = Array.from(codeElement.classList).find(cls => cls.startsWith('language-'));
        if (classMatch) {
          language = classMatch.replace('language-', '');
        }

        return {
          language,
          content: codeElement.textContent.trim()
        };
      }
    }

    return null;
  } catch (error) {
    console.error('Error detecting code block:', error);
    return null;
  }
}

/**
 * Extract code blocks from a message element
 * @param {Element} messageElement - The message element to process
 * @returns {Array} - Array of code block objects with language and content
 */
function extractCodeBlocks(messageElement) {
  if (!messageElement) return [];

  const codeBlocks = [];

  try {
    // Find all potential code block elements
    const potentialCodeBlocks = [
      ...messageElement.querySelectorAll('.ds-code-block, .code-block, pre, [class*="code"]'),
      ...Array.from(messageElement.querySelectorAll('div')).filter(div => {
        const text = div.textContent;
        // Look for indented blocks with code-like content
        return text.split('\n').filter(line =>
          /^\s{4,}/.test(line) && /[=(){}\[\];]/.test(line)
        ).length > 2;
      })
    ];

    // Process each potential code block
    potentialCodeBlocks.forEach(element => {
      const codeBlock = detectDeepSeekCodeBlock(element);
      if (codeBlock) {
        codeBlocks.push(codeBlock);

        // Mark this element as processed to avoid duplicate processing
        element.dataset.processed = 'true';
      }
    });

    return codeBlocks;
  } catch (error) {
    console.error('Error extracting code blocks:', error);
    return [];
  }
}

/**
 * Convert chat data to HTML format
 * @param {Object} data - The chat data to convert
 * @returns {string} - The HTML content
 */
function convertToHTML(data) {
  // åˆ›å»ºåŸºæœ¬çš„HTMLç»“æ„
  let html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${data.title}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f9f9f9;
    }
    .chat-header {
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 1px solid #eaeaea;
    }
    .chat-title {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    .chat-metadata {
      font-size: 14px;
      color: #666;
      margin-bottom: 5px;
    }
    .message-container {
      margin-bottom: 25px;
      padding-bottom: 25px;
      border-bottom: 1px solid #eaeaea;
    }
    .message-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .user-message .message-header {
      color: #2962FF;
    }
    .ai-message .message-header {
      color: #00796B;
    }
    .message-role {
      font-weight: bold;
      font-size: 16px;
      margin-left: 8px;
    }
    .message-content {
      background-color: #fff;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .user-message .message-content {
      background-color: #E3F2FD;
    }
    .ai-message .message-content {
      background-color: #E0F2F1;
    }
    .chain-of-thought {
      margin-top: 15px;
      padding: 12px;
      background-color: #FFF8E1;
      border-radius: 6px;
      border-left: 3px solid #FFB300;
    }
    .chain-of-thought-header {
      font-weight: bold;
      margin-bottom: 8px;
      color: #F57C00;
    }
    pre {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
    }
    code {
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="chat-header">
    <div class="chat-title">${data.title}</div>
    <div class="chat-metadata">URL: ${data.url}</div>
    <div class="chat-metadata">Date: ${new Date(data.date).toLocaleString()}</div>
  </div>
`;

  // å¤„ç†æ¯æ¡æ¶ˆæ¯
  data.messages.forEach(msg => {
    const roleClass = msg.role === 'user' ? 'user-message' : 'ai-message';
    const roleIcon = msg.role === 'user' ? 'ğŸ§‘' : 'ğŸ¤–';
    const roleName = msg.role === 'user' ? 'User' : 'DeepSeek AI';

    html += `  <div class="message-container ${roleClass}">
    <div class="message-header">
      <span>${roleIcon}</span>
      <span class="message-role">${roleName}</span>
    </div>
    <div class="message-content">
      ${msg.content}
    </div>`;

    // æ·»åŠ æ€è€ƒè¿‡ç¨‹ï¼ˆå¦‚æœæœ‰ï¼‰
    if (msg.chain_of_thought) {
      html += `    <div class="chain-of-thought">
      <div class="chain-of-thought-header">Thinking Process:</div>
      ${msg.chain_of_thought}
    </div>`;
    }

    html += `  </div>\n`;
  });

  // å…³é—­HTMLç»“æ„
  html += `</body>
</html>`;

  return html;
}

// Start the extension
init();
