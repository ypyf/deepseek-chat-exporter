/**
 * DeepSeek Chat Exporter - Content Script
 *
 * This script monitors the DeepSeek chat interface, extracts messages,
 * and provides functionality to export conversations as JSON.
 */

// DOM Selectors
const SELECTORS = {
  // 基于语义和结构模式的选择器
  CHAT_CONTAINER: 'main, [role="main"], .chat-container, .conversation, body',
  MESSAGE_CONTAINER: '[role="log"], .messages, .conversation-container, .ds-conversation',
  USER_MESSAGE_PATTERNS: ['user', 'human', 'you', 'question', 'query', 'input', 'e214291b', 'fbb737a4'],
  AI_MESSAGE_PATTERNS: ['ai', 'assistant', 'bot', 'chatbot', 'answer', 'response', 'generated', 'c92459f0', 'ds-markdown', 'ds-markdown--block'],
  AI_COT_PATTERNS: ['ba94db8a'], // Chain of thought reasoning
  CONTENT_PATTERNS: ['content', 'text', 'message', 'chat-content', 'c92459f0', 'e214291b', 'fbb737a4', 'ds-markdown', 'ds-markdown--block', 'ba94db8a'],
  AI_FOOTER_PATTERNS: ['AI-generated', 'Generated by AI', 'AI 生成', 'AI-generated, for reference only'],
  // 直接选择器
  USER_ELEMENTS: '[data-role="user"], .e214291b, .fbb737a4'
};

// Fallback selectors to try if primary selectors fail
const FALLBACK_SELECTORS = [
  // Chat container fallbacks
  'div.ds-conversation',
  '.ds-chat-container',
  'div[class*="conversation"]',
  'div[class*="chat"]',
  '.cbcaa82c',

  // Message item fallbacks
  'div[class*="message"]',
  'div[class*="chat-item"]',
  '.e214291b', // User message container
  '.c92459f0', // AI message container

  // Content text fallbacks
  'div[class*="content"]',
  'div[class*="text"]',
  '.e214291b textarea', // User input
  '.c92459f0' // AI response
];

// Cache of processed messages to prevent duplicates
let processedMessages = new WeakMap();

// Current session data
let currentSessionId = generateSessionId();
let lastStorageUpdate = 0;
const STORAGE_THROTTLE = 1000; // Limit storage updates to once per second

/**
 * Check if the current page is a DeepSeek chat page
 * @returns {boolean} True if the page is a DeepSeek chat page
 */
function isDeepSeekChatPage() {
  // 检查URL
  const url = window.location.href;

  // 首先检查是否有DeepSeek特定的元素
  if (document.querySelector('.e214291b, .c92459f0, .cbcaa82c, .ds-conversation, #chat-input') !== null) {
    return true;
  }

  // 检查是否有data-role="user"元素
    if (document.querySelectorAll('[data-role="user"]').length > 0) {
      return true;
    }

    // 如果URL包含deepseek，进行更详细的检查
    if (url.includes('deepseek.com') || url.includes('deepseek.ai')) {
      // 检查页面是否包含聊天界面的特征
      const hasChatElements =
        // 检查是否有对话容器
        document.querySelector('[role="log"]') !== null ||
        // 检查是否有AI生成内容的指示
        Array.from(document.querySelectorAll('div')).some(div =>
          SELECTORS.AI_FOOTER_PATTERNS.some(pattern =>
            div.textContent.includes(pattern)
          )
        ) ||
        // 检查是否有输入框
        document.querySelector('textarea, [role="textbox"]') !== null;

      return hasChatElements;
    }

  return false;
}

/**
 * Debug the message structure on the page
 */
function debugMessageStructure() {

  try {
    // 1. 查找对话容器
    const conversationContainer = document.querySelector('.ds-conversation, .cbcaa82c');

    if (conversationContainer) {
      // 2. 记录容器的子元素

      // 3. 检查每个子元素的类名和结构
      Array.from(conversationContainer.children).forEach((child, index) => {

        // 4. 检查是否包含用户/AI消息特征
        const hasUserClass = child.querySelector('.fbb737a4, .e214291b') !== null ||
                            child.classList.contains('fbb737a4') ||
                            child.classList.contains('e214291b');

        const hasAIClass = child.querySelector('.ds-markdown, .ds-markdown--block, .c92459f0') !== null ||
                          child.classList.contains('ds-markdown') ||
                          child.classList.contains('ds-markdown--block') ||
                          child.classList.contains('c92459f0');

        const hasCOTClass = child.querySelector('.ba94db8a') !== null ||
                           child.classList.contains('ba94db8a');


        // 5. 尝试提取内容
        const content = extractMessageContent(child);
      });
    }

    // 6. 查找所有可能的用户消息元素
    const userElements = document.querySelectorAll('.fbb737a4, .e214291b, [data-role="user"]');
    userElements.forEach((el, i) => {
    });

    // 7. 查找所有可能的AI消息元素
    const aiElements = document.querySelectorAll('.ds-markdown, .ds-markdown--block, .c92459f0, [data-role="assistant"]');
    aiElements.forEach((el, i) => {
    });

    // 8. 查找所有可能的思考过程元素
    const cotElements = document.querySelectorAll('.ba94db8a');
    cotElements.forEach((el, i) => {
    });

    // 9. 记录页面上所有类名，帮助识别新的模式
    const allClasses = new Set();
    document.querySelectorAll('*').forEach(el => {
      if (el.className && typeof el.className === 'string') {
        el.className.split(' ').forEach(cls => {
          if (cls) allClasses.add(cls);
        });
      }
    });
  } catch (error) {
    console.error('Error debugging message structure:', error);
  }
}

/**
 * Initialize the extension
 */
function init() {
  try {

    // 检查是否是DeepSeek聊天页面
    if (!isDeepSeekChatPage()) {
      return;
    }


    // 注入导出按钮
    setTimeout(() => {
      try {
        injectExportButton();
      } catch (buttonError) {
        console.error('Error injecting export button:', buttonError);
        // Try again with a simpler approach
        try {
          const simpleButton = document.createElement('button');
          simpleButton.id = 'deepseek-export-btn-simple';
          simpleButton.textContent = 'Export Chat';
          simpleButton.style.cssText = 'position:fixed;top:20px;right:20px;z-index:9999999;background:#4285f4;color:white;border:none;border-radius:12px;padding:10px 16px;font-size:14px;cursor:pointer;';
          simpleButton.onclick = () => exportChat('json');
          document.body.appendChild(simpleButton);
        } catch (simpleButtonError) {
          console.error('Failed to inject simple button:', simpleButtonError);
        }
      }
    }, 1000);

    // 首先进行一次调试，了解页面结构
    debugMessageStructure();

    // 设置观察器来监视页面变化，特别是聊天消息的变化
    const observer = new MutationObserver(debounce(() => {

      // 当页面内容变化时，尝试提取新消息
      const messages = extractAllMessagesFromPage();
      if (messages.length > 0) {
      } else {
      }
    }, 1000));

    // 查找聊天容器
    const chatContainer = document.querySelector('.ds-conversation, .cbcaa82c');

    if (chatContainer) {
      observer.observe(chatContainer, {
        childList: true,
        subtree: true,
        characterData: true,
        attributes: true
      });
    } else {
      console.warn('Chat container not found, observing body');
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
    }

    // 初始提取消息
    setTimeout(() => {
      const messages = extractAllMessagesFromPage();

      if (messages.length > 0) {
      } else {
        console.warn('No messages found on initial load');
        // 如果没有找到消息，再次调试页面结构
        debugMessageStructure();
      }
    }, 2000);
  } catch (error) {
    console.error('Error initializing extension:', error);
    // Try to recover by at least injecting the export button
    try {
      setTimeout(() => {
        injectExportButton();
      }, 2000);
    } catch (buttonError) {
      console.error('Failed to inject export button:', buttonError);
    }
  }
}

/**
 * Find the chat container with multiple fallback attempts
 * @returns {Promise<Element|null>} The chat container element or null if not found
 */
function findChatContainer() {
  return new Promise(resolve => {
    // First try the primary selector
    let container = document.querySelector(SELECTORS.CHAT_CONTAINER);

    if (container) {
      resolve(container);
      return;
    }

    // Try fallback selectors
    for (const selector of FALLBACK_SELECTORS) {
      container = document.querySelector(selector);
      if (container) {
        // Update the selector for future use
        SELECTORS.CHAT_CONTAINER = selector;
        resolve(container);
        return;
      }
    }

    // If still not found, try again after a delay (page might be loading)
    console.warn('Chat container not found. Retrying in 2 seconds...');
    setTimeout(() => {
      // One last attempt with body as fallback
      const lastResort = document.body;
      resolve(lastResort);
    }, 2000);
  });
}

/**
 * Generate a unique session ID based on timestamp
 */
function generateSessionId() {
  return `session_${Date.now()}`;
}

/**
 * Create a simple hash for message deduplication
 */
function createHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash.toString(16);
}

/**
 * Inject the export button with dropdown menu into the page
 */
function injectExportButton() {
  // Check if button already exists
  if (document.getElementById('deepseek-export-btn')) {
    return;
  }

  // Create container for the button and dropdown
  const container = document.createElement('div');
  container.id = 'deepseek-export-container';
  container.className = 'deepseek-export-container';

  // Create the main export button
  const exportButton = document.createElement('button');
  exportButton.id = 'deepseek-export-btn';
  exportButton.className = 'deepseek-export-btn';

  // 添加文本和箭头图标
  const buttonText = document.createElement('span');
  buttonText.textContent = chrome.i18n.getMessage('exportButtonText') || 'Export Chat';

  // 创建 SVG 箭头图标 - 使用用户提供的SVG
  const arrowIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  arrowIcon.classList.add('arrow-icon');
  arrowIcon.setAttribute('viewBox', '0 0 24 24');
  arrowIcon.setAttribute('fill', 'none');
  arrowIcon.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('d', 'M12 15.5L7 10.5L8.41 9.09L12 12.67L15.59 9.09L17 10.5L12 15.5Z');
  path.setAttribute('fill', 'currentColor');
  path.setAttribute('stroke-linejoin', 'round');

  arrowIcon.appendChild(path);

  // 将文本和图标添加到按钮
  exportButton.appendChild(buttonText);
  exportButton.appendChild(arrowIcon);

  // Create the dropdown menu
  const dropdownMenu = document.createElement('div');
  dropdownMenu.id = 'deepseek-export-dropdown';
  dropdownMenu.className = 'deepseek-export-dropdown';
  dropdownMenu.style.display = 'none';

  // Create export as JSON option
  const jsonOption = document.createElement('div');
  jsonOption.className = 'deepseek-export-option';
  jsonOption.textContent = chrome.i18n.getMessage('exportAsJSON') || 'Export as JSON';
  jsonOption.addEventListener('click', (e) => {
    e.stopPropagation();
    exportChat('json');
    dropdownMenu.style.display = 'none';
  });

  // Create export as Markdown option
  const markdownOption = document.createElement('div');
  markdownOption.className = 'deepseek-export-option';
  markdownOption.textContent = chrome.i18n.getMessage('exportAsMarkdown') || 'Export as Markdown';
  markdownOption.addEventListener('click', (e) => {
    e.stopPropagation();
    exportChat('markdown');
    dropdownMenu.style.display = 'none';
  });

  // Create export as Text option
  const textOption = document.createElement('div');
  textOption.className = 'deepseek-export-option';
  textOption.textContent = chrome.i18n.getMessage('exportAsText') || 'Export as Plain Text';
  textOption.addEventListener('click', (e) => {
    e.stopPropagation();
    exportChat('text');
    dropdownMenu.style.display = 'none';
  });

  // Create export as HTML option
  const htmlOption = document.createElement('div');
  htmlOption.className = 'deepseek-export-option';
  htmlOption.textContent = chrome.i18n.getMessage('exportAsHTML') || 'Export as HTML';
  htmlOption.addEventListener('click', (e) => {
    e.stopPropagation();
    exportChat('html');
    dropdownMenu.style.display = 'none';
  });

  // Add options to dropdown menu
  dropdownMenu.appendChild(jsonOption);
  dropdownMenu.appendChild(markdownOption);
  dropdownMenu.appendChild(textOption);
  dropdownMenu.appendChild(htmlOption);

  // Toggle dropdown menu when clicking the export button
  exportButton.addEventListener('click', (event) => {
    event.stopPropagation(); // 阻止事件冒泡
    const isVisible = dropdownMenu.style.display === 'block';
    dropdownMenu.style.display = isVisible ? 'none' : 'block';

    const arrowIcon = exportButton.querySelector('.arrow-icon');
    if (arrowIcon) {
      arrowIcon.style.transform = isVisible ? 'rotate(0deg)' : 'rotate(180deg)';
    }

  });

  // Prevent dropdown clicks from closing the dropdown
  dropdownMenu.addEventListener('click', (event) => {
    event.stopPropagation(); // 阻止事件冒泡
  });

  // Close dropdown when clicking outside
  document.addEventListener('click', () => {
    if (dropdownMenu.style.display === 'block') {
      dropdownMenu.style.display = 'none';

      // 恢复箭头图标方向
      const arrowIcon = exportButton.querySelector('.arrow-icon');
      if (arrowIcon) {
        arrowIcon.style.transform = 'rotate(0deg)';
      }

    }
  });

  // Add button and dropdown to container
  container.appendChild(exportButton);
  container.appendChild(dropdownMenu);

  // Remove any existing containers with the same ID to avoid conflicts
  const existingContainer = document.getElementById('deepseek-export-container');
  if (existingContainer) {
    existingContainer.remove();
  }

  // Add container to page
  document.body.appendChild(container);

  // Add CSS styles for the dropdown
  addExportStyles();

}

/**
 * Add CSS styles for the export button and dropdown
 */
function addExportStyles() {
  // Check if styles already exist
  if (document.getElementById('deepseek-export-styles')) {
    return;
  }

  // Create a link element to load the external CSS file
  const link = document.createElement('link');
  link.id = 'deepseek-export-styles';
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = chrome.runtime.getURL('styles.css');

  // Add the link to the document head
  document.head.appendChild(link);

}

/**
 * Set up MutationObserver to watch for new messages
 */
function setupChatObserver(chatContainer) {
  if (!chatContainer) {
    console.warn('No chat container provided for observer');
    return;
  }

  // Create a debounced message processor using the utility function
  const debouncedProcessMessages = debounce(processExistingMessages, 500);

  // Set up the observer
  const observer = new MutationObserver((mutations) => {
    let shouldProcess = false;

    for (const mutation of mutations) {
      if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
        shouldProcess = true;
        break;
      }
    }

    if (shouldProcess) {
      debouncedProcessMessages();
    }
  });

  // Start observing
  observer.observe(chatContainer, {
    childList: true,
    subtree: true
  });

}

/**
 * Process all existing messages in the chat
 */
function processExistingMessages() {
  // Try multiple selectors to find messages
  let messages = [];

  // Try primary selector first
  messages = document.querySelectorAll(SELECTORS.MESSAGE_CONTAINER);

  // If no messages found, try fallback selectors
  if (messages.length === 0) {
    for (const selector of FALLBACK_SELECTORS.filter(s => s.includes('message') || s.includes('chat-item'))) {
      messages = document.querySelectorAll(selector);
      if (messages.length > 0) {
        SELECTORS.MESSAGE_CONTAINER = selector; // Update for future use
        break;
      }
    }
  }

  // Special handling for DeepSeek's structure
  if (messages.length === 0) {
    // Look for AI response footers and their parent containers
    const aiFooters = document.querySelectorAll('div.fcaa63f8');
    if (aiFooters.length > 0) {

      aiFooters.forEach(footer => {
        // For each footer, find the parent message container
        let parent = footer.parentElement;
        while (parent && !parent.classList.contains('message-item') && parent.tagName !== 'BODY') {
          parent = parent.parentElement;
        }

        if (parent && parent.tagName !== 'BODY') {
          messages = [...messages, parent];
        }

        // Also add the footer itself as it contains the AI response text
        if (footer.textContent.trim() !== 'AI-generated, for reference only' &&
            !footer.textContent.includes('内容由 AI 生成')) {
          messages = [...messages, footer];
        }
      });
    }
  }

  // If still no messages, try a very broad selector
  if (messages.length === 0) {
    messages = document.querySelectorAll('div');
  }

  if (messages.length === 0) {
    console.warn('No messages found to process');
    return;
  }


  const messageData = [];

  messages.forEach((messageNode) => {
    // Skip if already processed
    if (processedMessages.has(messageNode)) {
      return;
    }

    const messageObj = extractMessageData(messageNode);
    if (messageObj) {
      messageData.push(messageObj);
      processedMessages.set(messageNode, true);
    }
  });

  if (messageData.length > 0) {
    saveMessages(messageData);
  }
}

/**
 * Clean up the content extracted from a message
 * @param {string} content - The raw content
 * @param {string} role - The role of the message (user or assistant)
 * @returns {string} The cleaned content
 */
function cleanMessageContent(content, role) {
  if (!content) return '';

  // 移除常见的AI生成页脚文本（使用更通用的模式）
  let cleaned = content;

  // 移除中文AI生成提示
  cleaned = cleaned.replace(/内容由\s*AI\s*生成[，,]?.*?(?=\n|$)/g, '');

  // 移除英文AI生成提示
  cleaned = cleaned.replace(/(?:Generated by AI|AI-generated).*?(?=\n|$)/g, '');

  // 移除DeepSeek特定的AI生成提示
  cleaned = cleaned.replace(/AI-generated, for reference only/g, '');

  // 移除其他可能的AI提示
  cleaned = cleaned.replace(/AI.*?generated.*?(?=\n|$)/g, '');

  // 移除"New chat"按钮文本
  cleaned = cleaned.replace(/New chat/g, '');

  // 移除可能的按钮和UI元素文本
  cleaned = cleaned.replace(/DeepThink \(R1\)/g, '');
  cleaned = cleaned.replace(/Search/g, '');
  cleaned = cleaned.replace(/Message DeepSeek/g, '');

  // 移除复制按钮文本
  cleaned = cleaned.replace(/Copy code/g, '');
  cleaned = cleaned.replace(/复制代码/g, '');

  // 移除可能的页脚元素
  cleaned = cleaned.replace(/fcaa63f8/g, '');

  // 移除多余空白和换行
  cleaned = cleaned.replace(/\n\s*\n/g, '\n');
  cleaned = cleaned.trim();

  return cleaned;
}

/**
 * Extract data from a message node
 */
function extractMessageData(messageNode) {
  try {
    // 跳过隐藏消息
    if (messageNode.offsetParent === null) {
      return null;
    }

    // 使用基于语义的方法确定角色
    const role = determineRoleBySemantics(messageNode);

    // 存储角色以供将来参考
    messageNode.dataset.role = role;

    // 提取内容 - 使用语义分析
    let content = '';

    // 1. 尝试找到明显的内容节点
    const contentNode = findContentNode(messageNode);
    if (contentNode) {
      content = contentNode.innerText || contentNode.textContent;
    } else {
      // 2. 如果没有明显的内容节点，使用消息节点的文本
      content = messageNode.innerText || messageNode.textContent;

      // 3. 移除可能的AI生成标记
      content = removeAIFooters(messageNode, content);
    }

    // 清理内容
    content = cleanMessageContent(content, role);

    // Skip empty messages
    if (!content) {
      return null;
    }

    // Generate element ID for reference
    const elementId = `chat-item-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

    return {
      role,
      content,
      element_id: elementId,
      hash: createHash(content + Date.now())
    };
  } catch (error) {
    console.error('Error extracting message data:', error);
    return null;
  }
}

/**
 * Save messages to chrome.storage.local
 */
function saveMessages(messages) {
  // Throttle storage updates
  const now = Date.now();
  if (now - lastStorageUpdate < STORAGE_THROTTLE) {
    return;
  }
  lastStorageUpdate = now;

  chrome.storage.local.get(['chatData'], (result) => {
    const chatData = result.chatData || {};

    // Initialize session if needed
    if (!chatData[currentSessionId]) {
      chatData[currentSessionId] = {
        messages: [],
        hashes: [],
        meta: {
          start_time: new Date().toISOString(),
          page_url: window.location.href,
          last_updated: now
        }
      };
    }

    // Add new messages, avoiding duplicates
    let newMessagesAdded = false;
    messages.forEach((message) => {
      if (!chatData[currentSessionId].hashes.includes(message.hash)) {
        chatData[currentSessionId].messages.push(message);
        chatData[currentSessionId].hashes.push(message.hash);
        newMessagesAdded = true;
      }
    });

    if (newMessagesAdded) {
      chatData[currentSessionId].meta.last_updated = now;

      // Notify background script about new messages
      chrome.runtime.sendMessage({
        action: 'newMessagesDetected',
        count: messages.length
      }, (response) => {
        // Handle response if needed
        if (chrome.runtime.lastError) {
          // Ignore errors from message sending
        }
      });

      chrome.storage.local.set({ chatData }, () => {
        if (chrome.runtime.lastError) {
          console.error('Error saving chat data:', chrome.runtime.lastError);
          // Retry with exponential backoff could be implemented here
        } else {
        }
      });
    }
  });
}

/**
 * Export the chat to a file in the specified format
 * @param {string} format - The format to export ('json', 'markdown', or 'text')
 */
function exportChat(format = 'json') {
  try {

    // 直接从页面提取最新消息
    const latestMessages = extractAllMessagesFromPage();

    if (latestMessages.length > 0) {
    }

    if (latestMessages.length === 0) {
      alert(chrome.i18n.getMessage('noMessagesFound'));
      return;
    }

    // 准备导出数据
    const exportData = {
      title: `DeepSeek Chat - ${new Date().toLocaleString()}`,
      url: window.location.href,
      date: new Date().toISOString(),
      messages: latestMessages
    };

    // 使用导出函数下载聊天数据
    downloadChat(exportData, format);
  } catch (error) {
    console.error('Error during export:', error);
    alert(chrome.i18n.getMessage('exportError'));
  }
}

/**
 * Download chat data as a file in the specified format
 * @param {Object} exportData - The data to export
 * @param {string} format - The format to export ('json', 'markdown', 'text', or 'html')
 */
function downloadChat(exportData, format = 'json') {
  try {
    // 确保有消息要导出
    if (!exportData.messages || exportData.messages.length === 0) {
      alert(chrome.i18n.getMessage('noMessagesOnPage'));
      return;
    }


    // 检查是否有包含chain_of_thought的消息
    const hasCOT = exportData.messages.some(msg => msg.chain_of_thought);

    // 格式化导出数据，确保包含用户问题、AI回答和思考过程
    // 注意：保持原始消息数组的顺序不变
    const formattedData = {
      title: exportData.title,
      url: exportData.url,
      date: exportData.date,
      messages: exportData.messages.map(msg => {
        const formattedMsg = {
          role: msg.role,
          content: msg.content
        };

        // 如果有思考过程，添加到导出消息中
        if (msg.chain_of_thought) {
          formattedMsg.chain_of_thought = msg.chain_of_thought;
        }

        return formattedMsg;
      })
    };

    let blob, filename, contentType;

    // 根据格式处理导出
    if (format === 'markdown') {
      // 转换为Markdown格式
      const markdownContent = convertToMarkdown(formattedData);
      blob = new Blob([markdownContent], { type: 'text/markdown' });
      contentType = 'text/markdown';
      filename = `deepseek-chat-${new Date().toISOString().replace(/[:.]/g, '-')}.md`;
    } else if (format === 'text') {
      // 转换为纯文本格式
      const textContent = convertToPlainText(formattedData);
      blob = new Blob([textContent], { type: 'text/plain' });
      contentType = 'text/plain';
      filename = `deepseek-chat-${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
    } else if (format === 'html') {
      // 转换为HTML格式
      const htmlContent = convertToHTML(formattedData);
      blob = new Blob([htmlContent], { type: 'text/html' });
      contentType = 'text/html';
      filename = `deepseek-chat-${new Date().toISOString().replace(/[:.]/g, '-')}.html`;
    } else {
      // 默认为JSON格式
      blob = new Blob([JSON.stringify(formattedData, null, 2)], { type: 'application/json' });
      contentType = 'application/json';
      filename = `deepseek-chat-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
    }

    // 创建并下载文件
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();

    // 清理
    setTimeout(() => URL.revokeObjectURL(url), 100);

    // 添加视觉反馈
    const exportButton = document.getElementById('deepseek-export-btn');
    if (exportButton) {
      exportButton.classList.add('pulse');
      setTimeout(() => exportButton.classList.remove('pulse'), 500);
    }

  } catch (error) {
    console.error('Error exporting chat:', error);
    alert(chrome.i18n.getMessage('exportFailed'));
  }
}

/**
 * Convert chat data to Markdown format
 * @param {Object} data - The chat data to convert
 * @returns {string} - The Markdown content
 */
function convertToMarkdown(data) {

  // Create the header with metadata
  let markdown = `# ${data.title}\n\n`;
  markdown += `- **URL**: ${data.url}\n`;
  markdown += `- **Date**: ${new Date(data.date).toLocaleString()}\n\n`;
  markdown += `---\n\n`;

  // Process each message
  data.messages.forEach((msg, index) => {
    // Format the role header
    const roleIcon = msg.role === 'user' ? '🧑' : '🤖';
    const roleName = msg.role === 'user' ? 'User' : 'DeepSeek AI';
    markdown += `## ${roleIcon} ${roleName}\n\n`;

    // Process the content with special handling for code blocks
    const formattedContent = formatMessageContent(msg.content);
    markdown += `${formattedContent}\n\n`;

    // Add chain of thought if available
    if (msg.chain_of_thought) {
      markdown += `<details>\n<summary>Chain of Thought</summary>\n\n`;
      const formattedCOT = formatMessageContent(msg.chain_of_thought);
      markdown += `${formattedCOT}\n\n`;
      markdown += `</details>\n\n`;
    }

    // Add separator between messages
    if (index < data.messages.length - 1) {
      markdown += `---\n\n`;
    }
  });

  return markdown;
}

/**
 * Format message content for Markdown, with special handling for code blocks
 * @param {string} content - The message content to format
 * @returns {string} - The formatted content
 */
function formatMessageContent(content) {
  if (!content) return '';

  // Replace HTML tags with their Markdown equivalents
  let formatted = content
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<p>(.*?)<\/p>/gi, '$1\n\n')
    .replace(/<strong>(.*?)<\/strong>/gi, '**$1**')
    .replace(/<em>(.*?)<\/em>/gi, '*$1*')
    .replace(/<h1>(.*?)<\/h1>/gi, '# $1\n')
    .replace(/<h2>(.*?)<\/h2>/gi, '## $1\n')
    .replace(/<h3>(.*?)<\/h3>/gi, '### $1\n')
    .replace(/<h4>(.*?)<\/h4>/gi, '#### $1\n')
    .replace(/<h5>(.*?)<\/h5>/gi, '##### $1\n')
    .replace(/<h6>(.*?)<\/h6>/gi, '###### $1\n')
    .replace(/<ul>(.*?)<\/ul>/gis, (match, p1) => {
      return p1.replace(/<li>(.*?)<\/li>/gi, '- $1\n');
    })
    .replace(/<ol>(.*?)<\/ol>/gis, (match, p1) => {
      let index = 1;
      return p1.replace(/<li>(.*?)<\/li>/gi, () => {
        return `${index++}. $1\n`;
      });
    });

  // Handle code blocks
  // First, handle fenced code blocks with language specification
  formatted = formatted.replace(/<pre><code class="language-([a-zA-Z0-9]+)">([\s\S]*?)<\/code><\/pre>/gi, (match, language, code) => {
    return `\`\`\`${language}\n${code.trim()}\n\`\`\`\n`;
  });

  // Handle DeepSeek specific code blocks with language
  formatted = formatted.replace(/<div class="ds-code-block".*?data-language="([a-zA-Z0-9]+)".*?>([\s\S]*?)<\/div>/gi, (match, language, code) => {
    // Extract the actual code content, removing any nested elements like copy buttons
    const codeContent = code.replace(/<button.*?<\/button>/gi, '')
                            .replace(/<div class="ds-code-header".*?<\/div>/gi, '')
                            .replace(/<div class="ds-code-content".*?>([\s\S]*?)<\/div>/gi, '$1')
                            .trim();
    return `\`\`\`${language}\n${codeContent}\n\`\`\`\n`;
  });

  // Handle DeepSeek specific code blocks without language
  formatted = formatted.replace(/<div class="ds-code-block".*?>([\s\S]*?)<\/div>/gi, (match, code) => {
    // Extract the actual code content, removing any nested elements
    const codeContent = code.replace(/<button.*?<\/button>/gi, '')
                            .replace(/<div class="ds-code-header".*?<\/div>/gi, '')
                            .replace(/<div class="ds-code-content".*?>([\s\S]*?)<\/div>/gi, '$1')
                            .trim();
    return `\`\`\`\n${codeContent}\n\`\`\`\n`;
  });

  // Then, handle regular code blocks
  formatted = formatted.replace(/<pre><code>([\s\S]*?)<\/code><\/pre>/gi, (match, code) => {
    return `\`\`\`\n${code.trim()}\n\`\`\`\n`;
  });

  // Handle code blocks that might be in a different format (DeepSeek specific)
  formatted = formatted.replace(/<div class="[^"]*code[^"]*".*?>([\s\S]*?)<\/div>/gi, (match, code) => {
    // Check if this is likely a code block by looking for common indicators
    if (match.includes('code-block') ||
        match.includes('language-') ||
        match.includes('syntax-') ||
        match.includes('ds-code')) {
      // Extract the language if available
      const langMatch = match.match(/language-([a-zA-Z0-9]+)/i) || match.match(/data-language="([a-zA-Z0-9]+)"/i);
      const language = langMatch ? langMatch[1] : '';

      // Clean up the code content
      const cleanCode = code.replace(/<[^>]*>/g, '').trim();

      return language ?
        `\`\`\`${language}\n${cleanCode}\n\`\`\`\n` :
        `\`\`\`\n${cleanCode}\n\`\`\`\n`;
    }
    return match; // Not a code block, leave it unchanged
  });

  // Handle inline code
  formatted = formatted.replace(/<code>(.*?)<\/code>/gi, '`$1`');
  formatted = formatted.replace(/<span class="[^"]*code[^"]*">(.*?)<\/span>/gi, '`$1`');

  // Handle links
  formatted = formatted.replace(/<a href="(.*?)".*?>(.*?)<\/a>/gi, '[$2]($1)');

  // Handle images
  formatted = formatted.replace(/<img src="(.*?)".*?>/gi, '![]($1)');

  // Handle blockquotes
  formatted = formatted.replace(/<blockquote>([\s\S]*?)<\/blockquote>/gi, (match, quote) => {
    return quote.split('\n').map(line => `> ${line}`).join('\n');
  });

  // Handle tables (simplified)
  formatted = formatted.replace(/<table>([\s\S]*?)<\/table>/gi, (match, tableContent) => {
    let mdTable = '';

    // Extract header
    const headerMatch = tableContent.match(/<thead>([\s\S]*?)<\/thead>/i);
    if (headerMatch) {
      const headerCells = headerMatch[1].match(/<th>(.*?)<\/th>/gi);
      if (headerCells) {
        mdTable += '| ' + headerCells.map(cell => cell.replace(/<\/?th>/gi, '').trim()).join(' | ') + ' |\n';
        mdTable += '| ' + headerCells.map(() => '---').join(' | ') + ' |\n';
      }
    }

    // Extract body
    const bodyMatch = tableContent.match(/<tbody>([\s\S]*?)<\/tbody>/i);
    if (bodyMatch) {
      const rows = bodyMatch[1].match(/<tr>([\s\S]*?)<\/tr>/gi);
      if (rows) {
        rows.forEach(row => {
          const cells = row.match(/<td>(.*?)<\/td>/gi);
          if (cells) {
            mdTable += '| ' + cells.map(cell => cell.replace(/<\/?td>/gi, '').trim()).join(' | ') + ' |\n';
          }
        });
      }
    }

    return mdTable;
  });

  // Handle DeepSeek specific markdown blocks
  formatted = formatted.replace(/<div class="ds-markdown.*?">([\s\S]*?)<\/div>/gi, '$1');
  formatted = formatted.replace(/<div class="ds-markdown--block.*?">([\s\S]*?)<\/div>/gi, '$1');

  // Special handling for code blocks that might be in plain text with indentation
  // Look for patterns like multiple lines starting with spaces or tabs
  const lines = formatted.split('\n');
  let inCodeBlock = false;
  let codeBlockContent = [];
  let processedLines = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const nextLine = i < lines.length - 1 ? lines[i + 1] : '';

    // Check if this line looks like code (starts with spaces/tabs and has code-like content)
    const isCodeLike = /^(\s{4,}|\t+)/.test(line) &&
                      (/[=(){}\[\];]/.test(line) || // Has code symbols
                       /\b(function|const|let|var|if|else|for|while|return|import|export)\b/.test(line)); // Has code keywords

    // Check if we're entering a code block
    if (!inCodeBlock && isCodeLike && /^(\s{4,}|\t+)/.test(nextLine)) {
      inCodeBlock = true;
      codeBlockContent = [line];
      continue;
    }

    // Continue collecting code block content
    if (inCodeBlock) {
      if (isCodeLike || line.trim() === '') {
        codeBlockContent.push(line);
      } else {
        // End of code block
        processedLines.push('```');
        processedLines.push(...codeBlockContent);
        processedLines.push('```');
        processedLines.push(line);
        inCodeBlock = false;
        codeBlockContent = [];
      }
    } else {
      processedLines.push(line);
    }
  }

  // Handle any remaining code block
  if (inCodeBlock) {
    processedLines.push('```');
    processedLines.push(...codeBlockContent);
    processedLines.push('```');
  }

  // Rejoin the processed lines
  formatted = processedLines.join('\n');

  // Remove any remaining HTML tags
  formatted = formatted.replace(/<[^>]*>/g, '');

  // Decode HTML entities
  formatted = formatted
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'");

  return formatted;
}

/**
 * Convert chat data to plain text format
 * @param {Object} data - The chat data to convert
 * @returns {string} - The plain text content
 */
function convertToPlainText(data) {
  // Create the header with metadata
  let text = `${data.title}\n\n`;
  text += `URL: ${data.url}\n`;
  text += `Date: ${new Date(data.date).toLocaleString()}\n\n`;
  text += `----------------------------------------\n\n`;

  // Process each message
  data.messages.forEach((msg, index) => {
    // Format the role header
    const roleName = msg.role === 'user' ? 'User' : 'DeepSeek AI';
    text += `${roleName}:\n\n`;

    // Add the content, stripping HTML and preserving code blocks
    const plainContent = msg.content
      .replace(/<br\s*\/?>/gi, '\n')  // Replace <br> with newlines
      .replace(/<\/p>/gi, '\n\n')     // Replace </p> with double newlines
      .replace(/<[^>]*>/g, '')        // Remove all other HTML tags
      .replace(/&nbsp;/g, ' ')        // Replace &nbsp; with spaces
      .replace(/&lt;/g, '<')          // Replace &lt; with <
      .replace(/&gt;/g, '>')          // Replace &gt; with >
      .replace(/&amp;/g, '&')         // Replace &amp; with &
      .replace(/&quot;/g, '"')        // Replace &quot; with "
      .replace(/&apos;/g, "'")        // Replace &apos; with '
      .trim();                        // Trim whitespace

    text += `${plainContent}\n\n`;

    // Add chain of thought if available
    if (msg.chain_of_thought) {
      text += `Thinking process:\n\n`;
      const plainCOT = msg.chain_of_thought
        .replace(/<br\s*\/?>/gi, '\n')
        .replace(/<\/p>/gi, '\n\n')
        .replace(/<[^>]*>/g, '')
        .replace(/&nbsp;/g, ' ')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&')
        .replace(/&quot;/g, '"')
        .replace(/&apos;/g, "'")
        .trim();
      text += `${plainCOT}\n\n`;
    }

    // Add separator between messages
    if (index < data.messages.length - 1) {
      text += `----------------------------------------\n\n`;
    }
  });

  return text;
}

/**
 * 从页面中提取所有消息
 * @returns {Array} 消息数组
 */
function extractAllMessagesFromPage() {

  try {
    // 1. 查找用户问题 (使用 .fbb737a4 类)
    const userQuestions = document.querySelectorAll('.fbb737a4');

    // 2. 查找AI回答 (使用 .ds-markdown 和 .ds-markdown--block 类)
    const aiResponses = document.querySelectorAll('.ds-markdown, .ds-markdown--block');

    // 3. 查找思考过程容器 (使用 .e1675d8b 类)
    const cotContainers = document.querySelectorAll('.e1675d8b');

    // 如果没有找到任何消息，使用备用方法
    if (userQuestions.length === 0 && aiResponses.length === 0 && cotContainers.length === 0) {
      return findMessagesByPattern();
    }

    // 创建一个数组来存储所有消息元素及其类型和位置
    const allElements = [];

    // 添加用户问题
    userQuestions.forEach(el => {
      allElements.push({
        element: el,
        type: 'user',
        position: getElementPosition(el)
      });
    });

    // 添加AI回答
    aiResponses.forEach(el => {
      allElements.push({
        element: el,
        type: 'ai',
        position: getElementPosition(el)
      });
    });

    // 添加思考过程容器
    cotContainers.forEach(el => {
      allElements.push({
        element: el,
        type: 'cot_container',
        position: getElementPosition(el)
      });
    });

    // 按照元素在DOM中的位置排序
    allElements.sort((a, b) => {
      return a.position - b.position;
    });


    // 处理排序后的元素
    const messages = [];
    let lastAiMessageIndex = -1;
    let pendingCOT = null; // 存储等待关联的COT内容
    let currentUserQuestion = null;

    allElements.forEach((item, index) => {
      const { element, type } = item;
      const content = extractMessageContent(element);

      if (!content) return;

      if (type === 'user') {
        // 处理用户问题
        currentUserQuestion = {
          role: 'user',
          content: cleanMessageContent(content, 'user'),
          element_id: element.id || `user-${index}-${Date.now()}`
        };

        messages.push(currentUserQuestion);
        lastAiMessageIndex = -1; // 重置最后一个AI消息的索引
      }
      else if (type === 'ai') {
        // 处理AI回答
        const aiMessage = {
          role: 'assistant',
          content: cleanMessageContent(content, 'assistant'),
          element_id: element.id || `ai-${index}-${Date.now()}`
        };

        // 如果有待处理的COT，将其添加到这个AI消息中
        if (pendingCOT) {
          aiMessage.chain_of_thought = pendingCOT;
          pendingCOT = null; // 清除待处理的COT
        }

        messages.push(aiMessage);
        lastAiMessageIndex = messages.length - 1;
      }
      else if (type === 'cot_container') {
        // 处理思考过程容器
        const cotContent = extractCOTFromContainer(element);

        if (cotContent) {
          // 如果有最近的AI消息，将思考过程添加到该消息
          if (lastAiMessageIndex >= 0) {
            messages[lastAiMessageIndex].chain_of_thought = cotContent;
          }
          // 如果没有最近的AI消息，存储COT以便与下一个AI消息关联
          else {
            pendingCOT = cotContent;
          }
        }
      }
    });

    // 处理最后可能剩余的待处理COT
    if (pendingCOT && messages.length > 0) {
      // 尝试找到最后一条消息
      const lastMessage = messages[messages.length - 1];

      // 如果最后一条消息是AI消息，将COT添加到该消息
      if (lastMessage.role === 'assistant') {
        lastMessage.chain_of_thought = pendingCOT;
      }
      // 如果最后一条消息是用户消息，创建一个新的AI消息
      else if (lastMessage.role === 'user') {
        const aiMessage = {
          role: 'assistant',
          content: "See chain of thought reasoning below:",
          element_id: `ai-final-${Date.now()}`,
          chain_of_thought: pendingCOT
        };

        messages.push(aiMessage);
      }
    }

    return messages;
  } catch (error) {
    console.error('Error extracting messages from page:', error);
    return findMessagesByPattern();
  }
}

/**
 * 从思考过程容器中提取内容
 * @param {Element} container - 思考过程容器元素
 * @returns {string} 清理后的思考过程内容
 */
function extractCOTFromContainer(container) {
  try {
    if (!container) return '';

    // 首先尝试查找所有 .ba94db8a 元素
    const cotElements = container.querySelectorAll('.ba94db8a');

    if (cotElements && cotElements.length > 0) {
      // 如果找到了 .ba94db8a 元素，提取它们的内容
      const cotTexts = [];
      cotElements.forEach(el => {
        const text = el.textContent.trim();
        if (text) {
          cotTexts.push(text);
        }
      });

      // 将所有内容合并为一个字符串
      const combinedText = cotTexts.join('\n\n');
      return cleanMessageContent(combinedText, 'assistant');
    }

    // 如果没有找到 .ba94db8a 元素，尝试查找所有段落元素
    const paragraphs = container.querySelectorAll('p');
    if (paragraphs && paragraphs.length > 0) {
      const paragraphTexts = [];
      paragraphs.forEach(p => {
        const text = p.textContent.trim();
        if (text) {
          paragraphTexts.push(text);
        }
      });

      if (paragraphTexts.length > 0) {
        const combinedText = paragraphTexts.join('\n\n');
        return cleanMessageContent(combinedText, 'assistant');
      }
    }

    // 如果没有找到段落元素，尝试直接提取容器的内容
    const directContent = container.textContent.trim();
    if (directContent) {
      return cleanMessageContent(directContent, 'assistant');
    }

    return '';
  } catch (error) {
    console.error('Error extracting COT content:', error);
    return '';
  }
}

/**
 * 获取元素在DOM中的位置
 * @param {Element} element - 要获取位置的元素
 * @returns {number} 元素的位置值
 */
function getElementPosition(element) {
  // 使用TreeWalker遍历DOM树，找到元素的位置
  const treeWalker = document.createTreeWalker(
    document.body,
    NodeFilter.SHOW_ELEMENT,
    null,
    false
  );

  let position = 0;
  let found = false;

  while (treeWalker.nextNode()) {
    position++;
    if (treeWalker.currentNode === element) {
      found = true;
      break;
    }
  }

  return found ? position : Number.MAX_SAFE_INTEGER;
}

/**
 * 基于内容模式查找消息
 * @returns {Array} 消息元素数组
 */
function findMessagesByPattern() {
  const extractedMessages = [];

  try {
    // 1. 查找所有可能的用户消息容器
    const userContainers = document.querySelectorAll('.fbb737a4, .e214291b, [data-role="user"]');

    // 2. 查找所有可能的AI消息容器
    const aiContainers = document.querySelectorAll('.ds-markdown, .ds-markdown--block, .c92459f0, [data-role="assistant"]');

    // 3. 查找所有可能的思考过程容器
    const cotContainers = document.querySelectorAll('.e1675d8b');
    const cotElements = document.querySelectorAll('.ba94db8a');

    // 创建一个数组来存储所有消息元素及其类型和位置
    const allElements = [];

    // 添加用户消息
    userContainers.forEach(el => {
      allElements.push({
        element: el,
        type: 'user',
        position: getElementPosition(el)
      });
    });

    // 添加AI消息
    aiContainers.forEach(el => {
      allElements.push({
        element: el,
        type: 'ai',
        position: getElementPosition(el)
      });
    });

    // 添加思考过程容器
    cotContainers.forEach(el => {
      allElements.push({
        element: el,
        type: 'cot_container',
        position: getElementPosition(el)
      });
    });

    // 按照元素在DOM中的位置排序
    allElements.sort((a, b) => {
      return a.position - b.position;
    });


    // 处理排序后的元素
    let lastAiMessageIndex = -1;
    let pendingCOT = null; // 存储等待关联的COT内容
    let currentUserQuestion = null;

    allElements.forEach((item, index) => {
      const { element, type } = item;
      const content = extractMessageContent(element);

      if (!content) return;

      if (type === 'user') {
        // 处理用户消息
        currentUserQuestion = {
          role: 'user',
          content: cleanMessageContent(content, 'user'),
          element_id: element.id || `user-${index}-${Date.now()}`
        };

        extractedMessages.push(currentUserQuestion);
        lastAiMessageIndex = -1; // 重置最后一个AI消息的索引
      }
      else if (type === 'ai') {
        // 处理AI消息
        const aiMessage = {
          role: 'assistant',
          content: cleanMessageContent(content, 'assistant'),
          element_id: element.id || `ai-${index}-${Date.now()}`
        };

        // 如果有待处理的COT，将其添加到这个AI消息中
        if (pendingCOT) {
          aiMessage.chain_of_thought = pendingCOT;
          pendingCOT = null; // 清除待处理的COT
        }

        extractedMessages.push(aiMessage);
        lastAiMessageIndex = extractedMessages.length - 1;
      }
      else if (type === 'cot_container') {
        // 处理思考过程容器
        const cotContent = extractCOTFromContainer(element);

        if (cotContent) {
          // 如果有最近的AI消息，将思考过程添加到该消息
          if (lastAiMessageIndex >= 0) {
            extractedMessages[lastAiMessageIndex].chain_of_thought = cotContent;
          }
          // 如果没有最近的AI消息，存储COT以便与下一个AI消息关联
          else {
            pendingCOT = cotContent;
          }
        }
      }
    });

    // 处理最后可能剩余的待处理COT
    if (pendingCOT && extractedMessages.length > 0) {
      // 尝试找到最后一条消息
      const lastMessage = extractedMessages[extractedMessages.length - 1];

      // 如果最后一条消息是AI消息，将COT添加到该消息
      if (lastMessage.role === 'assistant') {
        lastMessage.chain_of_thought = pendingCOT;
      }
      // 如果最后一条消息是用户消息，创建一个新的AI消息
      else if (lastMessage.role === 'user') {
        const aiMessage = {
          role: 'assistant',
          content: "See chain of thought reasoning below:",
          element_id: `ai-final-${Date.now()}`,
          chain_of_thought: pendingCOT
        };

        extractedMessages.push(aiMessage);
      }
    }

    // 如果仍然没有找到消息，尝试更广泛的搜索
    if (extractedMessages.length === 0) {

      // 查找所有可能包含文本的元素
      const allTextElements = document.querySelectorAll('div, p, section, article');
      const potentialMessages = Array.from(allTextElements).filter(el => {
        const text = el.textContent.trim();
        // 过滤掉太短的文本和明显的UI元素
        return text.length > 20 &&
               !text.includes('New chat') &&
               !text.includes('Sign in') &&
               !text.includes('Sign up') &&
               el.offsetParent !== null; // 确保元素可见
      });


      // 尝试确定每个元素的角色并提取内容
      potentialMessages.forEach((element, index) => {
        const role = determineRoleBySemantics(element);
        const content = extractMessageContent(element);

        if (content && role !== 'unknown') {
          extractedMessages.push({
            role,
            content: cleanMessageContent(content, role),
            element_id: element.id || `potential-message-${index}-${Date.now()}`
          });
        }
      });
    }

  } catch (error) {
    console.error('Error in pattern-based message extraction:', error);
  }

  return extractedMessages;
}

/**
 * 查找消息中的内容节点
 * @param {Element} messageNode - 消息节点
 * @returns {Element|null} 内容节点或null
 */
function findContentNode(messageNode) {
  // 检查是否是DeepSeek特定的消息结构
  if (messageNode.classList.contains('e214291b')) {
    // 用户消息 - 查找textarea
    const textarea = messageNode.querySelector('textarea');
    if (textarea) {
      return textarea;
    }
  }

  // 检查用户问题类
  if (messageNode.classList.contains('fbb737a4')) {
    return messageNode;
  }

  // 检查AI回复类
  if (messageNode.classList.contains('c92459f0') ||
      messageNode.classList.contains('ds-markdown') ||
      messageNode.classList.contains('ds-markdown--block')) {
    return messageNode;
  }

  // 检查AI思考过程类
  if (messageNode.classList.contains('ba94db8a')) {
    return messageNode;
  }

  // 检查是否有ID为chat-input的元素（用户输入框）
  const chatInput = messageNode.querySelector('#chat-input');
  if (chatInput) {
    return chatInput;
  }

  // 检查是否包含特定类的子元素
  const userContentNode = messageNode.querySelector('.fbb737a4');
  if (userContentNode) {
    return userContentNode;
  }

  const aiContentNode = messageNode.querySelector('.ds-markdown, .ds-markdown--block');
  if (aiContentNode) {
    return aiContentNode;
  }

  const cotContentNode = messageNode.querySelector('.ba94db8a');
  if (cotContentNode) {
    return cotContentNode;
  }

  // 1. 查找具有内容相关类名的元素
  for (const pattern of SELECTORS.CONTENT_PATTERNS) {
    const contentNodes = messageNode.querySelectorAll(`[class*="${pattern}"]`);
    if (contentNodes.length > 0) {
      // 返回最可能的内容节点（通常是最大的文本节点）
      return Array.from(contentNodes).sort((a, b) =>
        b.textContent.length - a.textContent.length
      )[0];
    }
  }

  // 2. 查找具有段落或文本特征的元素
  const textElements = messageNode.querySelectorAll('p, div > div:only-child');
  if (textElements.length > 0) {
    return Array.from(textElements).sort((a, b) =>
      b.textContent.length - a.textContent.length
    )[0];
  }

  // 3. 如果消息节点只有一个子元素，可能是内容节点
  if (messageNode.children.length === 1) {
    return messageNode.children[0];
  }

  return null;
}

/**
 * 移除AI生成的页脚文本
 * @param {Element} messageNode - 消息节点
 * @param {string} content - 原始内容
 * @returns {string} 清理后的内容
 */
function removeAIFooters(messageNode, content) {
  // 查找可能的AI页脚元素
  const footerElements = Array.from(messageNode.querySelectorAll('div, p, span, .fcaa63f8'))
    .filter(el => {
      const text = el.textContent.toLowerCase();
      return SELECTORS.AI_FOOTER_PATTERNS.some(pattern =>
        text.includes(pattern.toLowerCase())
      );
    });

  // 从内容中移除页脚文本
  let cleanedContent = content;

  // 特别处理DeepSeek的AI生成页脚
  const deepseekFooter = messageNode.querySelector('.fcaa63f8');
  if (deepseekFooter) {
    cleanedContent = cleanedContent.replace(deepseekFooter.textContent, '');
  }

  footerElements.forEach(footer => {
    cleanedContent = cleanedContent.replace(footer.textContent, '');
  });

  // 移除常见的AI生成页脚文本
  cleanedContent = cleanedContent.replace(/AI-generated, for reference only/gi, '');
  cleanedContent = cleanedContent.replace(/AI-generated/gi, '');
  cleanedContent = cleanedContent.replace(/Generated by AI/gi, '');
  cleanedContent = cleanedContent.replace(/内容由\s*AI\s*生成/gi, '');

  return cleanedContent;
}

/**
 * 基于语义确定消息的角色
 * @param {Element} messageNode - The message node
 * @returns {string} The role of the message ('user', 'assistant', or 'unknown')
 */
function determineRoleBySemantics(messageNode) {
  // 检查data-role属性
  if (messageNode.dataset.role === 'user') {
    return 'user';
  } else if (messageNode.dataset.role === 'assistant') {
    return 'assistant';
  }

  // 检查特定的类名
  if (messageNode.classList.contains('e214291b') ||
      messageNode.classList.contains('fbb737a4') ||
      messageNode.closest('.e214291b, .fbb737a4') !== null) {
    return 'user';
  }

  if (messageNode.classList.contains('c92459f0') ||
      messageNode.classList.contains('ds-markdown') ||
      messageNode.classList.contains('ds-markdown--block') ||
      messageNode.closest('.c92459f0, .ds-markdown, .ds-markdown--block') !== null) {
    return 'assistant';
  }

  // 检查是否包含思考过程元素
  if (messageNode.classList.contains('ba94db8a') ||
      messageNode.closest('.ba94db8a') !== null ||
      messageNode.querySelector('.ba94db8a') !== null) {
    return 'assistant';
  }

  // 1. 检查类名和属性中的角色指示
  const classAndAttrs = messageNode.className + ' ' +
                        (messageNode.getAttribute('role') || '') + ' ' +
                        (messageNode.getAttribute('aria-label') || '');

  const classString = classAndAttrs.toLowerCase();

  // 检查用户角色指示
  const hasUserIndicator = SELECTORS.USER_MESSAGE_PATTERNS.some(pattern =>
    classString.includes(pattern)
  );

  // 检查AI角色指示
  const hasAIIndicator = SELECTORS.AI_MESSAGE_PATTERNS.some(pattern =>
    classString.includes(pattern)
  );

  // 检查AI思考过程指示
  const hasCOTIndicator = SELECTORS.AI_COT_PATTERNS.some(pattern =>
    classString.includes(pattern)
  );

  if (hasUserIndicator && !hasAIIndicator && !hasCOTIndicator) return 'user';
  if ((hasAIIndicator || hasCOTIndicator) && !hasUserIndicator) return 'assistant';

  // 2. 检查内容中的AI生成指示
  const content = messageNode.textContent.toLowerCase();
  const hasAIFooter = SELECTORS.AI_FOOTER_PATTERNS.some(pattern =>
    content.includes(pattern.toLowerCase())
  );

  if (hasAIFooter) return 'assistant';

  // 3. 检查子元素中的AI指示
  const hasAIFooterElement = Array.from(messageNode.querySelectorAll('*')).some(el =>
    SELECTORS.AI_FOOTER_PATTERNS.some(pattern =>
      el.textContent.toLowerCase().includes(pattern.toLowerCase())
    )
  );

  if (hasAIFooterElement) return 'assistant';

  // 检查子元素中的特定类
  const hasUserClass = messageNode.querySelector('.fbb737a4') !== null;
  const hasAIClass = messageNode.querySelector('.ds-markdown, .ds-markdown--block') !== null;
  const hasCOTClass = messageNode.querySelector('.ba94db8a') !== null;

  if (hasUserClass && !hasAIClass && !hasCOTClass) return 'user';
  if ((hasAIClass || hasCOTClass) && !hasUserClass) return 'assistant';

  // 4. 使用交替模式
  const prevRole = document.querySelector('[data-role]')?.dataset.role;

  if (prevRole === 'user') {
    return 'assistant';
  } else if (prevRole === 'assistant' || prevRole === null) {
    return 'user';
  }

  // 默认为用户消息
  return 'user';
}

/**
 * 分析页面结构以识别聊天模式
 */
function analyzePageStructure() {

  // 检查是否有带有data-role="user"的元素
  const userRoleElements = document.querySelectorAll('[data-role="user"]');
  if (userRoleElements.length > 0) {
    return;
  }

  // 1. 识别可能的消息容器
  const possibleContainers = findPossibleMessageContainers();

  // 2. 识别对话模式
  identifyConversationPattern(possibleContainers);
}

/**
 * 查找可能包含消息的容器
 * @returns {Array} 可能的消息容器元素数组
 */
function findPossibleMessageContainers() {
  // 寻找具有重复结构的容器
  const allDivs = Array.from(document.querySelectorAll('div'));
  const containers = [];

  // 查找包含多个子元素且结构相似的容器
  allDivs.forEach(div => {
    const children = Array.from(div.children);

    // 至少有2个子元素的容器
    if (children.length >= 2) {
      // 检查子元素是否有相似的结构
      const similarStructure = children.filter(child =>
        child.tagName === children[0].tagName &&
        child.className === children[0].className
      ).length >= 2;

      if (similarStructure) {
        containers.push(div);
      }
    }
  });

  return containers;
}

/**
 * 识别对话模式
 * @param {Array} containers 可能的消息容器
 */
function identifyConversationPattern(containers) {
  // 对于每个容器，尝试识别用户/AI消息的模式
  containers.forEach(container => {
    const children = Array.from(container.children);

    // 检查是否有交替的用户/AI消息模式
    let userMessages = 0;
    let aiMessages = 0;

    children.forEach(child => {
      const text = child.textContent.toLowerCase();
      const classList = child.className.toLowerCase();

      // 检查是否是用户消息
      const isUserMessage = SELECTORS.USER_MESSAGE_PATTERNS.some(pattern =>
        classList.includes(pattern) || text.includes(pattern)
      );

      // 检查是否是AI消息
      const isAIMessage = SELECTORS.AI_MESSAGE_PATTERNS.some(pattern =>
        classList.includes(pattern) || text.includes(pattern)
      ) || SELECTORS.AI_FOOTER_PATTERNS.some(pattern => text.includes(pattern));

      if (isUserMessage) userMessages++;
      if (isAIMessage) aiMessages++;
    });

    // 如果同时有用户和AI消息，这可能是一个对话容器
    if (userMessages > 0 && aiMessages > 0) {
      // 更新选择器以使用这个容器
      SELECTORS.IDENTIFIED_CONTAINER = container;
    }
  });
}

/**
 * Process a message element and extract its content
 * @param {Element} messageElement - The message element to process
 * @returns {Object|null} - The processed message or null if processing failed
 */
function processMessage(messageElement) {
  if (!messageElement) return null;

  try {
    // 确定消息角色
    const role = determineRoleBySemantics(messageElement);

    // 查找内容节点
    const contentNode = findContentNode(messageElement);
    if (!contentNode) {
      console.warn('Could not find content node for message:', messageElement);
      return null;
    }

    // 提取消息内容
    let content = extractMessageContent(contentNode);
    if (!content) {
      console.warn('Could not extract content for message:', messageElement);
      return null;
    }

    // 清理消息内容
    content = cleanMessageContent(content, role);

    // 生成消息的唯一标识
    const elementId = messageElement.id || generateUniqueId();

    // 创建消息对象
    const message = {
      role,
      content,
      element_id: elementId
    };

    // 如果是AI消息，尝试提取思考过程
    if (role === 'assistant') {
      // 查找相关的思考过程元素
      const cotElements = Array.from(messageElement.querySelectorAll('.ba94db8a'));

      // 如果在当前元素中没有找到，尝试在相邻元素中查找
      if (cotElements.length === 0) {
        // 查找消息容器
        const messageContainer = messageElement.closest('.message-container') || messageElement.parentElement;
        if (messageContainer) {
          // 查找同一容器中的思考过程元素
          const containerCotElements = Array.from(messageContainer.querySelectorAll('.ba94db8a'));
          cotElements.push(...containerCotElements);
        }

        // 查找紧随其后的思考过程元素
        let nextElement = messageElement.nextElementSibling;
        while (nextElement && cotElements.length === 0) {
          if (nextElement.classList.contains('ba94db8a') || nextElement.querySelector('.ba94db8a')) {
            cotElements.push(nextElement.classList.contains('ba94db8a') ?
              nextElement : nextElement.querySelector('.ba94db8a'));
          }
          nextElement = nextElement.nextElementSibling;
        }
      }

      // 处理找到的思考过程元素
      if (cotElements.length > 0) {

        // 合并所有思考过程内容
        const cotContents = cotElements.map(cotElement => {
          const cotContent = extractMessageContent(cotElement);
          return cotContent ? cleanMessageContent(cotContent, 'assistant') : '';
        }).filter(Boolean);

        if (cotContents.length > 0) {
          message.chain_of_thought = cotContents.join('\n\n');
        }
      }
    }

    return message;
  } catch (error) {
    console.error('Error processing message:', error);
    return null;
  }
}

/**
 * Extract the text content from a message node
 * @param {Element} node - The node to extract content from
 * @returns {string} - The extracted content
 */
function extractMessageContent(node) {
  if (!node) return '';

  try {
    // 如果是输入元素，获取其值
    if (node.tagName === 'INPUT' || node.tagName === 'TEXTAREA') {
      return node.value.trim();
    }

    // 创建节点的克隆，以便我们可以修改它而不影响原始DOM
    const clone = node.cloneNode(true);

    // 移除所有代码块的复制按钮
    clone.querySelectorAll('button').forEach(button => {
      if (button.textContent.includes('Copy') ||
          button.textContent.includes('复制') ||
          button.classList.contains('copy-button')) {
        button.remove();
      }
    });

    // 移除所有不可见元素
    clone.querySelectorAll('*').forEach(el => {
      const style = window.getComputedStyle(el);
      if (style.display === 'none' || style.visibility === 'hidden') {
        el.remove();
      }
    });

    // 获取文本内容
    let content = clone.textContent.trim();

    // 如果内容为空，尝试获取innerHTML
    if (!content && node.innerHTML) {
      // 创建临时元素来解析HTML
      const temp = document.createElement('div');
      temp.innerHTML = node.innerHTML;

      // 移除所有脚本和样式标签
      temp.querySelectorAll('script, style').forEach(el => el.remove());

      content = temp.textContent.trim();
    }

    return content;
  } catch (error) {
    console.error('Error extracting message content:', error);
    return '';
  }
}

/**
 * Generate a unique ID for a message
 * @returns {string} - A unique ID
 */
function generateUniqueId() {
  return 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
}

/**
 * Detect if a DOM element is a code block in DeepSeek's format
 * @param {Element} element - The element to check
 * @returns {Object|null} - Code block info or null if not a code block
 */
function detectDeepSeekCodeBlock(element) {
  if (!element) return null;

  try {
    // Check for DeepSeek specific code block classes
    if (element.classList.contains('ds-code-block') ||
        element.classList.contains('code-block') ||
        element.querySelector('.ds-code-block, .code-block')) {

      // Find the target element (either this element or a child)
      const targetElement = element.classList.contains('ds-code-block') || element.classList.contains('code-block')
        ? element
        : element.querySelector('.ds-code-block, .code-block');

      if (!targetElement) return null;

      // Try to find the language
      let language = '';

      // Check data-language attribute
      if (targetElement.hasAttribute('data-language')) {
        language = targetElement.getAttribute('data-language');
      }

      // Check for language in class names
      if (!language) {
        const classMatch = Array.from(targetElement.classList).find(cls => cls.startsWith('language-'));
        if (classMatch) {
          language = classMatch.replace('language-', '');
        }
      }

      // Find the code content
      let codeContent = '';

      // First try to find a specific code content container
      const codeContentElement = targetElement.querySelector('.ds-code-content, .code-content');
      if (codeContentElement) {
        codeContent = codeContentElement.textContent;
      } else {
        // Otherwise use the element's text content, excluding any buttons or headers
        const clone = targetElement.cloneNode(true);

        // Remove copy buttons and headers
        clone.querySelectorAll('button, .ds-code-header, .code-header').forEach(el => el.remove());

        codeContent = clone.textContent;
      }

      return {
        language,
        content: codeContent.trim()
      };
    }

    // Check for pre/code elements
    const preElement = element.tagName === 'PRE' ? element : element.querySelector('pre');
    if (preElement) {
      const codeElement = preElement.querySelector('code');
      if (codeElement) {
        // Check for language class
        let language = '';
        const classMatch = Array.from(codeElement.classList).find(cls => cls.startsWith('language-'));
        if (classMatch) {
          language = classMatch.replace('language-', '');
        }

        return {
          language,
          content: codeElement.textContent.trim()
        };
      }
    }

    return null;
  } catch (error) {
    console.error('Error detecting code block:', error);
    return null;
  }
}

/**
 * Extract code blocks from a message element
 * @param {Element} messageElement - The message element to process
 * @returns {Array} - Array of code block objects with language and content
 */
function extractCodeBlocks(messageElement) {
  if (!messageElement) return [];

  const codeBlocks = [];

  try {
    // Find all potential code block elements
    const potentialCodeBlocks = [
      ...messageElement.querySelectorAll('.ds-code-block, .code-block, pre, [class*="code"]'),
      ...Array.from(messageElement.querySelectorAll('div')).filter(div => {
        const text = div.textContent;
        // Look for indented blocks with code-like content
        return text.split('\n').filter(line =>
          /^\s{4,}/.test(line) && /[=(){}\[\];]/.test(line)
        ).length > 2;
      })
    ];

    // Process each potential code block
    potentialCodeBlocks.forEach(element => {
      const codeBlock = detectDeepSeekCodeBlock(element);
      if (codeBlock) {
        codeBlocks.push(codeBlock);

        // Mark this element as processed to avoid duplicate processing
        element.dataset.processed = 'true';
      }
    });

    return codeBlocks;
  } catch (error) {
    console.error('Error extracting code blocks:', error);
    return [];
  }
}

/**
 * Convert chat data to HTML format
 * @param {Object} data - The chat data to convert
 * @returns {string} - The HTML content
 */
function convertToHTML(data) {
  // 创建基本的HTML结构
  let html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${data.title}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f9f9f9;
    }
    .chat-header {
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 1px solid #eaeaea;
    }
    .chat-title {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    .chat-metadata {
      font-size: 14px;
      color: #666;
      margin-bottom: 5px;
    }
    .message-container {
      margin-bottom: 25px;
      padding-bottom: 25px;
      border-bottom: 1px solid #eaeaea;
    }
    .message-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .user-message .message-header {
      color: #2962FF;
    }
    .ai-message .message-header {
      color: #00796B;
    }
    .message-role {
      font-weight: bold;
      font-size: 16px;
      margin-left: 8px;
    }
    .message-content {
      background-color: #fff;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .user-message .message-content {
      background-color: #E3F2FD;
    }
    .ai-message .message-content {
      background-color: #E0F2F1;
    }
    .chain-of-thought {
      margin-top: 15px;
      padding: 12px;
      background-color: #FFF8E1;
      border-radius: 6px;
      border-left: 3px solid #FFB300;
    }
    .chain-of-thought-header {
      font-weight: bold;
      margin-bottom: 8px;
      color: #F57C00;
    }
    pre {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
    }
    code {
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="chat-header">
    <div class="chat-title">${data.title}</div>
    <div class="chat-metadata">URL: ${data.url}</div>
    <div class="chat-metadata">Date: ${new Date(data.date).toLocaleString()}</div>
  </div>
`;

  // 处理每条消息
  data.messages.forEach(msg => {
    const roleClass = msg.role === 'user' ? 'user-message' : 'ai-message';
    const roleIcon = msg.role === 'user' ? '🧑' : '🤖';
    const roleName = msg.role === 'user' ? 'User' : 'DeepSeek AI';

    html += `  <div class="message-container ${roleClass}">
    <div class="message-header">
      <span>${roleIcon}</span>
      <span class="message-role">${roleName}</span>
    </div>
    <div class="message-content">
      ${msg.content}
    </div>`;

    // 添加思考过程（如果有）
    if (msg.chain_of_thought) {
      html += `    <div class="chain-of-thought">
      <div class="chain-of-thought-header">Thinking Process:</div>
      ${msg.chain_of_thought}
    </div>`;
    }

    html += `  </div>\n`;
  });

  // 关闭HTML结构
  html += `</body>
</html>`;

  return html;
}

// Start the extension
init();
