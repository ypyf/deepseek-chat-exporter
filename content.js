/**
 * DeepSeek Chat Exporter - Content Script
 *
 * This script monitors the DeepSeek chat interface, extracts messages,
 * and provides functionality to export conversations as JSON.
 */

// DOM Selectors
const SELECTORS = {
  // 基于语义和结构模式的选择器
  CHAT_CONTAINER: 'main, [role="main"], .chat-container, .conversation, body',
  MESSAGE_CONTAINER: '[role="log"], .messages, .conversation-container, .ds-conversation',
  USER_MESSAGE_PATTERNS: ['user', 'human', 'you', 'question', 'query', 'input', 'e214291b', 'fbb737a4'],
  AI_MESSAGE_PATTERNS: ['ai', 'assistant', 'bot', 'chatbot', 'answer', 'response', 'generated', 'c92459f0', 'ds-markdown', 'ds-markdown--block', 'md-code-block'],
  AI_COT_PATTERNS: ['ba94db8a'], // Chain of thought reasoning
  CONTENT_PATTERNS: ['content', 'text', 'message', 'chat-content', 'c92459f0', 'e214291b', 'fbb737a4', 'ds-markdown', 'ds-markdown--block', 'md-code-block', 'ba94db8a'],
  AI_FOOTER_PATTERNS: ['AI-generated', 'Generated by AI', 'AI 生成', 'AI-generated, for reference only'],
  // 直接选择器
  USER_ELEMENTS: '[data-role="user"], .e214291b, .fbb737a4',
  // 代码块选择器
  CODE_BLOCK_PATTERNS: ['.md-code-block', '.ds-code-block', '.code-block', 'pre', '.ds-markdown--block .md-code-block']
};

// Fallback selectors to try if primary selectors fail
const FALLBACK_SELECTORS = [
  // Chat container fallbacks
  'div.ds-conversation',
  '.ds-chat-container',
  'div[class*="conversation"]',
  'div[class*="chat"]',
  '.cbcaa82c',

  // Message item fallbacks
  'div[class*="message"]',
  'div[class*="chat-item"]',
  '.e214291b', // User message container
  '.c92459f0', // AI message container

  // Content text fallbacks
  'div[class*="content"]',
  'div[class*="text"]',
  '.e214291b textarea', // User input
  '.c92459f0', // AI response
  '.md-code-block' // DeepSeek markdown code block
];

// Cache of processed messages to prevent duplicates
let processedMessages = new WeakMap();

// Current session data
let currentSessionId = generateSessionId();
let lastStorageUpdate = 0;
const STORAGE_THROTTLE = 1000; // Limit storage updates to once per second

/**
 * Check if the current page is a DeepSeek chat page
 * @returns {boolean} True if the page is a DeepSeek chat page
 */
function isDeepSeekChatPage() {
  // 检查URL
  const url = window.location.href;

  // 首先检查是否有DeepSeek特定的元素
  if (document.querySelector('.e214291b, .c92459f0, .cbcaa82c, .ds-conversation, #chat-input') !== null) {
    return true;
  }

  // 检查是否有data-role="user"元素
    if (document.querySelectorAll('[data-role="user"]').length > 0) {
      return true;
    }

    // 如果URL包含deepseek，进行更详细的检查
    if (url.includes('deepseek.com') || url.includes('deepseek.ai')) {
      // 检查页面是否包含聊天界面的特征
      const hasChatElements =
        // 检查是否有对话容器
        document.querySelector('[role="log"]') !== null ||
        // 检查是否有AI生成内容的指示
        Array.from(document.querySelectorAll('div')).some(div =>
          SELECTORS.AI_FOOTER_PATTERNS.some(pattern =>
            div.textContent.includes(pattern)
          )
        ) ||
        // 检查是否有输入框
        document.querySelector('textarea, [role="textbox"]') !== null;

      return hasChatElements;
    }

  return false;
}

/**
 * Debug the message structure on the page
 */
function debugMessageStructure() {

  try {
    // 1. 查找对话容器
    const conversationContainer = document.querySelector('.ds-conversation, .cbcaa82c');

    if (conversationContainer) {
      // 2. 记录容器的子元素

      // 3. 检查每个子元素的类名和结构
      Array.from(conversationContainer.children).forEach((child, index) => {

        // 4. 检查是否包含用户/AI消息特征
        const hasUserClass = child.querySelector('.fbb737a4, .e214291b') !== null ||
                            child.classList.contains('fbb737a4') ||
                            child.classList.contains('e214291b');

        const hasAIClass = child.querySelector('.ds-markdown, .ds-markdown--block, .c92459f0') !== null ||
                          child.classList.contains('ds-markdown') ||
                          child.classList.contains('ds-markdown--block') ||
                          child.classList.contains('c92459f0');

        const hasCOTClass = child.querySelector('.ba94db8a') !== null ||
                           child.classList.contains('ba94db8a');


        // 5. 尝试提取内容
        const content = extractMessageContent(child);
      });
    }

    // 6. 查找所有可能的用户消息元素
    const userElements = document.querySelectorAll('.fbb737a4, .e214291b, [data-role="user"]');
    userElements.forEach((el, i) => {
    });

    // 7. 查找所有可能的AI消息元素
    const aiElements = document.querySelectorAll('.ds-markdown, .ds-markdown--block, .c92459f0, [data-role="assistant"]');
    aiElements.forEach((el, i) => {
    });

    // 8. 查找所有可能的思考过程元素
    const cotElements = document.querySelectorAll('.ba94db8a');
    cotElements.forEach((el, i) => {
    });

    // 9. 记录页面上所有类名，帮助识别新的模式
    const allClasses = new Set();
    document.querySelectorAll('*').forEach(el => {
      if (el.className && typeof el.className === 'string') {
        el.className.split(' ').forEach(cls => {
          if (cls) allClasses.add(cls);
        });
      }
    });
  } catch (error) {
    console.error('Error debugging message structure:', error);
  }
}

/**
 * Initialize the extension
 */
function init() {
  try {
    // 检查是否是DeepSeek聊天页面
    if (!isDeepSeekChatPage()) {
      return;
    }

    // 立即注入导出按钮，不使用延迟
    try {
      injectExportButton();
    } catch (buttonError) {
      console.error('Error injecting export button:', buttonError);
      // Try again with a simpler approach
      try {
        const simpleButton = document.createElement('button');
        simpleButton.id = 'deepseek-export-btn-simple';
        simpleButton.textContent = 'Export Chat';
        simpleButton.style.cssText = 'position:fixed;top:20px;right:20px;z-index:9999999;background:#4285f4;color:white;border:none;border-radius:12px;padding:10px 16px;font-size:14px;cursor:pointer;';
        simpleButton.onclick = () => exportChat('json');
        document.body.appendChild(simpleButton);
      } catch (simpleButtonError) {
        console.error('Failed to inject simple button:', simpleButtonError);
      }
    }

    // 首先进行一次调试，了解页面结构
    debugMessageStructure();

    // 设置观察器来监视页面变化，特别是聊天消息的变化
    const observer = new MutationObserver(debounce(() => {
      // 当页面内容变化时，尝试提取新消息
      const messages = extractAllMessagesFromPage();
      if (messages.length > 0) {
      } else {
      }
    }, 500)); // 减少debounce延迟

    // 查找聊天容器
    const chatContainer = document.querySelector('.ds-conversation, .cbcaa82c');

    if (chatContainer) {
      observer.observe(chatContainer, {
        childList: true,
        subtree: true,
        characterData: true,
        attributes: true
      });
    } else {
      console.warn('Chat container not found, observing body');
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
    }

    // 初始提取消息 - 减少延迟时间
    setTimeout(() => {
      const messages = extractAllMessagesFromPage();

      if (messages.length > 0) {
      } else {
        console.warn('No messages found on initial load');
        // 如果没有找到消息，再次调试页面结构
        debugMessageStructure();
      }
    }, 500);
  } catch (error) {
    console.error('Error initializing extension:', error);
    try {
      injectExportButton();
    } catch (buttonError) {
      console.error('Failed to inject export button:', buttonError);
    }
  }
}

/**
 * Find the chat container with multiple fallback attempts
 * @returns {Promise<Element|null>} The chat container element or null if not found
 */
function findChatContainer() {
  return new Promise(resolve => {
    // First try the primary selector
    let container = document.querySelector(SELECTORS.CHAT_CONTAINER);

    if (container) {
      resolve(container);
      return;
    }

    // Try fallback selectors
    for (const selector of FALLBACK_SELECTORS) {
      container = document.querySelector(selector);
      if (container) {
        // Update the selector for future use
        SELECTORS.CHAT_CONTAINER = selector;
        resolve(container);
        return;
      }
    }

    // If still not found, try again after a delay (page might be loading)
    console.warn('Chat container not found. Retrying in 2 seconds...');
    setTimeout(() => {
      // One last attempt with body as fallback
      const lastResort = document.body;
      resolve(lastResort);
    }, 2000);
  });
}

/**
 * Generate a unique session ID based on timestamp
 */
function generateSessionId() {
  return `session_${Date.now()}`;
}

/**
 * Create a simple hash for message deduplication
 */
function createHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash.toString(16);
}

/**
 * Inject the export button with dropdown menu into the page
 */
function injectExportButton() {
  // Check if button already exists
  if (document.getElementById('deepseek-export-btn')) {
    return;
  }

  // Create container for the button and dropdown
  const container = document.createElement('div');
  container.id = 'deepseek-export-container';
  container.className = 'deepseek-export-container';

  // Create the main export button
  const exportButton = document.createElement('button');
  exportButton.id = 'deepseek-export-btn';
  exportButton.className = 'deepseek-export-btn';

  // 添加文本和箭头图标
  const buttonText = document.createElement('span');
  buttonText.textContent = chrome.i18n.getMessage('exportButtonText') || 'Export Chat';

  // 创建 SVG 箭头图标 - 使用用户提供的SVG
  const arrowIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  arrowIcon.classList.add('arrow-icon');
  arrowIcon.setAttribute('viewBox', '0 0 24 24');
  arrowIcon.setAttribute('fill', 'none');
  arrowIcon.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('d', 'M12 15.5L7 10.5L8.41 9.09L12 12.67L15.59 9.09L17 10.5L12 15.5Z');
  path.setAttribute('fill', 'currentColor');
  path.setAttribute('stroke-linejoin', 'round');

  arrowIcon.appendChild(path);

  // 将文本和图标添加到按钮
  exportButton.appendChild(buttonText);
  exportButton.appendChild(arrowIcon);

  // Create the dropdown menu
  const dropdownMenu = document.createElement('div');
  dropdownMenu.id = 'deepseek-export-dropdown';
  dropdownMenu.className = 'deepseek-export-dropdown';
  dropdownMenu.style.display = 'none';

  // Create export as JSON option
  const jsonOption = document.createElement('div');
  jsonOption.className = 'deepseek-export-option';

  // 添加JSON选项的emoji图标和文本容器
  const jsonIconSpan = document.createElement('span');
  jsonIconSpan.className = 'option-icon';
  jsonIconSpan.textContent = '📄 ';

  const jsonTextSpan = document.createElement('span');
  jsonTextSpan.className = 'option-text';
  jsonTextSpan.textContent = chrome.i18n.getMessage('exportAsJSON') || 'Export as JSON';

  jsonOption.appendChild(jsonIconSpan);
  jsonOption.appendChild(jsonTextSpan);

  jsonOption.addEventListener('click', (e) => {
    e.stopPropagation();
    exportChat('json');
    dropdownMenu.style.display = 'none';
  });

  // Create export as Markdown option
  const markdownOption = document.createElement('div');
  markdownOption.className = 'deepseek-export-option';

  // 添加Markdown选项的emoji图标和文本容器
  const markdownIconSpan = document.createElement('span');
  markdownIconSpan.className = 'option-icon';
  markdownIconSpan.textContent = '📝 ';

  const markdownTextSpan = document.createElement('span');
  markdownTextSpan.className = 'option-text';
  markdownTextSpan.textContent = chrome.i18n.getMessage('exportAsMarkdown') || 'Export as Markdown';

  markdownOption.appendChild(markdownIconSpan);
  markdownOption.appendChild(markdownTextSpan);

  markdownOption.addEventListener('click', (e) => {
    e.stopPropagation();
    exportChat('markdown');
    dropdownMenu.style.display = 'none';
  });

  // Create export as Text option
  const textOption = document.createElement('div');
  textOption.className = 'deepseek-export-option';

  // 添加Text选项的emoji图标和文本容器
  const textIconSpan = document.createElement('span');
  textIconSpan.className = 'option-icon';
  textIconSpan.textContent = '📃 ';

  const textTextSpan = document.createElement('span');
  textTextSpan.className = 'option-text';
  textTextSpan.textContent = chrome.i18n.getMessage('exportAsText') || 'Export as Plain Text';

  textOption.appendChild(textIconSpan);
  textOption.appendChild(textTextSpan);

  textOption.addEventListener('click', (e) => {
    e.stopPropagation();
    exportChat('text');
    dropdownMenu.style.display = 'none';
  });

  // Create export as HTML option
  const htmlOption = document.createElement('div');
  htmlOption.className = 'deepseek-export-option';

  // 添加HTML选项的emoji图标和文本容器
  const htmlIconSpan = document.createElement('span');
  htmlIconSpan.className = 'option-icon';
  htmlIconSpan.textContent = '🌐 ';

  const htmlTextSpan = document.createElement('span');
  htmlTextSpan.className = 'option-text';
  htmlTextSpan.textContent = chrome.i18n.getMessage('exportAsHTML') || 'Export as HTML';

  htmlOption.appendChild(htmlIconSpan);
  htmlOption.appendChild(htmlTextSpan);

  htmlOption.addEventListener('click', (e) => {
    e.stopPropagation();
    exportChat('html');
    dropdownMenu.style.display = 'none';
  });

  // Add options to dropdown menu
  dropdownMenu.appendChild(jsonOption);
  dropdownMenu.appendChild(markdownOption);
  dropdownMenu.appendChild(textOption);
  dropdownMenu.appendChild(htmlOption);

  // Toggle dropdown menu when clicking the export button
  exportButton.addEventListener('click', (event) => {
    event.stopPropagation(); // 阻止事件冒泡
    const isVisible = dropdownMenu.style.display === 'block';
    dropdownMenu.style.display = isVisible ? 'none' : 'block';

    const arrowIcon = exportButton.querySelector('.arrow-icon');
    if (arrowIcon) {
      arrowIcon.style.transform = isVisible ? 'rotate(0deg)' : 'rotate(180deg)';
    }

  });

  // Prevent dropdown clicks from closing the dropdown
  dropdownMenu.addEventListener('click', (event) => {
    event.stopPropagation(); // 阻止事件冒泡
  });

  // Close dropdown when clicking outside
  document.addEventListener('click', () => {
    if (dropdownMenu.style.display === 'block') {
      dropdownMenu.style.display = 'none';

      // 恢复箭头图标方向
      const arrowIcon = exportButton.querySelector('.arrow-icon');
      if (arrowIcon) {
        arrowIcon.style.transform = 'rotate(0deg)';
      }

    }
  });

  // Add button and dropdown to container
  container.appendChild(exportButton);
  container.appendChild(dropdownMenu);

  // Remove any existing containers with the same ID to avoid conflicts
  const existingContainer = document.getElementById('deepseek-export-container');
  if (existingContainer) {
    existingContainer.remove();
  }

  // Add container to page
  document.body.appendChild(container);

  // Add CSS styles for the dropdown
  addExportStyles();

}

/**
 * Add CSS styles for the export button and dropdown
 */
function addExportStyles() {
  // Check if styles already exist
  if (document.getElementById('deepseek-export-styles')) {
    return;
  }

  // Create a link element to load the external CSS file
  const link = document.createElement('link');
  link.id = 'deepseek-export-styles';
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = chrome.runtime.getURL('styles.css');

  // Add the link to the document head
  document.head.appendChild(link);

}

/**
 * Set up MutationObserver to watch for new messages
 */
function setupChatObserver(chatContainer) {
  if (!chatContainer) {
    console.warn('No chat container provided for observer');
    return;
  }

  // Create a debounced message processor using the utility function
  const debouncedProcessMessages = debounce(processExistingMessages, 500);

  // Set up the observer
  const observer = new MutationObserver((mutations) => {
    let shouldProcess = false;

    for (const mutation of mutations) {
      if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
        shouldProcess = true;
        break;
      }
    }

    if (shouldProcess) {
      debouncedProcessMessages();
    }
  });

  // Start observing
  observer.observe(chatContainer, {
    childList: true,
    subtree: true
  });

}

/**
 * Process all existing messages in the chat
 */
function processExistingMessages() {
  // Try multiple selectors to find messages
  let messages = [];

  // Try primary selector first
  messages = document.querySelectorAll(SELECTORS.MESSAGE_CONTAINER);

  // If no messages found, try fallback selectors
  if (messages.length === 0) {
    for (const selector of FALLBACK_SELECTORS.filter(s => s.includes('message') || s.includes('chat-item'))) {
      messages = document.querySelectorAll(selector);
      if (messages.length > 0) {
        SELECTORS.MESSAGE_CONTAINER = selector; // Update for future use
        break;
      }
    }
  }

  // Special handling for DeepSeek's structure
  if (messages.length === 0) {
    // Look for AI response footers and their parent containers
    const aiFooters = document.querySelectorAll('div.fcaa63f8');
    if (aiFooters.length > 0) {

      aiFooters.forEach(footer => {
        // For each footer, find the parent message container
        let parent = footer.parentElement;
        while (parent && !parent.classList.contains('message-item') && parent.tagName !== 'BODY') {
          parent = parent.parentElement;
        }

        if (parent && parent.tagName !== 'BODY') {
          messages = [...messages, parent];
        }

        // Also add the footer itself as it contains the AI response text
        if (footer.textContent.trim() !== 'AI-generated, for reference only' &&
            !footer.textContent.includes('内容由 AI 生成')) {
          messages = [...messages, footer];
        }
      });
    }
  }

  // If still no messages, try a very broad selector
  if (messages.length === 0) {
    messages = document.querySelectorAll('div');
  }

  if (messages.length === 0) {
    console.warn('No messages found to process');
    return;
  }


  const messageData = [];

  messages.forEach((messageNode) => {
    // Skip if already processed
    if (processedMessages.has(messageNode)) {
      return;
    }

    const messageObj = extractMessageData(messageNode);
    if (messageObj) {
      messageData.push(messageObj);
      processedMessages.set(messageNode, true);
    }
  });

  if (messageData.length > 0) {
    saveMessages(messageData);
  }
}

/**
 * Clean up the content extracted from a message
 * @param {string} content - The raw content
 * @param {string} role - The role of the message (user or assistant)
 * @returns {string} The cleaned content
 */
function cleanMessageContent(content, role) {
  if (!content) return '';

  // 移除常见的AI生成页脚文本（使用更通用的模式）
  let cleaned = content;

  // 移除中文AI生成提示
  cleaned = cleaned.replace(/内容由\s*AI\s*生成[，,]?.*?(?=\n|$)/g, '');

  // 移除英文AI生成提示
  cleaned = cleaned.replace(/(?:Generated by AI|AI-generated).*?(?=\n|$)/g, '');

  // 移除DeepSeek特定的AI生成提示
  cleaned = cleaned.replace(/AI-generated, for reference only/g, '');

  // 移除其他可能的AI提示
  cleaned = cleaned.replace(/AI.*?generated.*?(?=\n|$)/g, '');

  // 移除"New chat"按钮文本
  cleaned = cleaned.replace(/New chat/g, '');

  // 移除可能的按钮和UI元素文本
  cleaned = cleaned.replace(/DeepThink \(R1\)/g, '');
  cleaned = cleaned.replace(/Search/g, '');
  cleaned = cleaned.replace(/Message DeepSeek/g, '');

  // 移除复制按钮文本
  cleaned = cleaned.replace(/Copy code/g, '');
  cleaned = cleaned.replace(/复制代码/g, '');

  // 移除可能的页脚元素
  cleaned = cleaned.replace(/fcaa63f8/g, '');

  // 移除多余空白和换行
  cleaned = cleaned.replace(/\n\s*\n/g, '\n');
  cleaned = cleaned.trim();

  return cleaned;
}

/**
 * Extract data from a message node
 */
function extractMessageData(messageNode) {
  try {
    // 跳过隐藏消息
    if (messageNode.offsetParent === null) {
      return null;
    }

    // 使用基于语义的方法确定角色
    const role = determineRoleBySemantics(messageNode);

    // 存储角色以供将来参考
    messageNode.dataset.role = role;

    // 提取内容 - 使用语义分析
    let content = '';

    // 1. 尝试找到明显的内容节点
    const contentNode = findContentNode(messageNode);
    if (contentNode) {
      content = contentNode.innerText || contentNode.textContent;
    } else {
      // 2. 如果没有明显的内容节点，使用消息节点的文本
      content = messageNode.innerText || messageNode.textContent;

      // 3. 移除可能的AI生成标记
      content = removeAIFooters(messageNode, content);
    }

    // 清理内容
    content = cleanMessageContent(content, role);

    // Skip empty messages
    if (!content) {
      return null;
    }

    // Generate element ID for reference
    const elementId = `chat-item-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

    return {
      role,
      content,
      element_id: elementId,
      hash: createHash(content + Date.now())
    };
  } catch (error) {
    console.error('Error extracting message data:', error);
    return null;
  }
}

/**
 * Save messages to chrome.storage.local
 */
function saveMessages(messages) {
  // Throttle storage updates
  const now = Date.now();
  if (now - lastStorageUpdate < STORAGE_THROTTLE) {
    return;
  }
  lastStorageUpdate = now;

  chrome.storage.local.get(['chatData'], (result) => {
    const chatData = result.chatData || {};

    // Initialize session if needed
    if (!chatData[currentSessionId]) {
      chatData[currentSessionId] = {
        messages: [],
        hashes: [],
        meta: {
          start_time: new Date().toISOString(),
          page_url: window.location.href,
          last_updated: now
        }
      };
    }

    // Add new messages, avoiding duplicates
    let newMessagesAdded = false;
    messages.forEach((message) => {
      if (!chatData[currentSessionId].hashes.includes(message.hash)) {
        chatData[currentSessionId].messages.push(message);
        chatData[currentSessionId].hashes.push(message.hash);
        newMessagesAdded = true;
      }
    });

    if (newMessagesAdded) {
      chatData[currentSessionId].meta.last_updated = now;

      // Notify background script about new messages
      chrome.runtime.sendMessage({
        action: 'newMessagesDetected',
        count: messages.length
      }, (response) => {
        // Handle response if needed
        if (chrome.runtime.lastError) {
          // Ignore errors from message sending
        }
      });

      chrome.storage.local.set({ chatData }, () => {
        if (chrome.runtime.lastError) {
          console.error('Error saving chat data:', chrome.runtime.lastError);
          // Retry with exponential backoff could be implemented here
        } else {
        }
      });
    }
  });
}

/**
 * Export the chat to a file in the specified format
 * @param {string} format - The format to export ('json', 'markdown', or 'text')
 */
function exportChat(format = 'json') {
  try {

    // 直接从页面提取最新消息
    const latestMessages = extractAllMessagesFromPage();

    if (latestMessages.length > 0) {
    }

    if (latestMessages.length === 0) {
      alert(chrome.i18n.getMessage('noMessagesFound'));
      return;
    }

    // 准备导出数据
    const exportData = {
      title: `DeepSeek Chat - ${new Date().toLocaleString()}`,
      url: window.location.href,
      date: new Date().toISOString(),
      messages: latestMessages
    };

    // 使用导出函数下载聊天数据
    downloadChat(exportData, format);
  } catch (error) {
    console.error('Error during export:', error);
    alert(chrome.i18n.getMessage('exportError'));
  }
}

/**
 * Download chat data as a file in the specified format
 * @param {Object} exportData - The data to export
 * @param {string} format - The format to export ('json', 'markdown', 'text', or 'html')
 */
function downloadChat(exportData, format = 'json') {
  try {
    // 确保有消息要导出
    if (!exportData.messages || exportData.messages.length === 0) {
      alert(chrome.i18n.getMessage('noMessagesOnPage'));
      return;
    }


    // 检查是否有包含chain_of_thought的消息
    const hasCOT = exportData.messages.some(msg => msg.chain_of_thought);

    // 格式化导出数据，确保包含用户问题、AI回答和思考过程
    // 注意：保持原始消息数组的顺序不变
    const formattedData = {
      title: exportData.title,
      url: exportData.url,
      date: exportData.date,
      messages: exportData.messages.map(msg => {
        const formattedMsg = {
          role: msg.role,
          content: msg.role === 'assistant' ? formatMessageContent(msg.content) : msg.content,
          format: msg.role === 'assistant' ? 'markdown' : 'text'
        };

        // 如果有思考过程，添加到导出消息中
        if (msg.chain_of_thought) {
          formattedMsg.chain_of_thought = formatMessageContent(msg.chain_of_thought);
        }

        return formattedMsg;
      })
    };

    let blob, filename, contentType;

    // 根据格式处理导出
    if (format === 'markdown') {
      const markdownContent = convertToMarkdown(formattedData);
      blob = new Blob([markdownContent], { type: 'text/markdown' });
      contentType = 'text/markdown';
      filename = `deepseek-chat-${new Date().toISOString().replace(/[:.]/g, '-')}.md`;
    } else if (format === 'text') {
      const textContent = convertToPlainText(formattedData);
      blob = new Blob([textContent], { type: 'text/plain' });
      contentType = 'text/plain';
      filename = `deepseek-chat-${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
    } else if (format === 'html') {
      const htmlContent = convertToHTML(formattedData);
      blob = new Blob([htmlContent], { type: 'text/html' });
      contentType = 'text/html';
      filename = `deepseek-chat-${new Date().toISOString().replace(/[:.]/g, '-')}.html`;
    } else {
      // 对于 JSON 格式，直接使用格式化后的数据
      blob = new Blob([JSON.stringify(formattedData, null, 2)], { type: 'application/json' });
      contentType = 'application/json';
      filename = `deepseek-chat-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
    }

    // 创建并下载文件
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();

    // 清理
    setTimeout(() => URL.revokeObjectURL(url), 50);

    // 添加视觉反馈
    const exportButton = document.getElementById('deepseek-export-btn');
    if (exportButton) {
      exportButton.classList.add('pulse');
      setTimeout(() => exportButton.classList.remove('pulse'), 300);
    }

  } catch (error) {
    console.error('Error exporting chat:', error);
    alert(chrome.i18n.getMessage('exportFailed'));
  }
}

/**
 * Convert chat data to Markdown format
 * @param {Object} data - The chat data to convert
 * @returns {string} - The Markdown content
 */
function convertToMarkdown(data) {

  // Create the header with metadata
  let markdown = `# ${data.title}\n\n`;
  markdown += `- **URL**: ${data.url}\n`;
  markdown += `- **Date**: ${new Date(data.date).toLocaleString()}\n\n`;
  markdown += `---\n\n`;

  // Process each message
  data.messages.forEach((msg, index) => {
    // Format the role header
    const roleIcon = msg.role === 'user' ? '🧑' : '🤖';
    const roleName = msg.role === 'user' ? 'User' : 'DeepSeek AI';
    markdown += `## ${roleIcon} ${roleName}\n\n`;

    // Process the content with special handling for code blocks
    const formattedContent = formatMessageContent(msg.content);
    markdown += `${formattedContent}\n\n`;

    // Add chain of thought if available
    if (msg.chain_of_thought) {
      markdown += `<details>\n<summary>Chain of Thought</summary>\n\n`;
      const formattedCOT = formatMessageContent(msg.chain_of_thought);
      markdown += `${formattedCOT}\n\n`;
      markdown += `</details>\n\n`;
    }

    // Add separator between messages
    if (index < data.messages.length - 1) {
      markdown += `---\n\n`;
    }
  });

  return markdown;
}

/**
 * Format message content for Markdown, with special handling for code blocks
 * @param {string} content - The message content to format
 * @returns {string} - The formatted content
 */
function formatMessageContent(content) {
  if (!content) return '';

  // Replace HTML tags with their Markdown equivalents
  let formatted = content
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<p>(.*?)<\/p>/gi, '$1\n\n')
    .replace(/<strong>(.*?)<\/strong>/gi, '**$1**')
    .replace(/<em>(.*?)<\/em>/gi, '*$1*')
    .replace(/<h1>(.*?)<\/h1>/gi, '# $1\n')
    .replace(/<h2>(.*?)<\/h2>/gi, '## $1\n')
    .replace(/<h3>(.*?)<\/h3>/gi, '### $1\n')
    .replace(/<h4>(.*?)<\/h4>/gi, '#### $1\n')
    .replace(/<h5>(.*?)<\/h5>/gi, '##### $1\n')
    .replace(/<h6>(.*?)<\/h6>/gi, '###### $1\n');

  // Create a temporary DOM element to parse the HTML
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = formatted;

  // Process code blocks
  const processCodeBlock = (element, language = '') => {
    // Get the raw HTML content
    const rawHtml = element.innerHTML;

    // Replace HTML entities and tags
    let codeContent = rawHtml
      .replace(/<button.*?<\/button>/gi, '')
      .replace(/<div class="ds-code-header".*?<\/div>/gi, '')
      .replace(/<div class="ds-code-content".*?>([\s\S]*?)<\/div>/gi, '$1');

    // Decode HTML entities
    codeContent = codeContent
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&amp;/g, '&')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/&nbsp;/g, ' ');

    // Remove any remaining HTML tags
    codeContent = codeContent.replace(/<[^>]*>/g, '');

    // Preserve line breaks
    codeContent = codeContent.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

    // Return formatted code block
    return `\`\`\`${language}\n${codeContent.trim()}\n\`\`\`\n`;
  };

  // Process lists (both ordered and unordered)
  const processList = (listElement, isOrdered = false) => {
    let markdown = '';
    let index = 1;

    // Process each list item
    Array.from(listElement.children).forEach(item => {
      if (item.tagName.toLowerCase() === 'li') {
        const prefix = isOrdered ? `${index++}. ` : '- ';
        let content = item.innerHTML;

        // Check for nested lists
        const nestedLists = [];
        item.querySelectorAll('ul, ol').forEach(nestedList => {
          const placeholder = `__LIST_${nestedLists.length}__`;
          nestedLists.push({
            placeholder,
            content: processList(nestedList, nestedList.tagName.toLowerCase() === 'ol')
          });
          content = content.replace(nestedList.outerHTML, placeholder);
        });

        // Process the content without the nested lists
        content = content
          .replace(/<br\s*\/?>/gi, '\n')
          .replace(/<p>(.*?)<\/p>/gi, '$1\n')
          .replace(/<strong>(.*?)<\/strong>/gi, '**$1**')
          .replace(/<em>(.*?)<\/em>/gi, '*$1*')
          .replace(/<code>(.*?)<\/code>/gi, '`$1`');

        // Remove any remaining HTML tags
        content = content.replace(/<[^>]*>/g, '');

        // Replace placeholders with the processed nested lists
        nestedLists.forEach(nestedList => {
          const indentedContent = nestedList.content
            .split('\n')
            .map(line => '  ' + line)
            .join('\n');
          content = content.replace(nestedList.placeholder, '\n' + indentedContent);
        });

        markdown += prefix + content.trim() + '\n';
      }
    });

    return markdown;
  };

  // Find and process all code blocks
  const codeBlocks = [];

  // Handle fenced code blocks with language specification
  tempDiv.querySelectorAll('pre code[class*="language-"]').forEach(codeElement => {
    const language = Array.from(codeElement.classList)
      .find(cls => cls.startsWith('language-'))
      ?.replace('language-', '') || '';

    const placeholder = `__CODE_BLOCK_${codeBlocks.length}__`;
    codeBlocks.push(processCodeBlock(codeElement, language));
    codeElement.parentElement.outerHTML = placeholder;
  });

  // Handle DeepSeek specific code blocks
  tempDiv.querySelectorAll('.ds-code-block, .code-block').forEach(blockElement => {
    const language = blockElement.getAttribute('data-language') || '';
    const placeholder = `__CODE_BLOCK_${codeBlocks.length}__`;
    codeBlocks.push(processCodeBlock(blockElement, language));
    blockElement.outerHTML = placeholder;
  });

  // Process md-code-block specifically
  const processMdCodeBlock = (blockElement) => {
    // 尝试提取语言信息
    let language = '';
    const infoStringElement = blockElement.querySelector('.md-code-block-infostring');
    if (infoStringElement) {
      language = infoStringElement.textContent.trim();

      // 如果语言信息是markdown，我们需要特殊处理
      if (language.toLowerCase() === 'markdown' || language.toLowerCase() === 'md') {
        // 标记为markdown代码块，而不是解释为markdown
        language = 'markdown';
      }
    }

    // 查找代码内容
    let codeContent = '';

    // 首先尝试查找pre标签 - 对于md代码块，我们应该只关注pre中的内容
    const preElements = blockElement.querySelectorAll('pre');
    if (preElements && preElements.length > 0) {
      // 如果有多个pre标签，将它们合并为一个代码块
      const preContents = [];
      preElements.forEach(preElement => {
        // 获取pre元素的原始HTML内容
        let preContent = preElement.innerHTML || '';

        // 递归处理嵌套的token spans
        // 这个函数会处理嵌套的token span元素，保留其中的文本内容
        const processNestedTokens = (html) => {
          // 使用正则表达式匹配最内层的token spans (没有嵌套其他spans的spans)
          const innerTokenRegex = /<span class="token [^"]*">([^<]*)<\/span>/g;
          let result = html;

          // 如果找到了匹配项，替换它们
          if (innerTokenRegex.test(html)) {
            result = html.replace(innerTokenRegex, '$1');
            // 递归处理，直到没有更多的内层token spans
            return processNestedTokens(result);
          }

          return result;
        };

        // 处理嵌套的token spans
        preContent = processNestedTokens(preContent);

        // 移除所有剩余的HTML标签，但保留内容
        preContent = preContent.replace(/<[^>]*>/g, '');

        // 清理HTML实体
        preContent = preContent.trim()
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&amp;/g, '&')
          .replace(/&quot;/g, '"')
          .replace(/&#39;/g, "'")
          .replace(/&nbsp;/g, ' ');

        preContents.push(preContent);
      });
      codeContent = preContents.join('\n\n');
    } else {
      // 如果没有找到pre标签，尝试获取整个元素的文本内容
      codeContent = blockElement.textContent || '';

      // 移除可能存在的语言信息和复制按钮文本
      if (infoStringElement) {
        codeContent = codeContent.replace(infoStringElement.textContent, '');
      }

      // 移除"复制"按钮文本
      const copyButton = blockElement.querySelector('.ds-markdown-code-copy-button');
      if (copyButton) {
        codeContent = codeContent.replace(copyButton.textContent, '');
      }

      // 移除footer中的"运行"文本
      const footer = blockElement.querySelector('.md-code-block-footer');
      if (footer) {
        codeContent = codeContent.replace(footer.textContent, '');
      }
    }

    // 清理代码内容
    codeContent = codeContent.trim()
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&amp;/g, '&')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/&nbsp;/g, ' ');

    // 保留换行，并处理缩进
    codeContent = codeContent.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

    // 处理多余的缩进 - 特别是在DeepSeek代码块中常见的情况
    const contentLines = codeContent.split('\n');
    // 检查是否所有非空行都有相同的前导空格
    const nonEmptyLines = contentLines.filter(line => line.trim().length > 0);
    if (nonEmptyLines.length > 0) {
      // 找出共同的缩进
      const commonIndent = nonEmptyLines.reduce((indent, line) => {
        const lineIndent = line.match(/^\s*/)[0].length;
        return Math.min(indent, lineIndent);
      }, Infinity);

      // 如果有共同的缩进，移除它
      if (commonIndent > 0 && commonIndent !== Infinity) {
        codeContent = contentLines.map(line =>
          line.length >= commonIndent ? line.substring(commonIndent) : line
        ).join('\n');
      }
    }

    // 检查是否是AI生成的markdown内容
    // 如果内容包含markdown语法但不在代码块中，我们应该将整个内容视为代码块
    const containsMarkdownSyntax = (
      /^#+ .+$/m.test(codeContent) || // 标题
      /^\* .+$/m.test(codeContent) || // 无序列表
      /^- .+$/m.test(codeContent) || // 无序列表
      /^\d+\. .+$/m.test(codeContent) || // 有序列表
      /^\> .+$/m.test(codeContent) || // 引用
      /\[.+\]\(.+\)/.test(codeContent) || // 链接
      /!\[.+\]\(.+\)/.test(codeContent) || // 图片
      /\*\*.+\*\*/.test(codeContent) || // 粗体
      /\*.+\*/.test(codeContent) || // 斜体
      /^---+$/m.test(codeContent) || // 分隔线
      /^\|.+\|.+\|$/m.test(codeContent) // 表格
    );

    // 如果内容包含markdown语法，并且没有指定语言或语言不是markdown，
    // 则将语言设置为markdown，以确保它被视为代码块而不是解释为markdown
    if (containsMarkdownSyntax && (!language || language.toLowerCase() !== 'markdown')) {
      language = 'markdown';
    }

    // 检查代码内容是否已经包含结束标记 ```
    const hasClosingBackticks = /```\s*$/m.test(codeContent);

    // 如果已经有结束标记，移除它，我们会在返回时添加统一的结束标记
    if (hasClosingBackticks) {
      codeContent = codeContent.replace(/```\s*$/m, '');
    }

    // 检查是否有多余的开始标记
    const extraStartingBackticks = codeContent.match(/^```(?:([a-zA-Z0-9_+-]+))?/m);
    if (extraStartingBackticks) {
      // 如果找到了开始标记，提取语言（如果有）并移除开始标记
      if (extraStartingBackticks[1] && !language) {
        language = extraStartingBackticks[1].trim();
      }
      codeContent = codeContent.replace(/^```(?:[a-zA-Z0-9_+-]+)?\n?/m, '');
    }

    // 确保代码内容不以 ``` 开头，这可能是错误提取的语言标记
    if (codeContent.startsWith('```')) {
      const codeLines = codeContent.split('\n');
      // 如果第一行只有 ```，移除它
      if (codeLines[0].trim() === '```') {
        codeLines.shift();
        codeContent = codeLines.join('\n');
      }
      // 如果第一行是 ```language，提取语言并移除该行
      else if (codeLines[0].trim().startsWith('```') && codeLines[0].trim().length > 3) {
        const firstLineLang = codeLines[0].trim().substring(3).trim();
        if (!language && firstLineLang) {
          language = firstLineLang;
        }
        codeLines.shift();
        codeContent = codeLines.join('\n');
      }
    }

    // 检查代码内容中是否有可能被错误包含的markdown元素
    // 这些元素可能表明代码块应该在此处结束
    const lines = codeContent.split('\n');
    let cleanedLines = [];
    let shouldTerminate = false;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // 检查这一行是否看起来像是markdown的开始
      if (
        line.startsWith('# ') ||
        line.startsWith('## ') ||
        line.startsWith('### ') ||
        line.startsWith('- ') ||
        line.startsWith('* ') ||
        line.startsWith('1. ') ||
        line.startsWith('> ') ||
        line.match(/^\|.*\|$/) || // 表格行
        line.match(/^[A-Za-z0-9_-]+:/) // 可能是YAML前置元数据
      ) {
        // 如果语言是markdown，我们不应该终止代码块，因为这些是markdown语法的一部分
        if (language.toLowerCase() !== 'markdown') {
          // 如果这一行看起来像是markdown的开始，我们应该在这里终止代码块
          shouldTerminate = true;
          break;
        }
      }

      cleanedLines.push(lines[i]);
    }

    // 如果我们检测到应该终止代码块，使用清理后的行
    if (shouldTerminate && cleanedLines.length > 0) {
      codeContent = cleanedLines.join('\n');
    }

    // 检查内部嵌套的代码块
    const nestedCodeBlockStart = codeContent.match(/```([a-zA-Z0-9_+-]*)[\s\n]/);
    if (nestedCodeBlockStart) {
      // 检查是否有对应的结束标记
      const nestedCodeBlockEnd = codeContent.indexOf("```", nestedCodeBlockStart.index + nestedCodeBlockStart[0].length);

      // 如果没有找到结束标记，或者结束标记在最后一行，我们需要添加一个
      if (nestedCodeBlockEnd === -1) {
        // 添加结束标记到内容的末尾
        codeContent = codeContent.trim() + "\n```";
      }
    }

    // 确保代码块以 ``` 结尾
    return `\`\`\`${language}\n${codeContent.trim()}\n\`\`\`\n`;
  };

  // Handle md-code-block class (DeepSeek specific)
  tempDiv.querySelectorAll('.md-code-block').forEach(blockElement => {
    const placeholder = `__CODE_BLOCK_${codeBlocks.length}__`;
    codeBlocks.push(processMdCodeBlock(blockElement));
    blockElement.outerHTML = placeholder;
  });

  // Handle regular code blocks
  tempDiv.querySelectorAll('pre code').forEach(codeElement => {
    const placeholder = `__CODE_BLOCK_${codeBlocks.length}__`;
    codeBlocks.push(processCodeBlock(codeElement));
    codeElement.parentElement.outerHTML = placeholder;
  });

  // Find and process all lists
  const lists = [];

  // Process ordered lists
  tempDiv.querySelectorAll('ol').forEach(listElement => {
    // Skip nested lists as they will be processed with their parent
    if (!listElement.closest('li')) {
      const placeholder = `__LIST_BLOCK_${lists.length}__`;
      lists.push(processList(listElement, true));
      listElement.outerHTML = placeholder;
    }
  });

  // Process unordered lists
  tempDiv.querySelectorAll('ul').forEach(listElement => {
    // Skip nested lists as they will be processed with their parent
    if (!listElement.closest('li')) {
      const placeholder = `__LIST_BLOCK_${lists.length}__`;
      lists.push(processList(listElement, false));
      listElement.outerHTML = placeholder;
    }
  });

  // Get the processed content
  formatted = tempDiv.innerHTML;

  // Replace code block placeholders with actual code blocks
  codeBlocks.forEach((codeBlock, index) => {
    formatted = formatted.replace(`__CODE_BLOCK_${index}__`, codeBlock);
  });

  // Replace list placeholders with actual lists
  lists.forEach((list, index) => {
    formatted = formatted.replace(`__LIST_BLOCK_${index}__`, list);
  });

  // Handle inline code
  formatted = formatted.replace(/<code>(.*?)<\/code>/gi, '`$1`');
  formatted = formatted.replace(/<span class="[^"]*code[^"]*">(.*?)<\/span>/gi, '`$1`');

  // Handle links
  formatted = formatted.replace(/<a href="(.*?)".*?>(.*?)<\/a>/gi, '[$2]($1)');

  // Handle images
  formatted = formatted.replace(/<img src="(.*?)".*?>/gi, '![]($1)');

  // Handle blockquotes
  formatted = formatted.replace(/<blockquote>([\s\S]*?)<\/blockquote>/gi, (match, quote) => {
    return quote.split('\n').map(line => `> ${line}`).join('\n');
  });

  // Handle tables (simplified)
  formatted = formatted.replace(/<table>([\s\S]*?)<\/table>/gi, (match, tableContent) => {
    let mdTable = '';

    // Extract header
    const headerMatch = tableContent.match(/<thead>([\s\S]*?)<\/thead>/i);
    if (headerMatch) {
      const headerCells = headerMatch[1].match(/<th>(.*?)<\/th>/gi);
      if (headerCells) {
        mdTable += '| ' + headerCells.map(cell => cell.replace(/<\/?th>/gi, '').trim()).join(' | ') + ' |\n';
        mdTable += '| ' + headerCells.map(() => '---').join(' | ') + ' |\n';
      }
    }

    // Extract body
    const bodyMatch = tableContent.match(/<tbody>([\s\S]*?)<\/tbody>/i);
    if (bodyMatch) {
      const rows = bodyMatch[1].match(/<tr>([\s\S]*?)<\/tr>/gi);
      if (rows) {
        rows.forEach(row => {
          const cells = row.match(/<td>(.*?)<\/td>/gi);
          if (cells) {
            mdTable += '| ' + cells.map(cell => cell.replace(/<\/?td>/gi, '').trim()).join(' | ') + ' |\n';
          }
        });
      }
    }

    return mdTable;
  });

  // Handle DeepSeek specific markdown blocks
  formatted = formatted.replace(/<div class="ds-markdown.*?">([\s\S]*?)<\/div>/gi, '$1');
  formatted = formatted.replace(/<div class="ds-markdown--block.*?">([\s\S]*?)<\/div>/gi, '$1');

  // Remove any remaining HTML tags
  formatted = formatted.replace(/<[^>]*>/g, '');

  // Decode HTML entities
  formatted = formatted
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&nbsp;/g, ' ');

  // 验证并修复代码块的结束标记
  formatted = validateCodeBlocks(formatted);

  return formatted;
}

/**
 * 验证并修复 Markdown 中的代码块，确保所有代码块都有正确的开始和结束标记
 * @param {string} markdown - Markdown 文本
 * @returns {string} - 修复后的 Markdown 文本
 */
function validateCodeBlocks(markdown) {
  if (!markdown) return '';

  // 首先处理已经存在的代码块，确保它们有正确的结束标记
  let processedMarkdown = markdown;

  // 查找所有以 ``` 开始但没有以 ``` 结束的代码块
  const codeBlockRegex = /```([^\n]*)\n([\s\S]*?)(?:```|$)/g;
  processedMarkdown = processedMarkdown.replace(codeBlockRegex, (match, language, code) => {
    // 如果代码块已经有结束标记，保持不变
    if (match.endsWith('```')) {
      return match;
    }
    // 否则添加结束标记
    return `\`\`\`${language}\n${code}\n\`\`\``;
  });

  // 再次检查，确保所有代码块都有正确的开始和结束标记
  const lines = processedMarkdown.split('\n');
  const result = [];
  let inCodeBlock = false;
  let codeBlockStartIndex = -1;
  let codeBlockLanguage = '';
  let codeBlockContent = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmedLine = line.trim();

    // 检测代码块开始
    if (!inCodeBlock && trimmedLine.startsWith('```')) {
      inCodeBlock = true;
      codeBlockStartIndex = i;
      // 提取语言信息
      codeBlockLanguage = trimmedLine.substring(3).trim();
      result.push(line);
      codeBlockContent = [];
    }
    // 检测代码块结束
    else if (inCodeBlock && trimmedLine === '```') {
      inCodeBlock = false;
      codeBlockStartIndex = -1;
      codeBlockLanguage = '';
      codeBlockContent = [];
      result.push(line);
    }
    // 普通行
    else {
      if (inCodeBlock) {
        codeBlockContent.push(line);
      }
      result.push(line);
    }

    // 特殊情况：如果我们在代码块内，但下一行看起来像是新内容的开始（例如标题、列表项等），
    // 这可能意味着代码块没有正确结束
    if (inCodeBlock && i < lines.length - 1) {
      const nextLine = lines[i + 1].trim();
      // 检查下一行是否看起来像是新内容的开始
      if (
        nextLine.startsWith('# ') ||
        nextLine.startsWith('## ') ||
        nextLine.startsWith('### ') ||
        nextLine.startsWith('- ') ||
        nextLine.startsWith('* ') ||
        nextLine.startsWith('1. ') ||
        nextLine.startsWith('> ') ||
        nextLine.match(/^[A-Za-z0-9_-]+:/) // 可能是YAML前置元数据
      ) {
        // 在当前行后添加代码块结束标记
        result.push('```');
        inCodeBlock = false;
        codeBlockStartIndex = -1;
        codeBlockLanguage = '';
        codeBlockContent = [];
      }
    }
  }

  // 如果到文档末尾还在代码块中，添加结束标记
  if (inCodeBlock) {
    result.push('```');
  }

  return result.join('\n');
}

/**
 * Convert chat data to plain text format
 * @param {Object} data - The chat data to convert
 * @returns {string} - The plain text content
 */
function convertToPlainText(data) {
  // Create the header with metadata
  let text = `${data.title}\n\n`;
  text += `URL: ${data.url}\n`;
  text += `Date: ${new Date(data.date).toLocaleString()}\n\n`;
  text += `----------------------------------------\n\n`;

  // Process each message
  data.messages.forEach((msg, index) => {
    // Format the role header
    const roleName = msg.role === 'user' ? 'User' : 'DeepSeek AI';
    text += `${roleName}:\n\n`;

    // Add the content, stripping HTML and preserving code blocks
    const plainContent = msg.content
      .replace(/<br\s*\/?>/gi, '\n')  // Replace <br> with newlines
      .replace(/<\/p>/gi, '\n\n')     // Replace </p> with double newlines
      .replace(/<[^>]*>/g, '')        // Remove all other HTML tags
      .replace(/&nbsp;/g, ' ')        // Replace &nbsp; with spaces
      .replace(/&lt;/g, '<')          // Replace &lt; with <
      .replace(/&gt;/g, '>')          // Replace &gt; with >
      .replace(/&amp;/g, '&')         // Replace &amp; with &
      .replace(/&quot;/g, '"')        // Replace &quot; with "
      .replace(/&apos;/g, "'")        // Replace &apos; with '
      .trim();                        // Trim whitespace

    text += `${plainContent}\n\n`;

    // Add chain of thought if available
    if (msg.chain_of_thought) {
      text += `Thinking process:\n\n`;
      const plainCOT = msg.chain_of_thought
        .replace(/<br\s*\/?>/gi, '\n')
        .replace(/<\/p>/gi, '\n\n')
        .replace(/<[^>]*>/g, '')
        .replace(/&nbsp;/g, ' ')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&')
        .replace(/&quot;/g, '"')
        .replace(/&apos;/g, "'")
        .trim();
      text += `${plainCOT}\n\n`;
    }

    // Add separator between messages
    if (index < data.messages.length - 1) {
      text += `----------------------------------------\n\n`;
    }
  });

  return text;
}

/**
 * 从页面中提取所有消息
 * @returns {Array} 消息数组
 */
function extractAllMessagesFromPage() {

  try {
    // 1. 查找用户问题 (使用 .fbb737a4 类)
    const userQuestions = document.querySelectorAll('.fbb737a4');

    // 2. 查找AI回答 (使用 .ds-markdown 和 .ds-markdown--block 类)
    const aiResponses = document.querySelectorAll('.ds-markdown, .ds-markdown--block');

    // 3. 查找思考过程容器 (使用 .e1675d8b 类)
    const cotContainers = document.querySelectorAll('.e1675d8b');

    // 如果没有找到任何消息，使用备用方法
    if (userQuestions.length === 0 && aiResponses.length === 0 && cotContainers.length === 0) {
      return findMessagesByPattern();
    }

    // 创建一个数组来存储所有消息元素及其类型和位置
    const allElements = [];

    // 添加用户问题
    userQuestions.forEach(el => {
      allElements.push({
        element: el,
        type: 'user',
        position: getElementPosition(el)
      });
    });

    // 添加AI回答
    aiResponses.forEach(el => {
      allElements.push({
        element: el,
        type: 'ai',
        position: getElementPosition(el)
      });
    });

    // 添加思考过程容器
    cotContainers.forEach(el => {
      allElements.push({
        element: el,
        type: 'cot_container',
        position: getElementPosition(el)
      });
    });

    // 按照元素在DOM中的位置排序
    allElements.sort((a, b) => {
      return a.position - b.position;
    });


    // 处理排序后的元素
    const messages = [];
    let lastAiMessageIndex = -1;
    let pendingCOT = null; // 存储等待关联的COT内容
    let currentUserQuestion = null;

    allElements.forEach((item, index) => {
      const { element, type } = item;
      const content = extractMessageContent(element);

      if (!content) return;

      if (type === 'user') {
        // 处理用户问题
        currentUserQuestion = {
          role: 'user',
          content: cleanMessageContent(content, 'user'),
          element_id: element.id || `user-${index}-${Date.now()}`
        };

        messages.push(currentUserQuestion);
        lastAiMessageIndex = -1; // 重置最后一个AI消息的索引
      }
      else if (type === 'ai') {
        // 处理AI回答
        const aiMessage = {
          role: 'assistant',
          content: cleanMessageContent(content, 'assistant'),
          element_id: element.id || `ai-${index}-${Date.now()}`
        };

        // 如果有待处理的COT，将其添加到这个AI消息中
        if (pendingCOT) {
          aiMessage.chain_of_thought = pendingCOT;
          pendingCOT = null; // 清除待处理的COT
        }

        messages.push(aiMessage);
        lastAiMessageIndex = messages.length - 1;
      }
      else if (type === 'cot_container') {
        // 处理思考过程容器
        const cotContent = extractCOTFromContainer(element);

        if (cotContent) {
          // 如果有最近的AI消息，将思考过程添加到该消息
          if (lastAiMessageIndex >= 0) {
            messages[lastAiMessageIndex].chain_of_thought = cotContent;
          }
          // 如果没有最近的AI消息，存储COT以便与下一个AI消息关联
          else {
            pendingCOT = cotContent;
          }
        }
      }
    });

    // 处理最后可能剩余的待处理COT
    if (pendingCOT && messages.length > 0) {
      // 尝试找到最后一条消息
      const lastMessage = messages[messages.length - 1];

      // 如果最后一条消息是AI消息，将COT添加到该消息
      if (lastMessage.role === 'assistant') {
        lastMessage.chain_of_thought = pendingCOT;
      }
      // 如果最后一条消息是用户消息，创建一个新的AI消息
      else if (lastMessage.role === 'user') {
        const aiMessage = {
          role: 'assistant',
          content: "See chain of thought reasoning below:",
          element_id: `ai-final-${Date.now()}`,
          chain_of_thought: pendingCOT
        };

        messages.push(aiMessage);
      }
    }

    return messages;
  } catch (error) {
    console.error('Error extracting messages from page:', error);
    return findMessagesByPattern();
  }
}

/**
 * 从思考过程容器中提取内容
 * @param {Element} container - 思考过程容器元素
 * @returns {string} 清理后的思考过程内容
 */
function extractCOTFromContainer(container) {
  try {
    if (!container) return '';

    // 首先尝试查找所有 .ba94db8a 元素
    const cotElements = container.querySelectorAll('.ba94db8a');

    if (cotElements && cotElements.length > 0) {
      // 如果找到了 .ba94db8a 元素，提取它们的内容
      const cotTexts = [];
      cotElements.forEach(el => {
        const text = el.textContent.trim();
        if (text) {
          cotTexts.push(text);
        }
      });

      // 将所有内容合并为一个字符串
      const combinedText = cotTexts.join('\n\n');
      return cleanMessageContent(combinedText, 'assistant');
    }

    // 如果没有找到 .ba94db8a 元素，尝试查找所有段落元素
    const paragraphs = container.querySelectorAll('p');
    if (paragraphs && paragraphs.length > 0) {
      const paragraphTexts = [];
      paragraphs.forEach(p => {
        const text = p.textContent.trim();
        if (text) {
          paragraphTexts.push(text);
        }
      });

      if (paragraphTexts.length > 0) {
        const combinedText = paragraphTexts.join('\n\n');
        return cleanMessageContent(combinedText, 'assistant');
      }
    }

    // 如果没有找到段落元素，尝试直接提取容器的内容
    const directContent = container.textContent.trim();
    if (directContent) {
      return cleanMessageContent(directContent, 'assistant');
    }

    return '';
  } catch (error) {
    console.error('Error extracting COT content:', error);
    return '';
  }
}

/**
 * 获取元素在DOM中的位置
 * @param {Element} element - 要获取位置的元素
 * @returns {number} 元素的位置值
 */
function getElementPosition(element) {
  // 使用TreeWalker遍历DOM树，找到元素的位置
  const treeWalker = document.createTreeWalker(
    document.body,
    NodeFilter.SHOW_ELEMENT,
    null,
    false
  );

  let position = 0;
  let found = false;

  while (treeWalker.nextNode()) {
    position++;
    if (treeWalker.currentNode === element) {
      found = true;
      break;
    }
  }

  return found ? position : Number.MAX_SAFE_INTEGER;
}

/**
 * 基于内容模式查找消息
 * @returns {Array} 消息元素数组
 */
function findMessagesByPattern() {
  const extractedMessages = [];

  try {
    // 1. 查找所有可能的用户消息容器
    const userContainers = document.querySelectorAll('.fbb737a4, .e214291b, [data-role="user"]');

    // 2. 查找所有可能的AI消息容器
    const aiContainers = document.querySelectorAll('.ds-markdown, .ds-markdown--block, .c92459f0, [data-role="assistant"]');

    // 3. 查找所有可能的思考过程容器
    const cotContainers = document.querySelectorAll('.e1675d8b');
    const cotElements = document.querySelectorAll('.ba94db8a');

    // 创建一个数组来存储所有消息元素及其类型和位置
    const allElements = [];

    // 添加用户消息
    userContainers.forEach(el => {
      allElements.push({
        element: el,
        type: 'user',
        position: getElementPosition(el)
      });
    });

    // 添加AI消息
    aiContainers.forEach(el => {
      allElements.push({
        element: el,
        type: 'ai',
        position: getElementPosition(el)
      });
    });

    // 添加思考过程容器
    cotContainers.forEach(el => {
      allElements.push({
        element: el,
        type: 'cot_container',
        position: getElementPosition(el)
      });
    });

    // 按照元素在DOM中的位置排序
    allElements.sort((a, b) => {
      return a.position - b.position;
    });


    // 处理排序后的元素
    let lastAiMessageIndex = -1;
    let pendingCOT = null; // 存储等待关联的COT内容
    let currentUserQuestion = null;

    allElements.forEach((item, index) => {
      const { element, type } = item;
      const content = extractMessageContent(element);

      if (!content) return;

      if (type === 'user') {
        // 处理用户消息
        currentUserQuestion = {
          role: 'user',
          content: cleanMessageContent(content, 'user'),
          element_id: element.id || `user-${index}-${Date.now()}`
        };

        extractedMessages.push(currentUserQuestion);
        lastAiMessageIndex = -1; // 重置最后一个AI消息的索引
      }
      else if (type === 'ai') {
        // 处理AI消息
        const aiMessage = {
          role: 'assistant',
          content: cleanMessageContent(content, 'assistant'),
          element_id: element.id || `ai-${index}-${Date.now()}`
        };

        // 如果有待处理的COT，将其添加到这个AI消息中
        if (pendingCOT) {
          aiMessage.chain_of_thought = pendingCOT;
          pendingCOT = null; // 清除待处理的COT
        }

        extractedMessages.push(aiMessage);
        lastAiMessageIndex = extractedMessages.length - 1;
      }
      else if (type === 'cot_container') {
        // 处理思考过程容器
        const cotContent = extractCOTFromContainer(element);

        if (cotContent) {
          // 如果有最近的AI消息，将思考过程添加到该消息
          if (lastAiMessageIndex >= 0) {
            extractedMessages[lastAiMessageIndex].chain_of_thought = cotContent;
          }
          // 如果没有最近的AI消息，存储COT以便与下一个AI消息关联
          else {
            pendingCOT = cotContent;
          }
        }
      }
    });

    // 处理最后可能剩余的待处理COT
    if (pendingCOT && extractedMessages.length > 0) {
      // 尝试找到最后一条消息
      const lastMessage = extractedMessages[extractedMessages.length - 1];

      // 如果最后一条消息是AI消息，将COT添加到该消息
      if (lastMessage.role === 'assistant') {
        lastMessage.chain_of_thought = pendingCOT;
      }
      // 如果最后一条消息是用户消息，创建一个新的AI消息
      else if (lastMessage.role === 'user') {
        const aiMessage = {
          role: 'assistant',
          content: "See chain of thought reasoning below:",
          element_id: `ai-final-${Date.now()}`,
          chain_of_thought: pendingCOT
        };

        extractedMessages.push(aiMessage);
      }
    }

    // 如果仍然没有找到消息，尝试更广泛的搜索
    if (extractedMessages.length === 0) {

      // 查找所有可能包含文本的元素
      const allTextElements = document.querySelectorAll('div, p, section, article');
      const potentialMessages = Array.from(allTextElements).filter(el => {
        const text = el.textContent.trim();
        // 过滤掉太短的文本和明显的UI元素
        return text.length > 20 &&
               !text.includes('New chat') &&
               !text.includes('Sign in') &&
               !text.includes('Sign up') &&
               el.offsetParent !== null; // 确保元素可见
      });


      // 尝试确定每个元素的角色并提取内容
      potentialMessages.forEach((element, index) => {
        const role = determineRoleBySemantics(element);
        const content = extractMessageContent(element);

        if (content && role !== 'unknown') {
          extractedMessages.push({
            role,
            content: cleanMessageContent(content, role),
            element_id: element.id || `potential-message-${index}-${Date.now()}`
          });
        }
      });
    }

  } catch (error) {
    console.error('Error in pattern-based message extraction:', error);
  }

  return extractedMessages;
}

/**
 * 查找消息中的内容节点
 * @param {Element} messageNode - 消息节点
 * @returns {Element|null} 内容节点或null
 */
function findContentNode(messageNode) {
  // 检查是否是DeepSeek特定的消息结构
  if (messageNode.classList.contains('e214291b')) {
    // 用户消息 - 查找textarea
    const textarea = messageNode.querySelector('textarea');
    if (textarea) {
      return textarea;
    }
  }

  // 检查用户问题类
  if (messageNode.classList.contains('fbb737a4')) {
    return messageNode;
  }

  // 检查AI回复类
  if (messageNode.classList.contains('c92459f0') ||
      messageNode.classList.contains('ds-markdown') ||
      messageNode.classList.contains('ds-markdown--block')) {
    return messageNode;
  }

  // 检查AI思考过程类
  if (messageNode.classList.contains('ba94db8a')) {
    return messageNode;
  }

  // 检查是否有ID为chat-input的元素（用户输入框）
  const chatInput = messageNode.querySelector('#chat-input');
  if (chatInput) {
    return chatInput;
  }

  // 检查是否包含特定类的子元素
  const userContentNode = messageNode.querySelector('.fbb737a4');
  if (userContentNode) {
    return userContentNode;
  }

  const aiContentNode = messageNode.querySelector('.ds-markdown, .ds-markdown--block');
  if (aiContentNode) {
    return aiContentNode;
  }

  const cotContentNode = messageNode.querySelector('.ba94db8a');
  if (cotContentNode) {
    return cotContentNode;
  }

  // 1. 查找具有内容相关类名的元素
  for (const pattern of SELECTORS.CONTENT_PATTERNS) {
    const contentNodes = messageNode.querySelectorAll(`[class*="${pattern}"]`);
    if (contentNodes.length > 0) {
      // 返回最可能的内容节点（通常是最大的文本节点）
      return Array.from(contentNodes).sort((a, b) =>
        b.textContent.length - a.textContent.length
      )[0];
    }
  }

  // 2. 查找具有段落或文本特征的元素
  const textElements = messageNode.querySelectorAll('p, div > div:only-child');
  if (textElements.length > 0) {
    return Array.from(textElements).sort((a, b) =>
      b.textContent.length - a.textContent.length
    )[0];
  }

  // 3. 如果消息节点只有一个子元素，可能是内容节点
  if (messageNode.children.length === 1) {
    return messageNode.children[0];
  }

  return null;
}

/**
 * 移除AI生成的页脚文本
 * @param {Element} messageNode - 消息节点
 * @param {string} content - 原始内容
 * @returns {string} 清理后的内容
 */
function removeAIFooters(messageNode, content) {
  // 查找可能的AI页脚元素
  const footerElements = Array.from(messageNode.querySelectorAll('div, p, span, .fcaa63f8'))
    .filter(el => {
      const text = el.textContent.toLowerCase();
      return SELECTORS.AI_FOOTER_PATTERNS.some(pattern =>
        text.includes(pattern.toLowerCase())
      );
    });

  // 从内容中移除页脚文本
  let cleanedContent = content;

  // 特别处理DeepSeek的AI生成页脚
  const deepseekFooter = messageNode.querySelector('.fcaa63f8');
  if (deepseekFooter) {
    cleanedContent = cleanedContent.replace(deepseekFooter.textContent, '');
  }

  footerElements.forEach(footer => {
    cleanedContent = cleanedContent.replace(footer.textContent, '');
  });

  // 移除常见的AI生成页脚文本
  cleanedContent = cleanedContent.replace(/AI-generated, for reference only/gi, '');
  cleanedContent = cleanedContent.replace(/AI-generated/gi, '');
  cleanedContent = cleanedContent.replace(/Generated by AI/gi, '');
  cleanedContent = cleanedContent.replace(/内容由\s*AI\s*生成/gi, '');

  return cleanedContent;
}

/**
 * 基于语义确定消息的角色
 * @param {Element} messageNode - The message node
 * @returns {string} The role of the message ('user', 'assistant', or 'unknown')
 */
function determineRoleBySemantics(messageNode) {
  // 检查data-role属性
  if (messageNode.dataset.role === 'user') {
    return 'user';
  } else if (messageNode.dataset.role === 'assistant') {
    return 'assistant';
  }

  // 检查特定的类名
  if (messageNode.classList.contains('e214291b') ||
      messageNode.classList.contains('fbb737a4') ||
      messageNode.closest('.e214291b, .fbb737a4') !== null) {
    return 'user';
  }

  if (messageNode.classList.contains('c92459f0') ||
      messageNode.classList.contains('ds-markdown') ||
      messageNode.classList.contains('ds-markdown--block') ||
      messageNode.closest('.c92459f0, .ds-markdown, .ds-markdown--block') !== null) {
    return 'assistant';
  }

  // 检查是否包含思考过程元素
  if (messageNode.classList.contains('ba94db8a') ||
      messageNode.closest('.ba94db8a') !== null ||
      messageNode.querySelector('.ba94db8a') !== null) {
    return 'assistant';
  }

  // 1. 检查类名和属性中的角色指示
  const classAndAttrs = messageNode.className + ' ' +
                        (messageNode.getAttribute('role') || '') + ' ' +
                        (messageNode.getAttribute('aria-label') || '');

  const classString = classAndAttrs.toLowerCase();

  // 检查用户角色指示
  const hasUserIndicator = SELECTORS.USER_MESSAGE_PATTERNS.some(pattern =>
    classString.includes(pattern)
  );

  // 检查AI角色指示
  const hasAIIndicator = SELECTORS.AI_MESSAGE_PATTERNS.some(pattern =>
    classString.includes(pattern)
  );

  // 检查AI思考过程指示
  const hasCOTIndicator = SELECTORS.AI_COT_PATTERNS.some(pattern =>
    classString.includes(pattern)
  );

  if (hasUserIndicator && !hasAIIndicator && !hasCOTIndicator) return 'user';
  if ((hasAIIndicator || hasCOTIndicator) && !hasUserIndicator) return 'assistant';

  // 2. 检查内容中的AI生成指示
  const content = messageNode.textContent.toLowerCase();
  const hasAIFooter = SELECTORS.AI_FOOTER_PATTERNS.some(pattern =>
    content.includes(pattern.toLowerCase())
  );

  if (hasAIFooter) return 'assistant';

  // 3. 检查子元素中的AI指示
  const hasAIFooterElement = Array.from(messageNode.querySelectorAll('*')).some(el =>
    SELECTORS.AI_FOOTER_PATTERNS.some(pattern =>
      el.textContent.toLowerCase().includes(pattern.toLowerCase())
    )
  );

  if (hasAIFooterElement) return 'assistant';

  // 检查子元素中的特定类
  const hasUserClass = messageNode.querySelector('.fbb737a4') !== null;
  const hasAIClass = messageNode.querySelector('.ds-markdown, .ds-markdown--block') !== null;
  const hasCOTClass = messageNode.querySelector('.ba94db8a') !== null;

  if (hasUserClass && !hasAIClass && !hasCOTClass) return 'user';
  if ((hasAIClass || hasCOTClass) && !hasUserClass) return 'assistant';

  // 4. 使用交替模式
  const prevRole = document.querySelector('[data-role]')?.dataset.role;

  if (prevRole === 'user') {
    return 'assistant';
  } else if (prevRole === 'assistant' || prevRole === null) {
    return 'user';
  }

  // 默认为用户消息
  return 'user';
}

/**
 * 分析页面结构以识别聊天模式
 */
function analyzePageStructure() {

  // 检查是否有带有data-role="user"的元素
  const userRoleElements = document.querySelectorAll('[data-role="user"]');
  if (userRoleElements.length > 0) {
    return;
  }

  // 1. 识别可能的消息容器
  const possibleContainers = findPossibleMessageContainers();

  // 2. 识别对话模式
  identifyConversationPattern(possibleContainers);
}

/**
 * 查找可能包含消息的容器
 * @returns {Array} 可能的消息容器元素数组
 */
function findPossibleMessageContainers() {
  // 寻找具有重复结构的容器
  const allDivs = Array.from(document.querySelectorAll('div'));
  const containers = [];

  // 查找包含多个子元素且结构相似的容器
  allDivs.forEach(div => {
    const children = Array.from(div.children);

    // 至少有2个子元素的容器
    if (children.length >= 2) {
      // 检查子元素是否有相似的结构
      const similarStructure = children.filter(child =>
        child.tagName === children[0].tagName &&
        child.className === children[0].className
      ).length >= 2;

      if (similarStructure) {
        containers.push(div);
      }
    }
  });

  return containers;
}

/**
 * 识别对话模式
 * @param {Array} containers 可能的消息容器
 */
function identifyConversationPattern(containers) {
  // 对于每个容器，尝试识别用户/AI消息的模式
  containers.forEach(container => {
    const children = Array.from(container.children);

    // 检查是否有交替的用户/AI消息模式
    let userMessages = 0;
    let aiMessages = 0;

    children.forEach(child => {
      const text = child.textContent.toLowerCase();
      const classList = child.className.toLowerCase();

      // 检查是否是用户消息
      const isUserMessage = SELECTORS.USER_MESSAGE_PATTERNS.some(pattern =>
        classList.includes(pattern) || text.includes(pattern)
      );

      // 检查是否是AI消息
      const isAIMessage = SELECTORS.AI_MESSAGE_PATTERNS.some(pattern =>
        classList.includes(pattern) || text.includes(pattern)
      ) || SELECTORS.AI_FOOTER_PATTERNS.some(pattern => text.includes(pattern));

      if (isUserMessage) userMessages++;
      if (isAIMessage) aiMessages++;
    });

    // 如果同时有用户和AI消息，这可能是一个对话容器
    if (userMessages > 0 && aiMessages > 0) {
      // 更新选择器以使用这个容器
      SELECTORS.IDENTIFIED_CONTAINER = container;
    }
  });
}

/**
 * Process a message element and extract its content
 * @param {Element} messageElement - The message element to process
 * @returns {Object|null} - The processed message or null if processing failed
 */
function processMessage(messageElement) {
  if (!messageElement) return null;

  try {
    // 确定消息角色
    const role = determineRoleBySemantics(messageElement);

    // 查找内容节点
    const contentNode = findContentNode(messageElement);
    if (!contentNode) {
      console.warn('Could not find content node for message:', messageElement);
      return null;
    }

    // 提取消息内容
    let content = extractMessageContent(contentNode);
    if (!content) {
      console.warn('Could not extract content for message:', messageElement);
      return null;
    }

    // 清理消息内容
    content = cleanMessageContent(content, role);

    // 生成消息的唯一标识
    const elementId = messageElement.id || generateUniqueId();

    // 创建消息对象
    const message = {
      role,
      content,
      element_id: elementId
    };

    // 如果是AI消息，尝试提取思考过程
    if (role === 'assistant') {
      // 查找相关的思考过程元素
      const cotElements = Array.from(messageElement.querySelectorAll('.ba94db8a'));

      // 如果在当前元素中没有找到，尝试在相邻元素中查找
      if (cotElements.length === 0) {
        // 查找消息容器
        const messageContainer = messageElement.closest('.message-container') || messageElement.parentElement;
        if (messageContainer) {
          // 查找同一容器中的思考过程元素
          const containerCotElements = Array.from(messageContainer.querySelectorAll('.ba94db8a'));
          cotElements.push(...containerCotElements);
        }

        // 查找紧随其后的思考过程元素
        let nextElement = messageElement.nextElementSibling;
        while (nextElement && cotElements.length === 0) {
          if (nextElement.classList.contains('ba94db8a') || nextElement.querySelector('.ba94db8a')) {
            cotElements.push(nextElement.classList.contains('ba94db8a') ?
              nextElement : nextElement.querySelector('.ba94db8a'));
          }
          nextElement = nextElement.nextElementSibling;
        }
      }

      // 处理找到的思考过程元素
      if (cotElements.length > 0) {

        // 合并所有思考过程内容
        const cotContents = cotElements.map(cotElement => {
          const cotContent = extractMessageContent(cotElement);
          return cotContent ? cleanMessageContent(cotContent, 'assistant') : '';
        }).filter(Boolean);

        if (cotContents.length > 0) {
          message.chain_of_thought = cotContents.join('\n\n');
        }
      }
    }

    return message;
  } catch (error) {
    console.error('Error processing message:', error);
    return null;
  }
}

/**
 * Extract the text content from a message node
 * @param {Element} node - The node to extract content from
 * @returns {string} - The extracted content
 */
function extractMessageContent(node) {
  if (!node) return '';

  try {
    // 如果是输入元素，获取其值
    if (node.tagName === 'INPUT' || node.tagName === 'TEXTAREA') {
      return node.value.trim();
    }

    // 创建节点的克隆，以便我们可以修改它而不影响原始DOM
    const clone = node.cloneNode(true);

    // 移除所有代码块的复制按钮
    clone.querySelectorAll('button').forEach(button => {
      if (button.textContent.includes('Copy') ||
          button.textContent.includes('复制') ||
          button.classList.contains('copy-button')) {
        button.remove();
      }
    });

    // 移除所有不可见元素
    clone.querySelectorAll('*').forEach(el => {
      const style = window.getComputedStyle(el);
      if (style.display === 'none' || style.visibility === 'hidden') {
        el.remove();
      }
    });

    // 获取文本内容
    let content = clone.textContent.trim();

    // 如果内容为空，尝试获取innerHTML
    if (!content && node.innerHTML) {
      // 创建临时元素来解析HTML
      const temp = document.createElement('div');
      temp.innerHTML = node.innerHTML;

      // 移除所有脚本和样式标签
      temp.querySelectorAll('script, style').forEach(el => el.remove());

      content = temp.textContent.trim();
    }

    return content;
  } catch (error) {
    console.error('Error extracting message content:', error);
    return '';
  }
}

/**
 * Generate a unique ID for a message
 * @returns {string} - A unique ID
 */
function generateUniqueId() {
  return 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
}

/**
 * Detect and extract DeepSeek code blocks
 * @param {Element} element - The element to check for code blocks
 * @returns {Object|null} - Code block object with language and content, or null if not a code block
 */
function detectDeepSeekCodeBlock(element) {
  if (!element) return null;

  try {
    // Check for md-code-block class (new DeepSeek format)
    if (element.classList.contains('md-code-block')) {
      let language = '';
      const infoStringElement = element.querySelector('.md-code-block-infostring');
      if (infoStringElement) {
        language = infoStringElement.textContent.trim();
      }

      // Find the code content in pre tag
      let codeContent = '';
      const preElement = element.querySelector('pre');
      if (preElement) {
        // Get the HTML content to preserve formatting
        let preHtml = preElement.innerHTML;

        // 递归处理嵌套的token spans
        // 这个函数会处理嵌套的token span元素，保留其中的文本内容
        const processNestedTokens = (html) => {
          // 使用正则表达式匹配最内层的token spans (没有嵌套其他spans的spans)
          const innerTokenRegex = /<span class="token [^"]*">([^<]*)<\/span>/g;
          let result = html;

          // 如果找到了匹配项，替换它们
          if (innerTokenRegex.test(html)) {
            result = html.replace(innerTokenRegex, '$1');
            // 递归处理，直到没有更多的内层token spans
            return processNestedTokens(result);
          }

          return result;
        };

        // 处理嵌套的token spans
        preHtml = processNestedTokens(preHtml);

        // Remove any remaining HTML tags
        codeContent = preHtml.replace(/<[^>]*>/g, '');

        // Clean HTML entities
        codeContent = codeContent
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&amp;/g, '&')
          .replace(/&quot;/g, '"')
          .replace(/&#39;/g, "'")
          .replace(/&nbsp;/g, ' ');

        // 处理多余的缩进 - 特别是在DeepSeek代码块中常见的情况
        const contentLines = codeContent.split('\n');
        // 检查是否所有非空行都有相同的前导空格
        const nonEmptyLines = contentLines.filter(line => line.trim().length > 0);
        if (nonEmptyLines.length > 0) {
          // 找出共同的缩进
          const commonIndent = nonEmptyLines.reduce((indent, line) => {
            const lineIndent = line.match(/^\s*/)[0].length;
            return Math.min(indent, lineIndent);
          }, Infinity);

          // 如果有共同的缩进，移除它
          if (commonIndent > 0 && commonIndent !== Infinity) {
            codeContent = contentLines.map(line =>
              line.length >= commonIndent ? line.substring(commonIndent) : line
            ).join('\n');
          }
        }

        // 检查内部嵌套的代码块
        const nestedCodeBlockStart = codeContent.match(/```([a-zA-Z0-9_+-]*)[\s\n]/);
        if (nestedCodeBlockStart) {
          // 检查是否有对应的结束标记
          const nestedCodeBlockEnd = codeContent.indexOf("```", nestedCodeBlockStart.index + nestedCodeBlockStart[0].length);

          // 如果没有找到结束标记，或者结束标记在最后一行，我们需要添加一个
          if (nestedCodeBlockEnd === -1) {
            // 添加结束标记到内容的末尾
            codeContent = codeContent.trim() + "\n```";
          }
        }
      } else {
        // If no pre element, get the text content and clean it
        codeContent = element.textContent;

        // Remove language info and UI elements text
        if (infoStringElement) {
          codeContent = codeContent.replace(infoStringElement.textContent, '');
        }

        // Remove "复制" button text
        const copyButton = element.querySelector('.ds-markdown-code-copy-button');
        if (copyButton) {
          codeContent = codeContent.replace(copyButton.textContent, '');
        }

        // Remove footer text like "运行 HTML"
        const footer = element.querySelector('.md-code-block-footer');
        if (footer) {
          codeContent = codeContent.replace(footer.textContent, '');
        }
      }

      return {
        language,
        content: codeContent.trim()
      };
    }

    // Check for DeepSeek specific code block classes
    if (element.classList.contains('ds-code-block') ||
        element.classList.contains('code-block') ||
        element.querySelector('.ds-code-block, .code-block')) {

      // Find the target element (either this element or a child)
      const targetElement = element.classList.contains('ds-code-block') || element.classList.contains('code-block')
        ? element
        : element.querySelector('.ds-code-block, .code-block');

      if (!targetElement) return null;

      // Try to find the language
      let language = '';

      // Check data-language attribute
      if (targetElement.hasAttribute('data-language')) {
        language = targetElement.getAttribute('data-language');
      }

      // Check for language in class names
      if (!language) {
        const classMatch = Array.from(targetElement.classList).find(cls => cls.startsWith('language-'));
        if (classMatch) {
          language = classMatch.replace('language-', '');
        }
      }

      // Find the code content
      let codeContent = '';

      // First try to find a specific code content container
      const codeContentElement = targetElement.querySelector('.ds-code-content, .code-content');
      if (codeContentElement) {
        codeContent = codeContentElement.textContent;
      } else {
        // Otherwise use the element's text content, excluding any buttons or headers
        const clone = targetElement.cloneNode(true);

        // Remove copy buttons and headers
        clone.querySelectorAll('button, .ds-code-header, .code-header').forEach(el => el.remove());

        codeContent = clone.textContent;
      }

      return {
        language,
        content: codeContent.trim()
      };
    }

    // Check for pre/code elements
    const preElement = element.tagName === 'PRE' ? element : element.querySelector('pre');
    if (preElement) {
      const codeElement = preElement.querySelector('code');
      if (codeElement) {
        // Check for language class
        let language = '';
        const classMatch = Array.from(codeElement.classList).find(cls => cls.startsWith('language-'));
        if (classMatch) {
          language = classMatch.replace('language-', '');
        }

        return {
          language,
          content: codeElement.textContent.trim()
        };
      }
    }

    return null;
  } catch (error) {
    console.error('Error detecting code block:', error);
    return null;
  }
}

/**
 * Extract code blocks from a message element
 * @param {Element} messageElement - The message element to process
 * @returns {Array} - Array of code block objects with language and content
 */
function extractCodeBlocks(messageElement) {
  if (!messageElement) return [];

  const codeBlocks = [];

  try {
    // Find all potential code block elements
    const potentialCodeBlocks = [
      // First check for the new md-code-block format
      ...messageElement.querySelectorAll('.md-code-block'),
      // Also check for ds-markdown--block elements that might contain code blocks
      ...messageElement.querySelectorAll('.ds-markdown--block .md-code-block'),
      // Then check for other code block formats
      ...messageElement.querySelectorAll('.ds-code-block, .code-block, pre, [class*="code"]'),
      ...Array.from(messageElement.querySelectorAll('div')).filter(div => {
        const text = div.textContent;
        // Look for indented blocks with code-like content
        return text.split('\n').filter(line =>
          /^\s{4,}/.test(line) && /[=(){}\[\];]/.test(line)
        ).length > 2;
      })
    ];

    // Process each potential code block
    potentialCodeBlocks.forEach(element => {
      // Skip if already processed
      if (element.dataset.processed === 'true') {
        return;
      }

      // 检查是否是嵌套在ds-markdown中的代码块
      const isInMarkdown = element.closest('.ds-markdown, .ds-markdown--block');

      const codeBlock = detectDeepSeekCodeBlock(element);
      if (codeBlock) {
        // 如果是在markdown中的代码块，添加标记
        if (isInMarkdown) {
          codeBlock.isInMarkdown = true;
        }

        codeBlocks.push(codeBlock);

        // Mark this element as processed to avoid duplicate processing
        element.dataset.processed = 'true';
      }
    });

    return codeBlocks;
  } catch (error) {
    console.error('Error extracting code blocks:', error);
    return [];
  }
}

/**
 * Convert chat data to HTML format
 * @param {Object} data - The chat data to convert
 * @returns {string} - The HTML content
 */
function convertToHTML(data) {
  // 创建基本的HTML结构
  let html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${data.title}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f9f9f9;
    }
    .chat-header {
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 1px solid #eaeaea;
    }
    .chat-title {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    .chat-metadata {
      font-size: 14px;
      color: #666;
      margin-bottom: 5px;
    }
    .message-container {
      margin-bottom: 25px;
      padding-bottom: 25px;
      border-bottom: 1px solid #eaeaea;
    }
    .message-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .user-message .message-header {
      color: #2962FF;
    }
    .ai-message .message-header {
      color: #00796B;
    }
    .message-role {
      font-weight: bold;
      font-size: 16px;
      margin-left: 8px;
    }
    .message-content {
      background-color: #fff;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .user-message .message-content {
      background-color: #E3F2FD;
    }
    .ai-message .message-content {
      background-color: #E0F2F1;
    }
    .chain-of-thought {
      margin-top: 15px;
      padding: 12px;
      background-color: #FFF8E1;
      border-radius: 6px;
      border-left: 3px solid #FFB300;
    }
    .chain-of-thought-header {
      font-weight: bold;
      margin-bottom: 8px;
      color: #F57C00;
    }
    pre {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
    }
    code {
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
    }
    .code-block {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
      margin: 15px 0;
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
      white-space: pre-wrap;
    }
    .language-header {
      font-size: 12px;
      color: #666;
      margin-bottom: 5px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="chat-header">
    <div class="chat-title">${data.title}</div>
    <div class="chat-metadata">URL: ${data.url}</div>
    <div class="chat-metadata">Date: ${new Date(data.date).toLocaleString()}</div>
  </div>
`;

  // 处理每条消息
  data.messages.forEach(msg => {
    const roleClass = msg.role === 'user' ? 'user-message' : 'ai-message';
    const roleIcon = msg.role === 'user' ? '🧑' : '🤖';
    const roleName = msg.role === 'user' ? 'User' : 'DeepSeek AI';

    // 处理消息内容，如果是 Markdown 格式，转换为 HTML
    let processedContent = msg.content;
    if (msg.format === 'markdown') {
      processedContent = convertMarkdownToHTML(msg.content);
    }

    html += `  <div class="message-container ${roleClass}">
    <div class="message-header">
      <span>${roleIcon}</span>
      <span class="message-role">${roleName}</span>
    </div>
    <div class="message-content">
      ${processedContent}
    </div>`;

    // 添加思考过程（如果有）
    if (msg.chain_of_thought) {
      // 处理思考过程内容，如果是 Markdown 格式，转换为 HTML
      let processedCOT = msg.chain_of_thought;
      if (msg.format === 'markdown') {
        processedCOT = convertMarkdownToHTML(msg.chain_of_thought);
      }

      html += `    <div class="chain-of-thought">
      <div class="chain-of-thought-header">Thinking Process:</div>
      ${processedCOT}
    </div>`;
    }

    html += `  </div>\n`;
  });

  // 关闭HTML结构
  html += `</body>
</html>`;

  return html;
}

/**
 * 将 Markdown 格式的文本转换为 HTML
 * @param {string} markdown - Markdown 文本
 * @returns {string} - HTML 文本
 */
function convertMarkdownToHTML(markdown) {
  if (!markdown) return '';

  // 首先确保所有代码块都有正确的结束标记
  markdown = validateCodeBlocks(markdown);

  // 处理代码块
  let html = markdown.replace(/```([\s\S]*?)```/g, (match, codeContent) => {
    // 提取语言（如果有）
    const firstLine = codeContent.trim().split('\n')[0];
    let language = '';
    let code = codeContent;

    if (firstLine && !firstLine.includes('=') && !firstLine.includes('{') && !firstLine.includes(';')) {
      language = firstLine.trim();
      code = codeContent.substring(firstLine.length).trim();
    }

    return `<div class="code-block">
      ${language ? `<div class="language-header">${language}</div>` : ''}
      <pre><code>${escapeHTML(code)}</code></pre>
    </div>`;
  });

  // 处理标题
  html = html.replace(/^# (.*?)$/gm, '<h1>$1</h1>');
  html = html.replace(/^## (.*?)$/gm, '<h2>$1</h2>');
  html = html.replace(/^### (.*?)$/gm, '<h3>$1</h3>');
  html = html.replace(/^#### (.*?)$/gm, '<h4>$1</h4>');
  html = html.replace(/^##### (.*?)$/gm, '<h5>$1</h5>');
  html = html.replace(/^###### (.*?)$/gm, '<h6>$1</h6>');

  // 处理粗体和斜体
  html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');

  // 处理链接
  html = html.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank">$1</a>');

  // 处理无序列表
  html = html.replace(/^- (.*?)$/gm, '<li>$1</li>');
  html = html.replace(/(<li>.*?<\/li>\n)+/g, '<ul>$&</ul>');

  // 处理有序列表
  html = html.replace(/^\d+\. (.*?)$/gm, '<li>$1</li>');
  html = html.replace(/(<li>.*?<\/li>\n)+/g, (match) => {
    // 避免重复处理已经包装在 <ul> 中的列表
    return match.includes('<ul>') ? match : `<ol>${match}</ol>`;
  });

  // 处理引用
  html = html.replace(/^> (.*?)$/gm, '<blockquote>$1</blockquote>');

  // 处理分隔线
  html = html.replace(/^---$/gm, '<hr>');

  // 处理表格
  // 这是一个简化的表格处理，可能需要更复杂的逻辑来处理所有情况
  html = html.replace(/^\|(.*)\|$/gm, (match, content) => {
    const cells = content.split('|').map(cell => cell.trim());
    return `<tr>${cells.map(cell => `<td>${cell}</td>`).join('')}</tr>`;
  });

  // 将表格行组合成表格
  html = html.replace(/(<tr>.*?<\/tr>\n)+/g, '<table>$&</table>');

  // 处理段落
  html = html.replace(/^([^<].*?)$/gm, (match, content) => {
    // 避免处理已经包含在HTML标签中的内容
    if (
      content.trim() === '' ||
      content.startsWith('<') ||
      match.startsWith('<')
    ) {
      return match;
    }
    return `<p>${content}</p>`;
  });

  return html;
}

/**
 * 转义 HTML 特殊字符
 * @param {string} text - 要转义的文本
 * @returns {string} - 转义后的文本
 */
function escapeHTML(text) {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

// 添加消息监听器，处理来自弹出窗口的请求
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'export') {
    try {
      const format = request.format || 'json';

      // 直接从页面提取最新消息
      const latestMessages = extractAllMessagesFromPage();

      if (latestMessages.length === 0) {
        sendResponse({ success: false, message: chrome.i18n.getMessage('noMessagesFound') });
        return true;
      }

      // 准备导出数据
      const exportData = {
        title: `DeepSeek Chat - ${new Date().toLocaleString()}`,
        url: window.location.href,
        date: new Date().toISOString(),
        messages: latestMessages
      };

      // 使用导出函数下载聊天数据
      downloadChat(exportData, format);

      // 发送成功响应
      sendResponse({ success: true });
    } catch (error) {
      console.error('Error during export:', error);
      sendResponse({
        success: false,
        message: chrome.i18n.getMessage('exportError'),
        error: error.message
      });
    }
    return true;
  }
});

// 使用DOMContentLoaded事件更早地初始化插件
document.addEventListener('DOMContentLoaded', function() {
  init();
});

// 如果DOMContentLoaded已经触发，则立即初始化
if (document.readyState === 'interactive' || document.readyState === 'complete') {
  init();
}
