/**
 * DeepSeek Chat Exporter - Content Script
 *
 * This script monitors the DeepSeek chat interface, extracts messages,
 * and provides functionality to export conversations as JSON.
 */

// DOM Selectors
const SELECTORS = {
  // åŸºäºè¯­ä¹‰å’Œç»“æ„æ¨¡å¼çš„é€‰æ‹©å™¨
  CHAT_CONTAINER: 'main, [role="main"], .chat-container, .conversation, body',
  MESSAGE_CONTAINER: '[role="log"], .messages, .conversation-container, .ds-conversation',
  USER_MESSAGE_PATTERNS: ['user', 'human', 'you', 'question', 'query', 'input', 'e214291b', 'fbb737a4'],
  AI_MESSAGE_PATTERNS: ['ai', 'assistant', 'bot', 'chatbot', 'answer', 'response', 'generated', 'c92459f0', 'ds-markdown', 'ds-markdown--block', 'md-code-block'],
  AI_COT_PATTERNS: ['ba94db8a'], // Chain of thought reasoning
  CONTENT_PATTERNS: ['content', 'text', 'message', 'chat-content', 'c92459f0', 'e214291b', 'fbb737a4', 'ds-markdown', 'ds-markdown--block', 'md-code-block', 'ba94db8a'],
  AI_FOOTER_PATTERNS: ['AI-generated', 'Generated by AI', 'AI ç”Ÿæˆ', 'AI-generated, for reference only'],
  // ç›´æ¥é€‰æ‹©å™¨
  USER_ELEMENTS: '[data-role="user"], .e214291b, .fbb737a4',
  // ä»£ç å—é€‰æ‹©å™¨
  CODE_BLOCK_PATTERNS: ['.md-code-block', '.ds-code-block', '.code-block', 'pre', '.ds-markdown--block .md-code-block']
};

// Fallback selectors to try if primary selectors fail
const FALLBACK_SELECTORS = [
  // Chat container fallbacks
  'div.ds-conversation',
  '.ds-chat-container',
  'div[class*="conversation"]',
  'div[class*="chat"]',
  '.cbcaa82c',

  // Message item fallbacks
  'div[class*="message"]',
  'div[class*="chat-item"]',
  '.e214291b', // User message container
  '.c92459f0', // AI message container

  // Content text fallbacks
  'div[class*="content"]',
  'div[class*="text"]',
  '.e214291b textarea', // User input
  '.c92459f0', // AI response
  '.md-code-block' // DeepSeek markdown code block
];

// Cache of processed messages to prevent duplicates
let processedMessages = new WeakMap();

// Current session data
let currentSessionId = generateSessionId();
let lastStorageUpdate = 0;
const STORAGE_THROTTLE = 1000; // Limit storage updates to once per second

/**
 * Check if the current page is a DeepSeek chat page
 * @returns {boolean} True if the page is a DeepSeek chat page
 */
function isDeepSeekChatPage() {
  // æ£€æŸ¥URL
  const url = window.location.href;

  // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰DeepSeekç‰¹å®šçš„å…ƒç´ 
  if (document.querySelector('.e214291b, .c92459f0, .cbcaa82c, .ds-conversation, #chat-input') !== null) {
    return true;
  }

  // æ£€æŸ¥æ˜¯å¦æœ‰data-role="user"å…ƒç´ 
    if (document.querySelectorAll('[data-role="user"]').length > 0) {
      return true;
    }

    // å¦‚æœURLåŒ…å«deepseekï¼Œè¿›è¡Œæ›´è¯¦ç»†çš„æ£€æŸ¥
    if (url.includes('deepseek.com') || url.includes('deepseek.ai')) {
      // æ£€æŸ¥é¡µé¢æ˜¯å¦åŒ…å«èŠå¤©ç•Œé¢çš„ç‰¹å¾
      const hasChatElements =
        // æ£€æŸ¥æ˜¯å¦æœ‰å¯¹è¯å®¹å™¨
        document.querySelector('[role="log"]') !== null ||
        // æ£€æŸ¥æ˜¯å¦æœ‰AIç”Ÿæˆå†…å®¹çš„æŒ‡ç¤º
        Array.from(document.querySelectorAll('div')).some(div =>
          SELECTORS.AI_FOOTER_PATTERNS.some(pattern =>
            div.textContent.includes(pattern)
          )
        ) ||
        // æ£€æŸ¥æ˜¯å¦æœ‰è¾“å…¥æ¡†
        document.querySelector('textarea, [role="textbox"]') !== null;

      return hasChatElements;
    }

  return false;
}

/**
 * Debug the message structure on the page
 */
function debugMessageStructure() {

  try {
    // 1. æŸ¥æ‰¾å¯¹è¯å®¹å™¨
    const conversationContainer = document.querySelector('.ds-conversation, .cbcaa82c');

    if (conversationContainer) {
      // 2. è®°å½•å®¹å™¨çš„å­å…ƒç´ 

      // 3. æ£€æŸ¥æ¯ä¸ªå­å…ƒç´ çš„ç±»åå’Œç»“æ„
      Array.from(conversationContainer.children).forEach((child, index) => {

        // 4. æ£€æŸ¥æ˜¯å¦åŒ…å«ç”¨æˆ·/AIæ¶ˆæ¯ç‰¹å¾
        const hasUserClass = child.querySelector('.fbb737a4, .e214291b') !== null ||
                            child.classList.contains('fbb737a4') ||
                            child.classList.contains('e214291b');

        const hasAIClass = child.querySelector('.ds-markdown, .ds-markdown--block, .c92459f0') !== null ||
                          child.classList.contains('ds-markdown') ||
                          child.classList.contains('ds-markdown--block') ||
                          child.classList.contains('c92459f0');

        const hasCOTClass = child.querySelector('.ba94db8a') !== null ||
                           child.classList.contains('ba94db8a');


        // 5. å°è¯•æå–å†…å®¹
        const content = extractMessageContent(child);
      });
    }

    // 6. æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„ç”¨æˆ·æ¶ˆæ¯å…ƒç´ 
    const userElements = document.querySelectorAll('.fbb737a4, .e214291b, [data-role="user"]');
    userElements.forEach((el, i) => {
    });

    // 7. æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„AIæ¶ˆæ¯å…ƒç´ 
    const aiElements = document.querySelectorAll('.ds-markdown, .ds-markdown--block, .c92459f0, [data-role="assistant"]');
    aiElements.forEach((el, i) => {
    });

    // 8. æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„æ€è€ƒè¿‡ç¨‹å…ƒç´ 
    const cotElements = document.querySelectorAll('.ba94db8a');
    cotElements.forEach((el, i) => {
    });

    // 9. è®°å½•é¡µé¢ä¸Šæ‰€æœ‰ç±»åï¼Œå¸®åŠ©è¯†åˆ«æ–°çš„æ¨¡å¼
    const allClasses = new Set();
    document.querySelectorAll('*').forEach(el => {
      if (el.className && typeof el.className === 'string') {
        el.className.split(' ').forEach(cls => {
          if (cls) allClasses.add(cls);
        });
      }
    });
  } catch (error) {
    console.error('Error debugging message structure:', error);
  }
}

/**
 * Initialize the extension
 */
function init() {
  try {
    // æ£€æŸ¥æ˜¯å¦æ˜¯DeepSeekèŠå¤©é¡µé¢
    if (!isDeepSeekChatPage()) {
      return;
    }

    // ç«‹å³æ³¨å…¥å¯¼å‡ºæŒ‰é’®ï¼Œä¸ä½¿ç”¨å»¶è¿Ÿ
    try {
      injectExportButton();
    } catch (buttonError) {
      console.error('Error injecting export button:', buttonError);
      // Try again with a simpler approach
      try {
        const simpleButton = document.createElement('button');
        simpleButton.id = 'deepseek-export-btn-simple';
        simpleButton.textContent = 'Export Chat';
        simpleButton.style.cssText = 'position:fixed;top:20px;right:20px;z-index:9999999;background:#4285f4;color:white;border:none;border-radius:12px;padding:10px 16px;font-size:14px;cursor:pointer;';
        simpleButton.onclick = () => exportChat('json');
        document.body.appendChild(simpleButton);
      } catch (simpleButtonError) {
        console.error('Failed to inject simple button:', simpleButtonError);
      }
    }

    // é¦–å…ˆè¿›è¡Œä¸€æ¬¡è°ƒè¯•ï¼Œäº†è§£é¡µé¢ç»“æ„
    debugMessageStructure();

    // è®¾ç½®è§‚å¯Ÿå™¨æ¥ç›‘è§†é¡µé¢å˜åŒ–ï¼Œç‰¹åˆ«æ˜¯èŠå¤©æ¶ˆæ¯çš„å˜åŒ–
    const observer = new MutationObserver(debounce(() => {
      // å½“é¡µé¢å†…å®¹å˜åŒ–æ—¶ï¼Œå°è¯•æå–æ–°æ¶ˆæ¯
      const messages = extractAllMessagesFromPage();
      if (messages.length > 0) {
      } else {
      }
    }, 500)); // å‡å°‘debounceå»¶è¿Ÿ

    // æŸ¥æ‰¾èŠå¤©å®¹å™¨
    const chatContainer = document.querySelector('.ds-conversation, .cbcaa82c');

    if (chatContainer) {
      observer.observe(chatContainer, {
        childList: true,
        subtree: true,
        characterData: true,
        attributes: true
      });
    } else {
      console.warn('Chat container not found, observing body');
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
    }

    // åˆå§‹æå–æ¶ˆæ¯ - å‡å°‘å»¶è¿Ÿæ—¶é—´
    setTimeout(() => {
      const messages = extractAllMessagesFromPage();

      if (messages.length > 0) {
      } else {
        console.warn('No messages found on initial load');
        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ¶ˆæ¯ï¼Œå†æ¬¡è°ƒè¯•é¡µé¢ç»“æ„
        debugMessageStructure();
      }
    }, 500);
  } catch (error) {
    console.error('Error initializing extension:', error);
    try {
      injectExportButton();
    } catch (buttonError) {
      console.error('Failed to inject export button:', buttonError);
    }
  }
}

/**
 * Find the chat container with multiple fallback attempts
 * @returns {Promise<Element|null>} The chat container element or null if not found
 */
function findChatContainer() {
  return new Promise(resolve => {
    // First try the primary selector
    let container = document.querySelector(SELECTORS.CHAT_CONTAINER);

    if (container) {
      resolve(container);
      return;
    }

    // Try fallback selectors
    for (const selector of FALLBACK_SELECTORS) {
      container = document.querySelector(selector);
      if (container) {
        // Update the selector for future use
        SELECTORS.CHAT_CONTAINER = selector;
        resolve(container);
        return;
      }
    }

    // If still not found, try again after a delay (page might be loading)
    console.warn('Chat container not found. Retrying in 2 seconds...');
    setTimeout(() => {
      // One last attempt with body as fallback
      const lastResort = document.body;
      resolve(lastResort);
    }, 2000);
  });
}

/**
 * Generate a unique session ID based on timestamp
 */
function generateSessionId() {
  return `session_${Date.now()}`;
}

/**
 * Create a simple hash for message deduplication
 */
function createHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash.toString(16);
}

/**
 * Inject the export button with dropdown menu into the page
 */
function injectExportButton() {
  // Check if button already exists
  if (document.getElementById('deepseek-export-btn')) {
    return;
  }

  // Create container for the button and dropdown
  const container = document.createElement('div');
  container.id = 'deepseek-export-container';
  container.className = 'deepseek-export-container';

  // Create the main export button
  const exportButton = document.createElement('button');
  exportButton.id = 'deepseek-export-btn';
  exportButton.className = 'deepseek-export-btn';

  // æ·»åŠ æ–‡æœ¬å’Œç®­å¤´å›¾æ ‡
  const buttonText = document.createElement('span');
  buttonText.textContent = chrome.i18n.getMessage('exportButtonText') || 'Export Chat';

  // åˆ›å»º SVG ç®­å¤´å›¾æ ‡ - ä½¿ç”¨ç”¨æˆ·æä¾›çš„SVG
  const arrowIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  arrowIcon.classList.add('arrow-icon');
  arrowIcon.setAttribute('viewBox', '0 0 24 24');
  arrowIcon.setAttribute('fill', 'none');
  arrowIcon.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('d', 'M12 15.5L7 10.5L8.41 9.09L12 12.67L15.59 9.09L17 10.5L12 15.5Z');
  path.setAttribute('fill', 'currentColor');
  path.setAttribute('stroke-linejoin', 'round');

  arrowIcon.appendChild(path);

  // å°†æ–‡æœ¬å’Œå›¾æ ‡æ·»åŠ åˆ°æŒ‰é’®
  exportButton.appendChild(buttonText);
  exportButton.appendChild(arrowIcon);

  // Create the dropdown menu
  const dropdownMenu = document.createElement('div');
  dropdownMenu.id = 'deepseek-export-dropdown';
  dropdownMenu.className = 'deepseek-export-dropdown';
  dropdownMenu.style.display = 'none';

  // Create export as JSON option
  const jsonOption = document.createElement('div');
  jsonOption.className = 'deepseek-export-option';

  // æ·»åŠ JSONé€‰é¡¹çš„emojiå›¾æ ‡å’Œæ–‡æœ¬å®¹å™¨
  const jsonIconSpan = document.createElement('span');
  jsonIconSpan.className = 'option-icon';
  jsonIconSpan.textContent = 'ğŸ“„ ';

  const jsonTextSpan = document.createElement('span');
  jsonTextSpan.className = 'option-text';
  jsonTextSpan.textContent = chrome.i18n.getMessage('exportAsJSON') || 'Export as JSON';

  jsonOption.appendChild(jsonIconSpan);
  jsonOption.appendChild(jsonTextSpan);

  jsonOption.addEventListener('click', (e) => {
    e.stopPropagation();
    exportChat('json');
    dropdownMenu.style.display = 'none';
  });

  // Create export as Markdown option
  const markdownOption = document.createElement('div');
  markdownOption.className = 'deepseek-export-option';

  // æ·»åŠ Markdowné€‰é¡¹çš„emojiå›¾æ ‡å’Œæ–‡æœ¬å®¹å™¨
  const markdownIconSpan = document.createElement('span');
  markdownIconSpan.className = 'option-icon';
  markdownIconSpan.textContent = 'ğŸ“ ';

  const markdownTextSpan = document.createElement('span');
  markdownTextSpan.className = 'option-text';
  markdownTextSpan.textContent = chrome.i18n.getMessage('exportAsMarkdown') || 'Export as Markdown';

  markdownOption.appendChild(markdownIconSpan);
  markdownOption.appendChild(markdownTextSpan);

  markdownOption.addEventListener('click', (e) => {
    e.stopPropagation();
    exportChat('markdown');
    dropdownMenu.style.display = 'none';
  });

  // Create export as Text option
  const textOption = document.createElement('div');
  textOption.className = 'deepseek-export-option';

  // æ·»åŠ Texté€‰é¡¹çš„emojiå›¾æ ‡å’Œæ–‡æœ¬å®¹å™¨
  const textIconSpan = document.createElement('span');
  textIconSpan.className = 'option-icon';
  textIconSpan.textContent = 'ğŸ“ƒ ';

  const textTextSpan = document.createElement('span');
  textTextSpan.className = 'option-text';
  textTextSpan.textContent = chrome.i18n.getMessage('exportAsText') || 'Export as Plain Text';

  textOption.appendChild(textIconSpan);
  textOption.appendChild(textTextSpan);

  textOption.addEventListener('click', (e) => {
    e.stopPropagation();
    exportChat('text');
    dropdownMenu.style.display = 'none';
  });

  // Create export as HTML option
  const htmlOption = document.createElement('div');
  htmlOption.className = 'deepseek-export-option';

  // æ·»åŠ HTMLé€‰é¡¹çš„emojiå›¾æ ‡å’Œæ–‡æœ¬å®¹å™¨
  const htmlIconSpan = document.createElement('span');
  htmlIconSpan.className = 'option-icon';
  htmlIconSpan.textContent = 'ğŸŒ ';

  const htmlTextSpan = document.createElement('span');
  htmlTextSpan.className = 'option-text';
  htmlTextSpan.textContent = chrome.i18n.getMessage('exportAsHTML') || 'Export as HTML';

  htmlOption.appendChild(htmlIconSpan);
  htmlOption.appendChild(htmlTextSpan);

  htmlOption.addEventListener('click', (e) => {
    e.stopPropagation();
    exportChat('html');
    dropdownMenu.style.display = 'none';
  });

  // Add options to dropdown menu
  dropdownMenu.appendChild(jsonOption);
  dropdownMenu.appendChild(markdownOption);
  dropdownMenu.appendChild(textOption);
  dropdownMenu.appendChild(htmlOption);

  // Toggle dropdown menu when clicking the export button
  exportButton.addEventListener('click', (event) => {
    event.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
    const isVisible = dropdownMenu.style.display === 'block';
    dropdownMenu.style.display = isVisible ? 'none' : 'block';

    const arrowIcon = exportButton.querySelector('.arrow-icon');
    if (arrowIcon) {
      arrowIcon.style.transform = isVisible ? 'rotate(0deg)' : 'rotate(180deg)';
    }

  });

  // Prevent dropdown clicks from closing the dropdown
  dropdownMenu.addEventListener('click', (event) => {
    event.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
  });

  // Close dropdown when clicking outside
  document.addEventListener('click', () => {
    if (dropdownMenu.style.display === 'block') {
      dropdownMenu.style.display = 'none';

      // æ¢å¤ç®­å¤´å›¾æ ‡æ–¹å‘
      const arrowIcon = exportButton.querySelector('.arrow-icon');
      if (arrowIcon) {
        arrowIcon.style.transform = 'rotate(0deg)';
      }

    }
  });

  // Add button and dropdown to container
  container.appendChild(exportButton);
  container.appendChild(dropdownMenu);

  // Remove any existing containers with the same ID to avoid conflicts
  const existingContainer = document.getElementById('deepseek-export-container');
  if (existingContainer) {
    existingContainer.remove();
  }

  // Add container to page
  document.body.appendChild(container);

  // Add CSS styles for the dropdown
  addExportStyles();

}

/**
 * Add CSS styles for the export button and dropdown
 */
function addExportStyles() {
  // Check if styles already exist
  if (document.getElementById('deepseek-export-styles')) {
    return;
  }

  // Create a link element to load the external CSS file
  const link = document.createElement('link');
  link.id = 'deepseek-export-styles';
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = chrome.runtime.getURL('styles.css');

  // Add the link to the document head
  document.head.appendChild(link);

}

/**
 * Set up MutationObserver to watch for new messages
 */
function setupChatObserver(chatContainer) {
  if (!chatContainer) {
    console.warn('No chat container provided for observer');
    return;
  }

  // Create a debounced message processor using the utility function
  const debouncedProcessMessages = debounce(processExistingMessages, 500);

  // Set up the observer
  const observer = new MutationObserver((mutations) => {
    let shouldProcess = false;

    for (const mutation of mutations) {
      if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
        shouldProcess = true;
        break;
      }
    }

    if (shouldProcess) {
      debouncedProcessMessages();
    }
  });

  // Start observing
  observer.observe(chatContainer, {
    childList: true,
    subtree: true
  });

}

/**
 * Process all existing messages in the chat
 */
function processExistingMessages() {
  // Try multiple selectors to find messages
  let messages = [];

  // Try primary selector first
  messages = document.querySelectorAll(SELECTORS.MESSAGE_CONTAINER);

  // If no messages found, try fallback selectors
  if (messages.length === 0) {
    for (const selector of FALLBACK_SELECTORS.filter(s => s.includes('message') || s.includes('chat-item'))) {
      messages = document.querySelectorAll(selector);
      if (messages.length > 0) {
        SELECTORS.MESSAGE_CONTAINER = selector; // Update for future use
        break;
      }
    }
  }

  // Special handling for DeepSeek's structure
  if (messages.length === 0) {
    // Look for AI response footers and their parent containers
    const aiFooters = document.querySelectorAll('div.fcaa63f8');
    if (aiFooters.length > 0) {

      aiFooters.forEach(footer => {
        // For each footer, find the parent message container
        let parent = footer.parentElement;
        while (parent && !parent.classList.contains('message-item') && parent.tagName !== 'BODY') {
          parent = parent.parentElement;
        }

        if (parent && parent.tagName !== 'BODY') {
          messages = [...messages, parent];
        }

        // Also add the footer itself as it contains the AI response text
        if (footer.textContent.trim() !== 'AI-generated, for reference only' &&
            !footer.textContent.includes('å†…å®¹ç”± AI ç”Ÿæˆ')) {
          messages = [...messages, footer];
        }
      });
    }
  }

  // If still no messages, try a very broad selector
  if (messages.length === 0) {
    messages = document.querySelectorAll('div');
  }

  if (messages.length === 0) {
    console.warn('No messages found to process');
    return;
  }


  const messageData = [];

  messages.forEach((messageNode) => {
    // Skip if already processed
    if (processedMessages.has(messageNode)) {
      return;
    }

    const messageObj = extractMessageData(messageNode);
    if (messageObj) {
      messageData.push(messageObj);
      processedMessages.set(messageNode, true);
    }
  });

  if (messageData.length > 0) {
    saveMessages(messageData);
  }
}

/**
 * Clean up the content extracted from a message
 * @param {string} content - The raw content
 * @param {string} role - The role of the message (user or assistant)
 * @returns {string} The cleaned content
 */
function cleanMessageContent(content, role) {
  if (!content) return '';

  // ç§»é™¤å¸¸è§çš„AIç”Ÿæˆé¡µè„šæ–‡æœ¬ï¼ˆä½¿ç”¨æ›´é€šç”¨çš„æ¨¡å¼ï¼‰
  let cleaned = content;

  // ç§»é™¤ä¸­æ–‡AIç”Ÿæˆæç¤º
  cleaned = cleaned.replace(/å†…å®¹ç”±\s*AI\s*ç”Ÿæˆ[ï¼Œ,]?.*?(?=\n|$)/g, '');

  // ç§»é™¤è‹±æ–‡AIç”Ÿæˆæç¤º
  cleaned = cleaned.replace(/(?:Generated by AI|AI-generated).*?(?=\n|$)/g, '');

  // ç§»é™¤DeepSeekç‰¹å®šçš„AIç”Ÿæˆæç¤º
  cleaned = cleaned.replace(/AI-generated, for reference only/g, '');

  // ç§»é™¤å…¶ä»–å¯èƒ½çš„AIæç¤º
  cleaned = cleaned.replace(/AI.*?generated.*?(?=\n|$)/g, '');

  // ç§»é™¤"New chat"æŒ‰é’®æ–‡æœ¬
  cleaned = cleaned.replace(/New chat/g, '');

  // ç§»é™¤å¯èƒ½çš„æŒ‰é’®å’ŒUIå…ƒç´ æ–‡æœ¬
  cleaned = cleaned.replace(/DeepThink \(R1\)/g, '');
  cleaned = cleaned.replace(/Search/g, '');
  cleaned = cleaned.replace(/Message DeepSeek/g, '');

  // ç§»é™¤å¤åˆ¶æŒ‰é’®æ–‡æœ¬
  cleaned = cleaned.replace(/Copy code/g, '');
  cleaned = cleaned.replace(/å¤åˆ¶ä»£ç /g, '');

  // ç§»é™¤å¯èƒ½çš„é¡µè„šå…ƒç´ 
  cleaned = cleaned.replace(/fcaa63f8/g, '');

  // ç§»é™¤å¤šä½™ç©ºç™½å’Œæ¢è¡Œ
  cleaned = cleaned.replace(/\n\s*\n/g, '\n');
  cleaned = cleaned.trim();

  return cleaned;
}

/**
 * Extract data from a message node
 */
function extractMessageData(messageNode) {
  try {
    // è·³è¿‡éšè—æ¶ˆæ¯
    if (messageNode.offsetParent === null) {
      return null;
    }

    // ä½¿ç”¨åŸºäºè¯­ä¹‰çš„æ–¹æ³•ç¡®å®šè§’è‰²
    const role = determineRoleBySemantics(messageNode);

    // å­˜å‚¨è§’è‰²ä»¥ä¾›å°†æ¥å‚è€ƒ
    messageNode.dataset.role = role;

    // æå–å†…å®¹ - ä½¿ç”¨è¯­ä¹‰åˆ†æ
    let content = '';

    // 1. å°è¯•æ‰¾åˆ°æ˜æ˜¾çš„å†…å®¹èŠ‚ç‚¹
    const contentNode = findContentNode(messageNode);
    if (contentNode) {
      content = contentNode.innerText || contentNode.textContent;
    } else {
      // 2. å¦‚æœæ²¡æœ‰æ˜æ˜¾çš„å†…å®¹èŠ‚ç‚¹ï¼Œä½¿ç”¨æ¶ˆæ¯èŠ‚ç‚¹çš„æ–‡æœ¬
      content = messageNode.innerText || messageNode.textContent;

      // 3. ç§»é™¤å¯èƒ½çš„AIç”Ÿæˆæ ‡è®°
      content = removeAIFooters(messageNode, content);
    }

    // æ¸…ç†å†…å®¹
    content = cleanMessageContent(content, role);

    // Skip empty messages
    if (!content) {
      return null;
    }

    // Generate element ID for reference
    const elementId = `chat-item-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

    return {
      role,
      content,
      element_id: elementId,
      hash: createHash(content + Date.now())
    };
  } catch (error) {
    console.error('Error extracting message data:', error);
    return null;
  }
}

/**
 * Save messages to chrome.storage.local
 */
function saveMessages(messages) {
  // Throttle storage updates
  const now = Date.now();
  if (now - lastStorageUpdate < STORAGE_THROTTLE) {
    return;
  }
  lastStorageUpdate = now;

  chrome.storage.local.get(['chatData'], (result) => {
    const chatData = result.chatData || {};

    // Initialize session if needed
    if (!chatData[currentSessionId]) {
      chatData[currentSessionId] = {
        messages: [],
        hashes: [],
        meta: {
          start_time: new Date().toISOString(),
          page_url: window.location.href,
          last_updated: now
        }
      };
    }

    // Add new messages, avoiding duplicates
    let newMessagesAdded = false;
    messages.forEach((message) => {
      if (!chatData[currentSessionId].hashes.includes(message.hash)) {
        chatData[currentSessionId].messages.push(message);
        chatData[currentSessionId].hashes.push(message.hash);
        newMessagesAdded = true;
      }
    });

    if (newMessagesAdded) {
      chatData[currentSessionId].meta.last_updated = now;

      // Notify background script about new messages
      chrome.runtime.sendMessage({
        action: 'newMessagesDetected',
        count: messages.length
      }, (response) => {
        // Handle response if needed
        if (chrome.runtime.lastError) {
          // Ignore errors from message sending
        }
      });

      chrome.storage.local.set({ chatData }, () => {
        if (chrome.runtime.lastError) {
          console.error('Error saving chat data:', chrome.runtime.lastError);
          // Retry with exponential backoff could be implemented here
        } else {
        }
      });
    }
  });
}

/**
 * Export the chat to a file in the specified format
 * @param {string} format - The format to export ('json', 'markdown', or 'text')
 */
function exportChat(format = 'json') {
  try {

    // ç›´æ¥ä»é¡µé¢æå–æœ€æ–°æ¶ˆæ¯
    const latestMessages = extractAllMessagesFromPage();

    if (latestMessages.length > 0) {
    }

    if (latestMessages.length === 0) {
      alert(chrome.i18n.getMessage('noMessagesFound'));
      return;
    }

    // å‡†å¤‡å¯¼å‡ºæ•°æ®
    const exportData = {
      title: `DeepSeek Chat - ${new Date().toLocaleString()}`,
      url: window.location.href,
      date: new Date().toISOString(),
      messages: latestMessages
    };

    // ä½¿ç”¨å¯¼å‡ºå‡½æ•°ä¸‹è½½èŠå¤©æ•°æ®
    downloadChat(exportData, format);
  } catch (error) {
    console.error('Error during export:', error);
    alert(chrome.i18n.getMessage('exportError'));
  }
}

/**
 * Download chat data as a file in the specified format
 * @param {Object} exportData - The data to export
 * @param {string} format - The format to export ('json', 'markdown', 'text', or 'html')
 */
function downloadChat(exportData, format = 'json') {
  try {
    // ç¡®ä¿æœ‰æ¶ˆæ¯è¦å¯¼å‡º
    if (!exportData.messages || exportData.messages.length === 0) {
      alert(chrome.i18n.getMessage('noMessagesOnPage'));
      return;
    }


    // æ£€æŸ¥æ˜¯å¦æœ‰åŒ…å«chain_of_thoughtçš„æ¶ˆæ¯
    const hasCOT = exportData.messages.some(msg => msg.chain_of_thought);

    // æ ¼å¼åŒ–å¯¼å‡ºæ•°æ®ï¼Œç¡®ä¿åŒ…å«ç”¨æˆ·é—®é¢˜ã€AIå›ç­”å’Œæ€è€ƒè¿‡ç¨‹
    // æ³¨æ„ï¼šä¿æŒåŸå§‹æ¶ˆæ¯æ•°ç»„çš„é¡ºåºä¸å˜
    const formattedData = {
      title: exportData.title,
      url: exportData.url,
      date: exportData.date,
      messages: exportData.messages.map(msg => {
        const formattedMsg = {
          role: msg.role,
          content: msg.role === 'assistant' ? formatMessageContent(msg.content) : msg.content,
          format: msg.role === 'assistant' ? 'markdown' : 'text'
        };

        // å¦‚æœæœ‰æ€è€ƒè¿‡ç¨‹ï¼Œæ·»åŠ åˆ°å¯¼å‡ºæ¶ˆæ¯ä¸­
        if (msg.chain_of_thought) {
          formattedMsg.chain_of_thought = formatMessageContent(msg.chain_of_thought);
        }

        return formattedMsg;
      })
    };

    let blob, filename, contentType;

    // æ ¹æ®æ ¼å¼å¤„ç†å¯¼å‡º
    if (format === 'markdown') {
      const markdownContent = convertToMarkdown(formattedData);
      blob = new Blob([markdownContent], { type: 'text/markdown' });
      contentType = 'text/markdown';
      filename = `deepseek-chat-${new Date().toISOString().replace(/[:.]/g, '-')}.md`;
    } else if (format === 'text') {
      const textContent = convertToPlainText(formattedData);
      blob = new Blob([textContent], { type: 'text/plain' });
      contentType = 'text/plain';
      filename = `deepseek-chat-${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
    } else if (format === 'html') {
      const htmlContent = convertToHTML(formattedData);
      blob = new Blob([htmlContent], { type: 'text/html' });
      contentType = 'text/html';
      filename = `deepseek-chat-${new Date().toISOString().replace(/[:.]/g, '-')}.html`;
    } else {
      // å¯¹äº JSON æ ¼å¼ï¼Œç›´æ¥ä½¿ç”¨æ ¼å¼åŒ–åçš„æ•°æ®
      blob = new Blob([JSON.stringify(formattedData, null, 2)], { type: 'application/json' });
      contentType = 'application/json';
      filename = `deepseek-chat-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
    }

    // åˆ›å»ºå¹¶ä¸‹è½½æ–‡ä»¶
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();

    // æ¸…ç†
    setTimeout(() => URL.revokeObjectURL(url), 50);

    // æ·»åŠ è§†è§‰åé¦ˆ
    const exportButton = document.getElementById('deepseek-export-btn');
    if (exportButton) {
      exportButton.classList.add('pulse');
      setTimeout(() => exportButton.classList.remove('pulse'), 300);
    }

  } catch (error) {
    console.error('Error exporting chat:', error);
    alert(chrome.i18n.getMessage('exportFailed'));
  }
}

/**
 * Convert chat data to Markdown format
 * @param {Object} data - The chat data to convert
 * @returns {string} - The Markdown content
 */
function convertToMarkdown(data) {

  // Create the header with metadata
  let markdown = `# ${data.title}\n\n`;
  markdown += `- **URL**: ${data.url}\n`;
  markdown += `- **Date**: ${new Date(data.date).toLocaleString()}\n\n`;
  markdown += `---\n\n`;

  // Process each message
  data.messages.forEach((msg, index) => {
    // Format the role header
    const roleIcon = msg.role === 'user' ? 'ğŸ§‘' : 'ğŸ¤–';
    const roleName = msg.role === 'user' ? 'User' : 'DeepSeek AI';
    markdown += `## ${roleIcon} ${roleName}\n\n`;

    // Process the content with special handling for code blocks
    const formattedContent = formatMessageContent(msg.content);
    markdown += `${formattedContent}\n\n`;

    // Add chain of thought if available
    if (msg.chain_of_thought) {
      markdown += `<details>\n<summary>Chain of Thought</summary>\n\n`;
      const formattedCOT = formatMessageContent(msg.chain_of_thought);
      markdown += `${formattedCOT}\n\n`;
      markdown += `</details>\n\n`;
    }

    // Add separator between messages
    if (index < data.messages.length - 1) {
      markdown += `---\n\n`;
    }
  });

  return markdown;
}

/**
 * Format message content for Markdown, with special handling for code blocks
 * @param {string} content - The message content to format
 * @returns {string} - The formatted content
 */
function formatMessageContent(content) {
  if (!content) return '';

  // Replace HTML tags with their Markdown equivalents
  let formatted = content
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<p>(.*?)<\/p>/gi, '$1\n\n')
    .replace(/<strong>(.*?)<\/strong>/gi, '**$1**')
    .replace(/<em>(.*?)<\/em>/gi, '*$1*')
    .replace(/<h1>(.*?)<\/h1>/gi, '# $1\n')
    .replace(/<h2>(.*?)<\/h2>/gi, '## $1\n')
    .replace(/<h3>(.*?)<\/h3>/gi, '### $1\n')
    .replace(/<h4>(.*?)<\/h4>/gi, '#### $1\n')
    .replace(/<h5>(.*?)<\/h5>/gi, '##### $1\n')
    .replace(/<h6>(.*?)<\/h6>/gi, '###### $1\n');

  // Create a temporary DOM element to parse the HTML
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = formatted;

  // Process code blocks
  const processCodeBlock = (element, language = '') => {
    // Get the raw HTML content
    const rawHtml = element.innerHTML;

    // Replace HTML entities and tags
    let codeContent = rawHtml
      .replace(/<button.*?<\/button>/gi, '')
      .replace(/<div class="ds-code-header".*?<\/div>/gi, '')
      .replace(/<div class="ds-code-content".*?>([\s\S]*?)<\/div>/gi, '$1');

    // Decode HTML entities
    codeContent = codeContent
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&amp;/g, '&')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/&nbsp;/g, ' ');

    // Remove any remaining HTML tags
    codeContent = codeContent.replace(/<[^>]*>/g, '');

    // Preserve line breaks
    codeContent = codeContent.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

    // Return formatted code block
    return `\`\`\`${language}\n${codeContent.trim()}\n\`\`\`\n`;
  };

  // Process lists (both ordered and unordered)
  const processList = (listElement, isOrdered = false) => {
    let markdown = '';
    let index = 1;

    // Process each list item
    Array.from(listElement.children).forEach(item => {
      if (item.tagName.toLowerCase() === 'li') {
        const prefix = isOrdered ? `${index++}. ` : '- ';
        let content = item.innerHTML;

        // Check for nested lists
        const nestedLists = [];
        item.querySelectorAll('ul, ol').forEach(nestedList => {
          const placeholder = `__LIST_${nestedLists.length}__`;
          nestedLists.push({
            placeholder,
            content: processList(nestedList, nestedList.tagName.toLowerCase() === 'ol')
          });
          content = content.replace(nestedList.outerHTML, placeholder);
        });

        // Process the content without the nested lists
        content = content
          .replace(/<br\s*\/?>/gi, '\n')
          .replace(/<p>(.*?)<\/p>/gi, '$1\n')
          .replace(/<strong>(.*?)<\/strong>/gi, '**$1**')
          .replace(/<em>(.*?)<\/em>/gi, '*$1*')
          .replace(/<code>(.*?)<\/code>/gi, '`$1`');

        // Remove any remaining HTML tags
        content = content.replace(/<[^>]*>/g, '');

        // Replace placeholders with the processed nested lists
        nestedLists.forEach(nestedList => {
          const indentedContent = nestedList.content
            .split('\n')
            .map(line => '  ' + line)
            .join('\n');
          content = content.replace(nestedList.placeholder, '\n' + indentedContent);
        });

        markdown += prefix + content.trim() + '\n';
      }
    });

    return markdown;
  };

  // Find and process all code blocks
  const codeBlocks = [];

  // Handle fenced code blocks with language specification
  tempDiv.querySelectorAll('pre code[class*="language-"]').forEach(codeElement => {
    const language = Array.from(codeElement.classList)
      .find(cls => cls.startsWith('language-'))
      ?.replace('language-', '') || '';

    const placeholder = `__CODE_BLOCK_${codeBlocks.length}__`;
    codeBlocks.push(processCodeBlock(codeElement, language));
    codeElement.parentElement.outerHTML = placeholder;
  });

  // Handle DeepSeek specific code blocks
  tempDiv.querySelectorAll('.ds-code-block, .code-block').forEach(blockElement => {
    const language = blockElement.getAttribute('data-language') || '';
    const placeholder = `__CODE_BLOCK_${codeBlocks.length}__`;
    codeBlocks.push(processCodeBlock(blockElement, language));
    blockElement.outerHTML = placeholder;
  });

  // Process md-code-block specifically
  const processMdCodeBlock = (blockElement) => {
    // å°è¯•æå–è¯­è¨€ä¿¡æ¯
    let language = '';
    const infoStringElement = blockElement.querySelector('.md-code-block-infostring');
    if (infoStringElement) {
      language = infoStringElement.textContent.trim();

      // å¦‚æœè¯­è¨€ä¿¡æ¯æ˜¯markdownï¼Œæˆ‘ä»¬éœ€è¦ç‰¹æ®Šå¤„ç†
      if (language.toLowerCase() === 'markdown' || language.toLowerCase() === 'md') {
        // æ ‡è®°ä¸ºmarkdownä»£ç å—ï¼Œè€Œä¸æ˜¯è§£é‡Šä¸ºmarkdown
        language = 'markdown';
      }
    }

    // æŸ¥æ‰¾ä»£ç å†…å®¹
    let codeContent = '';

    // é¦–å…ˆå°è¯•æŸ¥æ‰¾preæ ‡ç­¾ - å¯¹äºmdä»£ç å—ï¼Œæˆ‘ä»¬åº”è¯¥åªå…³æ³¨preä¸­çš„å†…å®¹
    const preElements = blockElement.querySelectorAll('pre');
    if (preElements && preElements.length > 0) {
      // å¦‚æœæœ‰å¤šä¸ªpreæ ‡ç­¾ï¼Œå°†å®ƒä»¬åˆå¹¶ä¸ºä¸€ä¸ªä»£ç å—
      const preContents = [];
      preElements.forEach(preElement => {
        // è·å–preå…ƒç´ çš„åŸå§‹HTMLå†…å®¹
        let preContent = preElement.innerHTML || '';

        // é€’å½’å¤„ç†åµŒå¥—çš„token spans
        // è¿™ä¸ªå‡½æ•°ä¼šå¤„ç†åµŒå¥—çš„token spanå…ƒç´ ï¼Œä¿ç•™å…¶ä¸­çš„æ–‡æœ¬å†…å®¹
        const processNestedTokens = (html) => {
          // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…æœ€å†…å±‚çš„token spans (æ²¡æœ‰åµŒå¥—å…¶ä»–spansçš„spans)
          const innerTokenRegex = /<span class="token [^"]*">([^<]*)<\/span>/g;
          let result = html;

          // å¦‚æœæ‰¾åˆ°äº†åŒ¹é…é¡¹ï¼Œæ›¿æ¢å®ƒä»¬
          if (innerTokenRegex.test(html)) {
            result = html.replace(innerTokenRegex, '$1');
            // é€’å½’å¤„ç†ï¼Œç›´åˆ°æ²¡æœ‰æ›´å¤šçš„å†…å±‚token spans
            return processNestedTokens(result);
          }

          return result;
        };

        // å¤„ç†åµŒå¥—çš„token spans
        preContent = processNestedTokens(preContent);

        // ç§»é™¤æ‰€æœ‰å‰©ä½™çš„HTMLæ ‡ç­¾ï¼Œä½†ä¿ç•™å†…å®¹
        preContent = preContent.replace(/<[^>]*>/g, '');

        // æ¸…ç†HTMLå®ä½“
        preContent = preContent.trim()
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&amp;/g, '&')
          .replace(/&quot;/g, '"')
          .replace(/&#39;/g, "'")
          .replace(/&nbsp;/g, ' ');

        preContents.push(preContent);
      });
      codeContent = preContents.join('\n\n');
    } else {
      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°preæ ‡ç­¾ï¼Œå°è¯•è·å–æ•´ä¸ªå…ƒç´ çš„æ–‡æœ¬å†…å®¹
      codeContent = blockElement.textContent || '';

      // ç§»é™¤å¯èƒ½å­˜åœ¨çš„è¯­è¨€ä¿¡æ¯å’Œå¤åˆ¶æŒ‰é’®æ–‡æœ¬
      if (infoStringElement) {
        codeContent = codeContent.replace(infoStringElement.textContent, '');
      }

      // ç§»é™¤"å¤åˆ¶"æŒ‰é’®æ–‡æœ¬
      const copyButton = blockElement.querySelector('.ds-markdown-code-copy-button');
      if (copyButton) {
        codeContent = codeContent.replace(copyButton.textContent, '');
      }

      // ç§»é™¤footerä¸­çš„"è¿è¡Œ"æ–‡æœ¬
      const footer = blockElement.querySelector('.md-code-block-footer');
      if (footer) {
        codeContent = codeContent.replace(footer.textContent, '');
      }
    }

    // æ¸…ç†ä»£ç å†…å®¹
    codeContent = codeContent.trim()
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&amp;/g, '&')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/&nbsp;/g, ' ');

    // ä¿ç•™æ¢è¡Œï¼Œå¹¶å¤„ç†ç¼©è¿›
    codeContent = codeContent.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

    // å¤„ç†å¤šä½™çš„ç¼©è¿› - ç‰¹åˆ«æ˜¯åœ¨DeepSeekä»£ç å—ä¸­å¸¸è§çš„æƒ…å†µ
    const contentLines = codeContent.split('\n');
    // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰éç©ºè¡Œéƒ½æœ‰ç›¸åŒçš„å‰å¯¼ç©ºæ ¼
    const nonEmptyLines = contentLines.filter(line => line.trim().length > 0);
    if (nonEmptyLines.length > 0) {
      // æ‰¾å‡ºå…±åŒçš„ç¼©è¿›
      const commonIndent = nonEmptyLines.reduce((indent, line) => {
        const lineIndent = line.match(/^\s*/)[0].length;
        return Math.min(indent, lineIndent);
      }, Infinity);

      // å¦‚æœæœ‰å…±åŒçš„ç¼©è¿›ï¼Œç§»é™¤å®ƒ
      if (commonIndent > 0 && commonIndent !== Infinity) {
        codeContent = contentLines.map(line =>
          line.length >= commonIndent ? line.substring(commonIndent) : line
        ).join('\n');
      }
    }

    // æ£€æŸ¥æ˜¯å¦æ˜¯AIç”Ÿæˆçš„markdownå†…å®¹
    // å¦‚æœå†…å®¹åŒ…å«markdownè¯­æ³•ä½†ä¸åœ¨ä»£ç å—ä¸­ï¼Œæˆ‘ä»¬åº”è¯¥å°†æ•´ä¸ªå†…å®¹è§†ä¸ºä»£ç å—
    const containsMarkdownSyntax = (
      /^#+ .+$/m.test(codeContent) || // æ ‡é¢˜
      /^\* .+$/m.test(codeContent) || // æ— åºåˆ—è¡¨
      /^- .+$/m.test(codeContent) || // æ— åºåˆ—è¡¨
      /^\d+\. .+$/m.test(codeContent) || // æœ‰åºåˆ—è¡¨
      /^\> .+$/m.test(codeContent) || // å¼•ç”¨
      /\[.+\]\(.+\)/.test(codeContent) || // é“¾æ¥
      /!\[.+\]\(.+\)/.test(codeContent) || // å›¾ç‰‡
      /\*\*.+\*\*/.test(codeContent) || // ç²—ä½“
      /\*.+\*/.test(codeContent) || // æ–œä½“
      /^---+$/m.test(codeContent) || // åˆ†éš”çº¿
      /^\|.+\|.+\|$/m.test(codeContent) // è¡¨æ ¼
    );

    // å¦‚æœå†…å®¹åŒ…å«markdownè¯­æ³•ï¼Œå¹¶ä¸”æ²¡æœ‰æŒ‡å®šè¯­è¨€æˆ–è¯­è¨€ä¸æ˜¯markdownï¼Œ
    // åˆ™å°†è¯­è¨€è®¾ç½®ä¸ºmarkdownï¼Œä»¥ç¡®ä¿å®ƒè¢«è§†ä¸ºä»£ç å—è€Œä¸æ˜¯è§£é‡Šä¸ºmarkdown
    if (containsMarkdownSyntax && (!language || language.toLowerCase() !== 'markdown')) {
      language = 'markdown';
    }

    // æ£€æŸ¥ä»£ç å†…å®¹æ˜¯å¦å·²ç»åŒ…å«ç»“æŸæ ‡è®° ```
    const hasClosingBackticks = /```\s*$/m.test(codeContent);

    // å¦‚æœå·²ç»æœ‰ç»“æŸæ ‡è®°ï¼Œç§»é™¤å®ƒï¼Œæˆ‘ä»¬ä¼šåœ¨è¿”å›æ—¶æ·»åŠ ç»Ÿä¸€çš„ç»“æŸæ ‡è®°
    if (hasClosingBackticks) {
      codeContent = codeContent.replace(/```\s*$/m, '');
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰å¤šä½™çš„å¼€å§‹æ ‡è®°
    const extraStartingBackticks = codeContent.match(/^```(?:([a-zA-Z0-9_+-]+))?/m);
    if (extraStartingBackticks) {
      // å¦‚æœæ‰¾åˆ°äº†å¼€å§‹æ ‡è®°ï¼Œæå–è¯­è¨€ï¼ˆå¦‚æœæœ‰ï¼‰å¹¶ç§»é™¤å¼€å§‹æ ‡è®°
      if (extraStartingBackticks[1] && !language) {
        language = extraStartingBackticks[1].trim();
      }
      codeContent = codeContent.replace(/^```(?:[a-zA-Z0-9_+-]+)?\n?/m, '');
    }

    // ç¡®ä¿ä»£ç å†…å®¹ä¸ä»¥ ``` å¼€å¤´ï¼Œè¿™å¯èƒ½æ˜¯é”™è¯¯æå–çš„è¯­è¨€æ ‡è®°
    if (codeContent.startsWith('```')) {
      const codeLines = codeContent.split('\n');
      // å¦‚æœç¬¬ä¸€è¡Œåªæœ‰ ```ï¼Œç§»é™¤å®ƒ
      if (codeLines[0].trim() === '```') {
        codeLines.shift();
        codeContent = codeLines.join('\n');
      }
      // å¦‚æœç¬¬ä¸€è¡Œæ˜¯ ```languageï¼Œæå–è¯­è¨€å¹¶ç§»é™¤è¯¥è¡Œ
      else if (codeLines[0].trim().startsWith('```') && codeLines[0].trim().length > 3) {
        const firstLineLang = codeLines[0].trim().substring(3).trim();
        if (!language && firstLineLang) {
          language = firstLineLang;
        }
        codeLines.shift();
        codeContent = codeLines.join('\n');
      }
    }

    // æ£€æŸ¥ä»£ç å†…å®¹ä¸­æ˜¯å¦æœ‰å¯èƒ½è¢«é”™è¯¯åŒ…å«çš„markdownå…ƒç´ 
    // è¿™äº›å…ƒç´ å¯èƒ½è¡¨æ˜ä»£ç å—åº”è¯¥åœ¨æ­¤å¤„ç»“æŸ
    const lines = codeContent.split('\n');
    let cleanedLines = [];
    let shouldTerminate = false;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // æ£€æŸ¥è¿™ä¸€è¡Œæ˜¯å¦çœ‹èµ·æ¥åƒæ˜¯markdownçš„å¼€å§‹
      if (
        line.startsWith('# ') ||
        line.startsWith('## ') ||
        line.startsWith('### ') ||
        line.startsWith('- ') ||
        line.startsWith('* ') ||
        line.startsWith('1. ') ||
        line.startsWith('> ') ||
        line.match(/^\|.*\|$/) || // è¡¨æ ¼è¡Œ
        line.match(/^[A-Za-z0-9_-]+:/) // å¯èƒ½æ˜¯YAMLå‰ç½®å…ƒæ•°æ®
      ) {
        // å¦‚æœè¯­è¨€æ˜¯markdownï¼Œæˆ‘ä»¬ä¸åº”è¯¥ç»ˆæ­¢ä»£ç å—ï¼Œå› ä¸ºè¿™äº›æ˜¯markdownè¯­æ³•çš„ä¸€éƒ¨åˆ†
        if (language.toLowerCase() !== 'markdown') {
          // å¦‚æœè¿™ä¸€è¡Œçœ‹èµ·æ¥åƒæ˜¯markdownçš„å¼€å§‹ï¼Œæˆ‘ä»¬åº”è¯¥åœ¨è¿™é‡Œç»ˆæ­¢ä»£ç å—
          shouldTerminate = true;
          break;
        }
      }

      cleanedLines.push(lines[i]);
    }

    // å¦‚æœæˆ‘ä»¬æ£€æµ‹åˆ°åº”è¯¥ç»ˆæ­¢ä»£ç å—ï¼Œä½¿ç”¨æ¸…ç†åçš„è¡Œ
    if (shouldTerminate && cleanedLines.length > 0) {
      codeContent = cleanedLines.join('\n');
    }

    // æ£€æŸ¥å†…éƒ¨åµŒå¥—çš„ä»£ç å—
    const nestedCodeBlockStart = codeContent.match(/```([a-zA-Z0-9_+-]*)[\s\n]/);
    if (nestedCodeBlockStart) {
      // æ£€æŸ¥æ˜¯å¦æœ‰å¯¹åº”çš„ç»“æŸæ ‡è®°
      const nestedCodeBlockEnd = codeContent.indexOf("```", nestedCodeBlockStart.index + nestedCodeBlockStart[0].length);

      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ç»“æŸæ ‡è®°ï¼Œæˆ–è€…ç»“æŸæ ‡è®°åœ¨æœ€åä¸€è¡Œï¼Œæˆ‘ä»¬éœ€è¦æ·»åŠ ä¸€ä¸ª
      if (nestedCodeBlockEnd === -1) {
        // æ·»åŠ ç»“æŸæ ‡è®°åˆ°å†…å®¹çš„æœ«å°¾
        codeContent = codeContent.trim() + "\n```";
      }
    }

    // ç¡®ä¿ä»£ç å—ä»¥ ``` ç»“å°¾
    return `\`\`\`${language}\n${codeContent.trim()}\n\`\`\`\n`;
  };

  // Handle md-code-block class (DeepSeek specific)
  tempDiv.querySelectorAll('.md-code-block').forEach(blockElement => {
    const placeholder = `__CODE_BLOCK_${codeBlocks.length}__`;
    codeBlocks.push(processMdCodeBlock(blockElement));
    blockElement.outerHTML = placeholder;
  });

  // Handle regular code blocks
  tempDiv.querySelectorAll('pre code').forEach(codeElement => {
    const placeholder = `__CODE_BLOCK_${codeBlocks.length}__`;
    codeBlocks.push(processCodeBlock(codeElement));
    codeElement.parentElement.outerHTML = placeholder;
  });

  // Find and process all lists
  const lists = [];

  // Process ordered lists
  tempDiv.querySelectorAll('ol').forEach(listElement => {
    // Skip nested lists as they will be processed with their parent
    if (!listElement.closest('li')) {
      const placeholder = `__LIST_BLOCK_${lists.length}__`;
      lists.push(processList(listElement, true));
      listElement.outerHTML = placeholder;
    }
  });

  // Process unordered lists
  tempDiv.querySelectorAll('ul').forEach(listElement => {
    // Skip nested lists as they will be processed with their parent
    if (!listElement.closest('li')) {
      const placeholder = `__LIST_BLOCK_${lists.length}__`;
      lists.push(processList(listElement, false));
      listElement.outerHTML = placeholder;
    }
  });

  // Get the processed content
  formatted = tempDiv.innerHTML;

  // Replace code block placeholders with actual code blocks
  codeBlocks.forEach((codeBlock, index) => {
    formatted = formatted.replace(`__CODE_BLOCK_${index}__`, codeBlock);
  });

  // Replace list placeholders with actual lists
  lists.forEach((list, index) => {
    formatted = formatted.replace(`__LIST_BLOCK_${index}__`, list);
  });

  // Handle inline code
  formatted = formatted.replace(/<code>(.*?)<\/code>/gi, '`$1`');
  formatted = formatted.replace(/<span class="[^"]*code[^"]*">(.*?)<\/span>/gi, '`$1`');

  // Handle links
  formatted = formatted.replace(/<a href="(.*?)".*?>(.*?)<\/a>/gi, '[$2]($1)');

  // Handle images
  formatted = formatted.replace(/<img src="(.*?)".*?>/gi, '![]($1)');

  // Handle blockquotes
  formatted = formatted.replace(/<blockquote>([\s\S]*?)<\/blockquote>/gi, (match, quote) => {
    return quote.split('\n').map(line => `> ${line}`).join('\n');
  });

  // Handle tables (simplified)
  formatted = formatted.replace(/<table>([\s\S]*?)<\/table>/gi, (match, tableContent) => {
    let mdTable = '';

    // Extract header
    const headerMatch = tableContent.match(/<thead>([\s\S]*?)<\/thead>/i);
    if (headerMatch) {
      const headerCells = headerMatch[1].match(/<th>(.*?)<\/th>/gi);
      if (headerCells) {
        mdTable += '| ' + headerCells.map(cell => cell.replace(/<\/?th>/gi, '').trim()).join(' | ') + ' |\n';
        mdTable += '| ' + headerCells.map(() => '---').join(' | ') + ' |\n';
      }
    }

    // Extract body
    const bodyMatch = tableContent.match(/<tbody>([\s\S]*?)<\/tbody>/i);
    if (bodyMatch) {
      const rows = bodyMatch[1].match(/<tr>([\s\S]*?)<\/tr>/gi);
      if (rows) {
        rows.forEach(row => {
          const cells = row.match(/<td>(.*?)<\/td>/gi);
          if (cells) {
            mdTable += '| ' + cells.map(cell => cell.replace(/<\/?td>/gi, '').trim()).join(' | ') + ' |\n';
          }
        });
      }
    }

    return mdTable;
  });

  // Handle DeepSeek specific markdown blocks
  formatted = formatted.replace(/<div class="ds-markdown.*?">([\s\S]*?)<\/div>/gi, '$1');
  formatted = formatted.replace(/<div class="ds-markdown--block.*?">([\s\S]*?)<\/div>/gi, '$1');

  // Remove any remaining HTML tags
  formatted = formatted.replace(/<[^>]*>/g, '');

  // Decode HTML entities
  formatted = formatted
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&nbsp;/g, ' ');

  // éªŒè¯å¹¶ä¿®å¤ä»£ç å—çš„ç»“æŸæ ‡è®°
  formatted = validateCodeBlocks(formatted);

  return formatted;
}

/**
 * éªŒè¯å¹¶ä¿®å¤ Markdown ä¸­çš„ä»£ç å—ï¼Œç¡®ä¿æ‰€æœ‰ä»£ç å—éƒ½æœ‰æ­£ç¡®çš„å¼€å§‹å’Œç»“æŸæ ‡è®°
 * @param {string} markdown - Markdown æ–‡æœ¬
 * @returns {string} - ä¿®å¤åçš„ Markdown æ–‡æœ¬
 */
function validateCodeBlocks(markdown) {
  if (!markdown) return '';

  // é¦–å…ˆå¤„ç†å·²ç»å­˜åœ¨çš„ä»£ç å—ï¼Œç¡®ä¿å®ƒä»¬æœ‰æ­£ç¡®çš„ç»“æŸæ ‡è®°
  let processedMarkdown = markdown;

  // æŸ¥æ‰¾æ‰€æœ‰ä»¥ ``` å¼€å§‹ä½†æ²¡æœ‰ä»¥ ``` ç»“æŸçš„ä»£ç å—
  const codeBlockRegex = /```([^\n]*)\n([\s\S]*?)(?:```|$)/g;
  processedMarkdown = processedMarkdown.replace(codeBlockRegex, (match, language, code) => {
    // å¦‚æœä»£ç å—å·²ç»æœ‰ç»“æŸæ ‡è®°ï¼Œä¿æŒä¸å˜
    if (match.endsWith('```')) {
      return match;
    }
    // å¦åˆ™æ·»åŠ ç»“æŸæ ‡è®°
    return `\`\`\`${language}\n${code}\n\`\`\``;
  });

  // å†æ¬¡æ£€æŸ¥ï¼Œç¡®ä¿æ‰€æœ‰ä»£ç å—éƒ½æœ‰æ­£ç¡®çš„å¼€å§‹å’Œç»“æŸæ ‡è®°
  const lines = processedMarkdown.split('\n');
  const result = [];
  let inCodeBlock = false;
  let codeBlockStartIndex = -1;
  let codeBlockLanguage = '';
  let codeBlockContent = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmedLine = line.trim();

    // æ£€æµ‹ä»£ç å—å¼€å§‹
    if (!inCodeBlock && trimmedLine.startsWith('```')) {
      inCodeBlock = true;
      codeBlockStartIndex = i;
      // æå–è¯­è¨€ä¿¡æ¯
      codeBlockLanguage = trimmedLine.substring(3).trim();
      result.push(line);
      codeBlockContent = [];
    }
    // æ£€æµ‹ä»£ç å—ç»“æŸ
    else if (inCodeBlock && trimmedLine === '```') {
      inCodeBlock = false;
      codeBlockStartIndex = -1;
      codeBlockLanguage = '';
      codeBlockContent = [];
      result.push(line);
    }
    // æ™®é€šè¡Œ
    else {
      if (inCodeBlock) {
        codeBlockContent.push(line);
      }
      result.push(line);
    }

    // ç‰¹æ®Šæƒ…å†µï¼šå¦‚æœæˆ‘ä»¬åœ¨ä»£ç å—å†…ï¼Œä½†ä¸‹ä¸€è¡Œçœ‹èµ·æ¥åƒæ˜¯æ–°å†…å®¹çš„å¼€å§‹ï¼ˆä¾‹å¦‚æ ‡é¢˜ã€åˆ—è¡¨é¡¹ç­‰ï¼‰ï¼Œ
    // è¿™å¯èƒ½æ„å‘³ç€ä»£ç å—æ²¡æœ‰æ­£ç¡®ç»“æŸ
    if (inCodeBlock && i < lines.length - 1) {
      const nextLine = lines[i + 1].trim();
      // æ£€æŸ¥ä¸‹ä¸€è¡Œæ˜¯å¦çœ‹èµ·æ¥åƒæ˜¯æ–°å†…å®¹çš„å¼€å§‹
      if (
        nextLine.startsWith('# ') ||
        nextLine.startsWith('## ') ||
        nextLine.startsWith('### ') ||
        nextLine.startsWith('- ') ||
        nextLine.startsWith('* ') ||
        nextLine.startsWith('1. ') ||
        nextLine.startsWith('> ') ||
        nextLine.match(/^[A-Za-z0-9_-]+:/) // å¯èƒ½æ˜¯YAMLå‰ç½®å…ƒæ•°æ®
      ) {
        // åœ¨å½“å‰è¡Œåæ·»åŠ ä»£ç å—ç»“æŸæ ‡è®°
        result.push('```');
        inCodeBlock = false;
        codeBlockStartIndex = -1;
        codeBlockLanguage = '';
        codeBlockContent = [];
      }
    }
  }

  // å¦‚æœåˆ°æ–‡æ¡£æœ«å°¾è¿˜åœ¨ä»£ç å—ä¸­ï¼Œæ·»åŠ ç»“æŸæ ‡è®°
  if (inCodeBlock) {
    result.push('```');
  }

  return result.join('\n');
}

/**
 * Convert chat data to plain text format
 * @param {Object} data - The chat data to convert
 * @returns {string} - The plain text content
 */
function convertToPlainText(data) {
  // Create the header with metadata
  let text = `${data.title}\n\n`;
  text += `URL: ${data.url}\n`;
  text += `Date: ${new Date(data.date).toLocaleString()}\n\n`;
  text += `----------------------------------------\n\n`;

  // Process each message
  data.messages.forEach((msg, index) => {
    // Format the role header
    const roleName = msg.role === 'user' ? 'User' : 'DeepSeek AI';
    text += `${roleName}:\n\n`;

    // Add the content, stripping HTML and preserving code blocks
    const plainContent = msg.content
      .replace(/<br\s*\/?>/gi, '\n')  // Replace <br> with newlines
      .replace(/<\/p>/gi, '\n\n')     // Replace </p> with double newlines
      .replace(/<[^>]*>/g, '')        // Remove all other HTML tags
      .replace(/&nbsp;/g, ' ')        // Replace &nbsp; with spaces
      .replace(/&lt;/g, '<')          // Replace &lt; with <
      .replace(/&gt;/g, '>')          // Replace &gt; with >
      .replace(/&amp;/g, '&')         // Replace &amp; with &
      .replace(/&quot;/g, '"')        // Replace &quot; with "
      .replace(/&apos;/g, "'")        // Replace &apos; with '
      .trim();                        // Trim whitespace

    text += `${plainContent}\n\n`;

    // Add chain of thought if available
    if (msg.chain_of_thought) {
      text += `Thinking process:\n\n`;
      const plainCOT = msg.chain_of_thought
        .replace(/<br\s*\/?>/gi, '\n')
        .replace(/<\/p>/gi, '\n\n')
        .replace(/<[^>]*>/g, '')
        .replace(/&nbsp;/g, ' ')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&')
        .replace(/&quot;/g, '"')
        .replace(/&apos;/g, "'")
        .trim();
      text += `${plainCOT}\n\n`;
    }

    // Add separator between messages
    if (index < data.messages.length - 1) {
      text += `----------------------------------------\n\n`;
    }
  });

  return text;
}

/**
 * ä»é¡µé¢ä¸­æå–æ‰€æœ‰æ¶ˆæ¯
 * @returns {Array} æ¶ˆæ¯æ•°ç»„
 */
function extractAllMessagesFromPage() {

  try {
    // 1. æŸ¥æ‰¾ç”¨æˆ·é—®é¢˜ (ä½¿ç”¨ .fbb737a4 ç±»)
    const userQuestions = document.querySelectorAll('.fbb737a4');

    // 2. æŸ¥æ‰¾AIå›ç­” (ä½¿ç”¨ .ds-markdown å’Œ .ds-markdown--block ç±»)
    const aiResponses = document.querySelectorAll('.ds-markdown, .ds-markdown--block');

    // 3. æŸ¥æ‰¾æ€è€ƒè¿‡ç¨‹å®¹å™¨ (ä½¿ç”¨ .e1675d8b ç±»)
    const cotContainers = document.querySelectorAll('.e1675d8b');

    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•æ¶ˆæ¯ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ³•
    if (userQuestions.length === 0 && aiResponses.length === 0 && cotContainers.length === 0) {
      return findMessagesByPattern();
    }

    // åˆ›å»ºä¸€ä¸ªæ•°ç»„æ¥å­˜å‚¨æ‰€æœ‰æ¶ˆæ¯å…ƒç´ åŠå…¶ç±»å‹å’Œä½ç½®
    const allElements = [];

    // æ·»åŠ ç”¨æˆ·é—®é¢˜
    userQuestions.forEach(el => {
      allElements.push({
        element: el,
        type: 'user',
        position: getElementPosition(el)
      });
    });

    // æ·»åŠ AIå›ç­”
    aiResponses.forEach(el => {
      allElements.push({
        element: el,
        type: 'ai',
        position: getElementPosition(el)
      });
    });

    // æ·»åŠ æ€è€ƒè¿‡ç¨‹å®¹å™¨
    cotContainers.forEach(el => {
      allElements.push({
        element: el,
        type: 'cot_container',
        position: getElementPosition(el)
      });
    });

    // æŒ‰ç…§å…ƒç´ åœ¨DOMä¸­çš„ä½ç½®æ’åº
    allElements.sort((a, b) => {
      return a.position - b.position;
    });


    // å¤„ç†æ’åºåçš„å…ƒç´ 
    const messages = [];
    let lastAiMessageIndex = -1;
    let pendingCOT = null; // å­˜å‚¨ç­‰å¾…å…³è”çš„COTå†…å®¹
    let currentUserQuestion = null;

    allElements.forEach((item, index) => {
      const { element, type } = item;
      const content = extractMessageContent(element);

      if (!content) return;

      if (type === 'user') {
        // å¤„ç†ç”¨æˆ·é—®é¢˜
        currentUserQuestion = {
          role: 'user',
          content: cleanMessageContent(content, 'user'),
          element_id: element.id || `user-${index}-${Date.now()}`
        };

        messages.push(currentUserQuestion);
        lastAiMessageIndex = -1; // é‡ç½®æœ€åä¸€ä¸ªAIæ¶ˆæ¯çš„ç´¢å¼•
      }
      else if (type === 'ai') {
        // å¤„ç†AIå›ç­”
        const aiMessage = {
          role: 'assistant',
          content: cleanMessageContent(content, 'assistant'),
          element_id: element.id || `ai-${index}-${Date.now()}`
        };

        // å¦‚æœæœ‰å¾…å¤„ç†çš„COTï¼Œå°†å…¶æ·»åŠ åˆ°è¿™ä¸ªAIæ¶ˆæ¯ä¸­
        if (pendingCOT) {
          aiMessage.chain_of_thought = pendingCOT;
          pendingCOT = null; // æ¸…é™¤å¾…å¤„ç†çš„COT
        }

        messages.push(aiMessage);
        lastAiMessageIndex = messages.length - 1;
      }
      else if (type === 'cot_container') {
        // å¤„ç†æ€è€ƒè¿‡ç¨‹å®¹å™¨
        const cotContent = extractCOTFromContainer(element);

        if (cotContent) {
          // å¦‚æœæœ‰æœ€è¿‘çš„AIæ¶ˆæ¯ï¼Œå°†æ€è€ƒè¿‡ç¨‹æ·»åŠ åˆ°è¯¥æ¶ˆæ¯
          if (lastAiMessageIndex >= 0) {
            messages[lastAiMessageIndex].chain_of_thought = cotContent;
          }
          // å¦‚æœæ²¡æœ‰æœ€è¿‘çš„AIæ¶ˆæ¯ï¼Œå­˜å‚¨COTä»¥ä¾¿ä¸ä¸‹ä¸€ä¸ªAIæ¶ˆæ¯å…³è”
          else {
            pendingCOT = cotContent;
          }
        }
      }
    });

    // å¤„ç†æœ€åå¯èƒ½å‰©ä½™çš„å¾…å¤„ç†COT
    if (pendingCOT && messages.length > 0) {
      // å°è¯•æ‰¾åˆ°æœ€åä¸€æ¡æ¶ˆæ¯
      const lastMessage = messages[messages.length - 1];

      // å¦‚æœæœ€åä¸€æ¡æ¶ˆæ¯æ˜¯AIæ¶ˆæ¯ï¼Œå°†COTæ·»åŠ åˆ°è¯¥æ¶ˆæ¯
      if (lastMessage.role === 'assistant') {
        lastMessage.chain_of_thought = pendingCOT;
      }
      // å¦‚æœæœ€åä¸€æ¡æ¶ˆæ¯æ˜¯ç”¨æˆ·æ¶ˆæ¯ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„AIæ¶ˆæ¯
      else if (lastMessage.role === 'user') {
        const aiMessage = {
          role: 'assistant',
          content: "See chain of thought reasoning below:",
          element_id: `ai-final-${Date.now()}`,
          chain_of_thought: pendingCOT
        };

        messages.push(aiMessage);
      }
    }

    return messages;
  } catch (error) {
    console.error('Error extracting messages from page:', error);
    return findMessagesByPattern();
  }
}

/**
 * ä»æ€è€ƒè¿‡ç¨‹å®¹å™¨ä¸­æå–å†…å®¹
 * @param {Element} container - æ€è€ƒè¿‡ç¨‹å®¹å™¨å…ƒç´ 
 * @returns {string} æ¸…ç†åçš„æ€è€ƒè¿‡ç¨‹å†…å®¹
 */
function extractCOTFromContainer(container) {
  try {
    if (!container) return '';

    // é¦–å…ˆå°è¯•æŸ¥æ‰¾æ‰€æœ‰ .ba94db8a å…ƒç´ 
    const cotElements = container.querySelectorAll('.ba94db8a');

    if (cotElements && cotElements.length > 0) {
      // å¦‚æœæ‰¾åˆ°äº† .ba94db8a å…ƒç´ ï¼Œæå–å®ƒä»¬çš„å†…å®¹
      const cotTexts = [];
      cotElements.forEach(el => {
        const text = el.textContent.trim();
        if (text) {
          cotTexts.push(text);
        }
      });

      // å°†æ‰€æœ‰å†…å®¹åˆå¹¶ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²
      const combinedText = cotTexts.join('\n\n');
      return cleanMessageContent(combinedText, 'assistant');
    }

    // å¦‚æœæ²¡æœ‰æ‰¾åˆ° .ba94db8a å…ƒç´ ï¼Œå°è¯•æŸ¥æ‰¾æ‰€æœ‰æ®µè½å…ƒç´ 
    const paragraphs = container.querySelectorAll('p');
    if (paragraphs && paragraphs.length > 0) {
      const paragraphTexts = [];
      paragraphs.forEach(p => {
        const text = p.textContent.trim();
        if (text) {
          paragraphTexts.push(text);
        }
      });

      if (paragraphTexts.length > 0) {
        const combinedText = paragraphTexts.join('\n\n');
        return cleanMessageContent(combinedText, 'assistant');
      }
    }

    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ®µè½å…ƒç´ ï¼Œå°è¯•ç›´æ¥æå–å®¹å™¨çš„å†…å®¹
    const directContent = container.textContent.trim();
    if (directContent) {
      return cleanMessageContent(directContent, 'assistant');
    }

    return '';
  } catch (error) {
    console.error('Error extracting COT content:', error);
    return '';
  }
}

/**
 * è·å–å…ƒç´ åœ¨DOMä¸­çš„ä½ç½®
 * @param {Element} element - è¦è·å–ä½ç½®çš„å…ƒç´ 
 * @returns {number} å…ƒç´ çš„ä½ç½®å€¼
 */
function getElementPosition(element) {
  // ä½¿ç”¨TreeWalkeréå†DOMæ ‘ï¼Œæ‰¾åˆ°å…ƒç´ çš„ä½ç½®
  const treeWalker = document.createTreeWalker(
    document.body,
    NodeFilter.SHOW_ELEMENT,
    null,
    false
  );

  let position = 0;
  let found = false;

  while (treeWalker.nextNode()) {
    position++;
    if (treeWalker.currentNode === element) {
      found = true;
      break;
    }
  }

  return found ? position : Number.MAX_SAFE_INTEGER;
}

/**
 * åŸºäºå†…å®¹æ¨¡å¼æŸ¥æ‰¾æ¶ˆæ¯
 * @returns {Array} æ¶ˆæ¯å…ƒç´ æ•°ç»„
 */
function findMessagesByPattern() {
  const extractedMessages = [];

  try {
    // 1. æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„ç”¨æˆ·æ¶ˆæ¯å®¹å™¨
    const userContainers = document.querySelectorAll('.fbb737a4, .e214291b, [data-role="user"]');

    // 2. æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„AIæ¶ˆæ¯å®¹å™¨
    const aiContainers = document.querySelectorAll('.ds-markdown, .ds-markdown--block, .c92459f0, [data-role="assistant"]');

    // 3. æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„æ€è€ƒè¿‡ç¨‹å®¹å™¨
    const cotContainers = document.querySelectorAll('.e1675d8b');
    const cotElements = document.querySelectorAll('.ba94db8a');

    // åˆ›å»ºä¸€ä¸ªæ•°ç»„æ¥å­˜å‚¨æ‰€æœ‰æ¶ˆæ¯å…ƒç´ åŠå…¶ç±»å‹å’Œä½ç½®
    const allElements = [];

    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
    userContainers.forEach(el => {
      allElements.push({
        element: el,
        type: 'user',
        position: getElementPosition(el)
      });
    });

    // æ·»åŠ AIæ¶ˆæ¯
    aiContainers.forEach(el => {
      allElements.push({
        element: el,
        type: 'ai',
        position: getElementPosition(el)
      });
    });

    // æ·»åŠ æ€è€ƒè¿‡ç¨‹å®¹å™¨
    cotContainers.forEach(el => {
      allElements.push({
        element: el,
        type: 'cot_container',
        position: getElementPosition(el)
      });
    });

    // æŒ‰ç…§å…ƒç´ åœ¨DOMä¸­çš„ä½ç½®æ’åº
    allElements.sort((a, b) => {
      return a.position - b.position;
    });


    // å¤„ç†æ’åºåçš„å…ƒç´ 
    let lastAiMessageIndex = -1;
    let pendingCOT = null; // å­˜å‚¨ç­‰å¾…å…³è”çš„COTå†…å®¹
    let currentUserQuestion = null;

    allElements.forEach((item, index) => {
      const { element, type } = item;
      const content = extractMessageContent(element);

      if (!content) return;

      if (type === 'user') {
        // å¤„ç†ç”¨æˆ·æ¶ˆæ¯
        currentUserQuestion = {
          role: 'user',
          content: cleanMessageContent(content, 'user'),
          element_id: element.id || `user-${index}-${Date.now()}`
        };

        extractedMessages.push(currentUserQuestion);
        lastAiMessageIndex = -1; // é‡ç½®æœ€åä¸€ä¸ªAIæ¶ˆæ¯çš„ç´¢å¼•
      }
      else if (type === 'ai') {
        // å¤„ç†AIæ¶ˆæ¯
        const aiMessage = {
          role: 'assistant',
          content: cleanMessageContent(content, 'assistant'),
          element_id: element.id || `ai-${index}-${Date.now()}`
        };

        // å¦‚æœæœ‰å¾…å¤„ç†çš„COTï¼Œå°†å…¶æ·»åŠ åˆ°è¿™ä¸ªAIæ¶ˆæ¯ä¸­
        if (pendingCOT) {
          aiMessage.chain_of_thought = pendingCOT;
          pendingCOT = null; // æ¸…é™¤å¾…å¤„ç†çš„COT
        }

        extractedMessages.push(aiMessage);
        lastAiMessageIndex = extractedMessages.length - 1;
      }
      else if (type === 'cot_container') {
        // å¤„ç†æ€è€ƒè¿‡ç¨‹å®¹å™¨
        const cotContent = extractCOTFromContainer(element);

        if (cotContent) {
          // å¦‚æœæœ‰æœ€è¿‘çš„AIæ¶ˆæ¯ï¼Œå°†æ€è€ƒè¿‡ç¨‹æ·»åŠ åˆ°è¯¥æ¶ˆæ¯
          if (lastAiMessageIndex >= 0) {
            extractedMessages[lastAiMessageIndex].chain_of_thought = cotContent;
          }
          // å¦‚æœæ²¡æœ‰æœ€è¿‘çš„AIæ¶ˆæ¯ï¼Œå­˜å‚¨COTä»¥ä¾¿ä¸ä¸‹ä¸€ä¸ªAIæ¶ˆæ¯å…³è”
          else {
            pendingCOT = cotContent;
          }
        }
      }
    });

    // å¤„ç†æœ€åå¯èƒ½å‰©ä½™çš„å¾…å¤„ç†COT
    if (pendingCOT && extractedMessages.length > 0) {
      // å°è¯•æ‰¾åˆ°æœ€åä¸€æ¡æ¶ˆæ¯
      const lastMessage = extractedMessages[extractedMessages.length - 1];

      // å¦‚æœæœ€åä¸€æ¡æ¶ˆæ¯æ˜¯AIæ¶ˆæ¯ï¼Œå°†COTæ·»åŠ åˆ°è¯¥æ¶ˆæ¯
      if (lastMessage.role === 'assistant') {
        lastMessage.chain_of_thought = pendingCOT;
      }
      // å¦‚æœæœ€åä¸€æ¡æ¶ˆæ¯æ˜¯ç”¨æˆ·æ¶ˆæ¯ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„AIæ¶ˆæ¯
      else if (lastMessage.role === 'user') {
        const aiMessage = {
          role: 'assistant',
          content: "See chain of thought reasoning below:",
          element_id: `ai-final-${Date.now()}`,
          chain_of_thought: pendingCOT
        };

        extractedMessages.push(aiMessage);
      }
    }

    // å¦‚æœä»ç„¶æ²¡æœ‰æ‰¾åˆ°æ¶ˆæ¯ï¼Œå°è¯•æ›´å¹¿æ³›çš„æœç´¢
    if (extractedMessages.length === 0) {

      // æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½åŒ…å«æ–‡æœ¬çš„å…ƒç´ 
      const allTextElements = document.querySelectorAll('div, p, section, article');
      const potentialMessages = Array.from(allTextElements).filter(el => {
        const text = el.textContent.trim();
        // è¿‡æ»¤æ‰å¤ªçŸ­çš„æ–‡æœ¬å’Œæ˜æ˜¾çš„UIå…ƒç´ 
        return text.length > 20 &&
               !text.includes('New chat') &&
               !text.includes('Sign in') &&
               !text.includes('Sign up') &&
               el.offsetParent !== null; // ç¡®ä¿å…ƒç´ å¯è§
      });


      // å°è¯•ç¡®å®šæ¯ä¸ªå…ƒç´ çš„è§’è‰²å¹¶æå–å†…å®¹
      potentialMessages.forEach((element, index) => {
        const role = determineRoleBySemantics(element);
        const content = extractMessageContent(element);

        if (content && role !== 'unknown') {
          extractedMessages.push({
            role,
            content: cleanMessageContent(content, role),
            element_id: element.id || `potential-message-${index}-${Date.now()}`
          });
        }
      });
    }

  } catch (error) {
    console.error('Error in pattern-based message extraction:', error);
  }

  return extractedMessages;
}

/**
 * æŸ¥æ‰¾æ¶ˆæ¯ä¸­çš„å†…å®¹èŠ‚ç‚¹
 * @param {Element} messageNode - æ¶ˆæ¯èŠ‚ç‚¹
 * @returns {Element|null} å†…å®¹èŠ‚ç‚¹æˆ–null
 */
function findContentNode(messageNode) {
  // æ£€æŸ¥æ˜¯å¦æ˜¯DeepSeekç‰¹å®šçš„æ¶ˆæ¯ç»“æ„
  if (messageNode.classList.contains('e214291b')) {
    // ç”¨æˆ·æ¶ˆæ¯ - æŸ¥æ‰¾textarea
    const textarea = messageNode.querySelector('textarea');
    if (textarea) {
      return textarea;
    }
  }

  // æ£€æŸ¥ç”¨æˆ·é—®é¢˜ç±»
  if (messageNode.classList.contains('fbb737a4')) {
    return messageNode;
  }

  // æ£€æŸ¥AIå›å¤ç±»
  if (messageNode.classList.contains('c92459f0') ||
      messageNode.classList.contains('ds-markdown') ||
      messageNode.classList.contains('ds-markdown--block')) {
    return messageNode;
  }

  // æ£€æŸ¥AIæ€è€ƒè¿‡ç¨‹ç±»
  if (messageNode.classList.contains('ba94db8a')) {
    return messageNode;
  }

  // æ£€æŸ¥æ˜¯å¦æœ‰IDä¸ºchat-inputçš„å…ƒç´ ï¼ˆç”¨æˆ·è¾“å…¥æ¡†ï¼‰
  const chatInput = messageNode.querySelector('#chat-input');
  if (chatInput) {
    return chatInput;
  }

  // æ£€æŸ¥æ˜¯å¦åŒ…å«ç‰¹å®šç±»çš„å­å…ƒç´ 
  const userContentNode = messageNode.querySelector('.fbb737a4');
  if (userContentNode) {
    return userContentNode;
  }

  const aiContentNode = messageNode.querySelector('.ds-markdown, .ds-markdown--block');
  if (aiContentNode) {
    return aiContentNode;
  }

  const cotContentNode = messageNode.querySelector('.ba94db8a');
  if (cotContentNode) {
    return cotContentNode;
  }

  // 1. æŸ¥æ‰¾å…·æœ‰å†…å®¹ç›¸å…³ç±»åçš„å…ƒç´ 
  for (const pattern of SELECTORS.CONTENT_PATTERNS) {
    const contentNodes = messageNode.querySelectorAll(`[class*="${pattern}"]`);
    if (contentNodes.length > 0) {
      // è¿”å›æœ€å¯èƒ½çš„å†…å®¹èŠ‚ç‚¹ï¼ˆé€šå¸¸æ˜¯æœ€å¤§çš„æ–‡æœ¬èŠ‚ç‚¹ï¼‰
      return Array.from(contentNodes).sort((a, b) =>
        b.textContent.length - a.textContent.length
      )[0];
    }
  }

  // 2. æŸ¥æ‰¾å…·æœ‰æ®µè½æˆ–æ–‡æœ¬ç‰¹å¾çš„å…ƒç´ 
  const textElements = messageNode.querySelectorAll('p, div > div:only-child');
  if (textElements.length > 0) {
    return Array.from(textElements).sort((a, b) =>
      b.textContent.length - a.textContent.length
    )[0];
  }

  // 3. å¦‚æœæ¶ˆæ¯èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­å…ƒç´ ï¼Œå¯èƒ½æ˜¯å†…å®¹èŠ‚ç‚¹
  if (messageNode.children.length === 1) {
    return messageNode.children[0];
  }

  return null;
}

/**
 * ç§»é™¤AIç”Ÿæˆçš„é¡µè„šæ–‡æœ¬
 * @param {Element} messageNode - æ¶ˆæ¯èŠ‚ç‚¹
 * @param {string} content - åŸå§‹å†…å®¹
 * @returns {string} æ¸…ç†åçš„å†…å®¹
 */
function removeAIFooters(messageNode, content) {
  // æŸ¥æ‰¾å¯èƒ½çš„AIé¡µè„šå…ƒç´ 
  const footerElements = Array.from(messageNode.querySelectorAll('div, p, span, .fcaa63f8'))
    .filter(el => {
      const text = el.textContent.toLowerCase();
      return SELECTORS.AI_FOOTER_PATTERNS.some(pattern =>
        text.includes(pattern.toLowerCase())
      );
    });

  // ä»å†…å®¹ä¸­ç§»é™¤é¡µè„šæ–‡æœ¬
  let cleanedContent = content;

  // ç‰¹åˆ«å¤„ç†DeepSeekçš„AIç”Ÿæˆé¡µè„š
  const deepseekFooter = messageNode.querySelector('.fcaa63f8');
  if (deepseekFooter) {
    cleanedContent = cleanedContent.replace(deepseekFooter.textContent, '');
  }

  footerElements.forEach(footer => {
    cleanedContent = cleanedContent.replace(footer.textContent, '');
  });

  // ç§»é™¤å¸¸è§çš„AIç”Ÿæˆé¡µè„šæ–‡æœ¬
  cleanedContent = cleanedContent.replace(/AI-generated, for reference only/gi, '');
  cleanedContent = cleanedContent.replace(/AI-generated/gi, '');
  cleanedContent = cleanedContent.replace(/Generated by AI/gi, '');
  cleanedContent = cleanedContent.replace(/å†…å®¹ç”±\s*AI\s*ç”Ÿæˆ/gi, '');

  return cleanedContent;
}

/**
 * åŸºäºè¯­ä¹‰ç¡®å®šæ¶ˆæ¯çš„è§’è‰²
 * @param {Element} messageNode - The message node
 * @returns {string} The role of the message ('user', 'assistant', or 'unknown')
 */
function determineRoleBySemantics(messageNode) {
  // æ£€æŸ¥data-roleå±æ€§
  if (messageNode.dataset.role === 'user') {
    return 'user';
  } else if (messageNode.dataset.role === 'assistant') {
    return 'assistant';
  }

  // æ£€æŸ¥ç‰¹å®šçš„ç±»å
  if (messageNode.classList.contains('e214291b') ||
      messageNode.classList.contains('fbb737a4') ||
      messageNode.closest('.e214291b, .fbb737a4') !== null) {
    return 'user';
  }

  if (messageNode.classList.contains('c92459f0') ||
      messageNode.classList.contains('ds-markdown') ||
      messageNode.classList.contains('ds-markdown--block') ||
      messageNode.closest('.c92459f0, .ds-markdown, .ds-markdown--block') !== null) {
    return 'assistant';
  }

  // æ£€æŸ¥æ˜¯å¦åŒ…å«æ€è€ƒè¿‡ç¨‹å…ƒç´ 
  if (messageNode.classList.contains('ba94db8a') ||
      messageNode.closest('.ba94db8a') !== null ||
      messageNode.querySelector('.ba94db8a') !== null) {
    return 'assistant';
  }

  // 1. æ£€æŸ¥ç±»åå’Œå±æ€§ä¸­çš„è§’è‰²æŒ‡ç¤º
  const classAndAttrs = messageNode.className + ' ' +
                        (messageNode.getAttribute('role') || '') + ' ' +
                        (messageNode.getAttribute('aria-label') || '');

  const classString = classAndAttrs.toLowerCase();

  // æ£€æŸ¥ç”¨æˆ·è§’è‰²æŒ‡ç¤º
  const hasUserIndicator = SELECTORS.USER_MESSAGE_PATTERNS.some(pattern =>
    classString.includes(pattern)
  );

  // æ£€æŸ¥AIè§’è‰²æŒ‡ç¤º
  const hasAIIndicator = SELECTORS.AI_MESSAGE_PATTERNS.some(pattern =>
    classString.includes(pattern)
  );

  // æ£€æŸ¥AIæ€è€ƒè¿‡ç¨‹æŒ‡ç¤º
  const hasCOTIndicator = SELECTORS.AI_COT_PATTERNS.some(pattern =>
    classString.includes(pattern)
  );

  if (hasUserIndicator && !hasAIIndicator && !hasCOTIndicator) return 'user';
  if ((hasAIIndicator || hasCOTIndicator) && !hasUserIndicator) return 'assistant';

  // 2. æ£€æŸ¥å†…å®¹ä¸­çš„AIç”ŸæˆæŒ‡ç¤º
  const content = messageNode.textContent.toLowerCase();
  const hasAIFooter = SELECTORS.AI_FOOTER_PATTERNS.some(pattern =>
    content.includes(pattern.toLowerCase())
  );

  if (hasAIFooter) return 'assistant';

  // 3. æ£€æŸ¥å­å…ƒç´ ä¸­çš„AIæŒ‡ç¤º
  const hasAIFooterElement = Array.from(messageNode.querySelectorAll('*')).some(el =>
    SELECTORS.AI_FOOTER_PATTERNS.some(pattern =>
      el.textContent.toLowerCase().includes(pattern.toLowerCase())
    )
  );

  if (hasAIFooterElement) return 'assistant';

  // æ£€æŸ¥å­å…ƒç´ ä¸­çš„ç‰¹å®šç±»
  const hasUserClass = messageNode.querySelector('.fbb737a4') !== null;
  const hasAIClass = messageNode.querySelector('.ds-markdown, .ds-markdown--block') !== null;
  const hasCOTClass = messageNode.querySelector('.ba94db8a') !== null;

  if (hasUserClass && !hasAIClass && !hasCOTClass) return 'user';
  if ((hasAIClass || hasCOTClass) && !hasUserClass) return 'assistant';

  // 4. ä½¿ç”¨äº¤æ›¿æ¨¡å¼
  const prevRole = document.querySelector('[data-role]')?.dataset.role;

  if (prevRole === 'user') {
    return 'assistant';
  } else if (prevRole === 'assistant' || prevRole === null) {
    return 'user';
  }

  // é»˜è®¤ä¸ºç”¨æˆ·æ¶ˆæ¯
  return 'user';
}

/**
 * åˆ†æé¡µé¢ç»“æ„ä»¥è¯†åˆ«èŠå¤©æ¨¡å¼
 */
function analyzePageStructure() {

  // æ£€æŸ¥æ˜¯å¦æœ‰å¸¦æœ‰data-role="user"çš„å…ƒç´ 
  const userRoleElements = document.querySelectorAll('[data-role="user"]');
  if (userRoleElements.length > 0) {
    return;
  }

  // 1. è¯†åˆ«å¯èƒ½çš„æ¶ˆæ¯å®¹å™¨
  const possibleContainers = findPossibleMessageContainers();

  // 2. è¯†åˆ«å¯¹è¯æ¨¡å¼
  identifyConversationPattern(possibleContainers);
}

/**
 * æŸ¥æ‰¾å¯èƒ½åŒ…å«æ¶ˆæ¯çš„å®¹å™¨
 * @returns {Array} å¯èƒ½çš„æ¶ˆæ¯å®¹å™¨å…ƒç´ æ•°ç»„
 */
function findPossibleMessageContainers() {
  // å¯»æ‰¾å…·æœ‰é‡å¤ç»“æ„çš„å®¹å™¨
  const allDivs = Array.from(document.querySelectorAll('div'));
  const containers = [];

  // æŸ¥æ‰¾åŒ…å«å¤šä¸ªå­å…ƒç´ ä¸”ç»“æ„ç›¸ä¼¼çš„å®¹å™¨
  allDivs.forEach(div => {
    const children = Array.from(div.children);

    // è‡³å°‘æœ‰2ä¸ªå­å…ƒç´ çš„å®¹å™¨
    if (children.length >= 2) {
      // æ£€æŸ¥å­å…ƒç´ æ˜¯å¦æœ‰ç›¸ä¼¼çš„ç»“æ„
      const similarStructure = children.filter(child =>
        child.tagName === children[0].tagName &&
        child.className === children[0].className
      ).length >= 2;

      if (similarStructure) {
        containers.push(div);
      }
    }
  });

  return containers;
}

/**
 * è¯†åˆ«å¯¹è¯æ¨¡å¼
 * @param {Array} containers å¯èƒ½çš„æ¶ˆæ¯å®¹å™¨
 */
function identifyConversationPattern(containers) {
  // å¯¹äºæ¯ä¸ªå®¹å™¨ï¼Œå°è¯•è¯†åˆ«ç”¨æˆ·/AIæ¶ˆæ¯çš„æ¨¡å¼
  containers.forEach(container => {
    const children = Array.from(container.children);

    // æ£€æŸ¥æ˜¯å¦æœ‰äº¤æ›¿çš„ç”¨æˆ·/AIæ¶ˆæ¯æ¨¡å¼
    let userMessages = 0;
    let aiMessages = 0;

    children.forEach(child => {
      const text = child.textContent.toLowerCase();
      const classList = child.className.toLowerCase();

      // æ£€æŸ¥æ˜¯å¦æ˜¯ç”¨æˆ·æ¶ˆæ¯
      const isUserMessage = SELECTORS.USER_MESSAGE_PATTERNS.some(pattern =>
        classList.includes(pattern) || text.includes(pattern)
      );

      // æ£€æŸ¥æ˜¯å¦æ˜¯AIæ¶ˆæ¯
      const isAIMessage = SELECTORS.AI_MESSAGE_PATTERNS.some(pattern =>
        classList.includes(pattern) || text.includes(pattern)
      ) || SELECTORS.AI_FOOTER_PATTERNS.some(pattern => text.includes(pattern));

      if (isUserMessage) userMessages++;
      if (isAIMessage) aiMessages++;
    });

    // å¦‚æœåŒæ—¶æœ‰ç”¨æˆ·å’ŒAIæ¶ˆæ¯ï¼Œè¿™å¯èƒ½æ˜¯ä¸€ä¸ªå¯¹è¯å®¹å™¨
    if (userMessages > 0 && aiMessages > 0) {
      // æ›´æ–°é€‰æ‹©å™¨ä»¥ä½¿ç”¨è¿™ä¸ªå®¹å™¨
      SELECTORS.IDENTIFIED_CONTAINER = container;
    }
  });
}

/**
 * Process a message element and extract its content
 * @param {Element} messageElement - The message element to process
 * @returns {Object|null} - The processed message or null if processing failed
 */
function processMessage(messageElement) {
  if (!messageElement) return null;

  try {
    // ç¡®å®šæ¶ˆæ¯è§’è‰²
    const role = determineRoleBySemantics(messageElement);

    // æŸ¥æ‰¾å†…å®¹èŠ‚ç‚¹
    const contentNode = findContentNode(messageElement);
    if (!contentNode) {
      console.warn('Could not find content node for message:', messageElement);
      return null;
    }

    // æå–æ¶ˆæ¯å†…å®¹
    let content = extractMessageContent(contentNode);
    if (!content) {
      console.warn('Could not extract content for message:', messageElement);
      return null;
    }

    // æ¸…ç†æ¶ˆæ¯å†…å®¹
    content = cleanMessageContent(content, role);

    // ç”Ÿæˆæ¶ˆæ¯çš„å”¯ä¸€æ ‡è¯†
    const elementId = messageElement.id || generateUniqueId();

    // åˆ›å»ºæ¶ˆæ¯å¯¹è±¡
    const message = {
      role,
      content,
      element_id: elementId
    };

    // å¦‚æœæ˜¯AIæ¶ˆæ¯ï¼Œå°è¯•æå–æ€è€ƒè¿‡ç¨‹
    if (role === 'assistant') {
      // æŸ¥æ‰¾ç›¸å…³çš„æ€è€ƒè¿‡ç¨‹å…ƒç´ 
      const cotElements = Array.from(messageElement.querySelectorAll('.ba94db8a'));

      // å¦‚æœåœ¨å½“å‰å…ƒç´ ä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œå°è¯•åœ¨ç›¸é‚»å…ƒç´ ä¸­æŸ¥æ‰¾
      if (cotElements.length === 0) {
        // æŸ¥æ‰¾æ¶ˆæ¯å®¹å™¨
        const messageContainer = messageElement.closest('.message-container') || messageElement.parentElement;
        if (messageContainer) {
          // æŸ¥æ‰¾åŒä¸€å®¹å™¨ä¸­çš„æ€è€ƒè¿‡ç¨‹å…ƒç´ 
          const containerCotElements = Array.from(messageContainer.querySelectorAll('.ba94db8a'));
          cotElements.push(...containerCotElements);
        }

        // æŸ¥æ‰¾ç´§éšå…¶åçš„æ€è€ƒè¿‡ç¨‹å…ƒç´ 
        let nextElement = messageElement.nextElementSibling;
        while (nextElement && cotElements.length === 0) {
          if (nextElement.classList.contains('ba94db8a') || nextElement.querySelector('.ba94db8a')) {
            cotElements.push(nextElement.classList.contains('ba94db8a') ?
              nextElement : nextElement.querySelector('.ba94db8a'));
          }
          nextElement = nextElement.nextElementSibling;
        }
      }

      // å¤„ç†æ‰¾åˆ°çš„æ€è€ƒè¿‡ç¨‹å…ƒç´ 
      if (cotElements.length > 0) {

        // åˆå¹¶æ‰€æœ‰æ€è€ƒè¿‡ç¨‹å†…å®¹
        const cotContents = cotElements.map(cotElement => {
          const cotContent = extractMessageContent(cotElement);
          return cotContent ? cleanMessageContent(cotContent, 'assistant') : '';
        }).filter(Boolean);

        if (cotContents.length > 0) {
          message.chain_of_thought = cotContents.join('\n\n');
        }
      }
    }

    return message;
  } catch (error) {
    console.error('Error processing message:', error);
    return null;
  }
}

/**
 * Extract the text content from a message node
 * @param {Element} node - The node to extract content from
 * @returns {string} - The extracted content
 */
function extractMessageContent(node) {
  if (!node) return '';

  try {
    // å¦‚æœæ˜¯è¾“å…¥å…ƒç´ ï¼Œè·å–å…¶å€¼
    if (node.tagName === 'INPUT' || node.tagName === 'TEXTAREA') {
      return node.value.trim();
    }

    // åˆ›å»ºèŠ‚ç‚¹çš„å…‹éš†ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥ä¿®æ”¹å®ƒè€Œä¸å½±å“åŸå§‹DOM
    const clone = node.cloneNode(true);

    // ç§»é™¤æ‰€æœ‰ä»£ç å—çš„å¤åˆ¶æŒ‰é’®
    clone.querySelectorAll('button').forEach(button => {
      if (button.textContent.includes('Copy') ||
          button.textContent.includes('å¤åˆ¶') ||
          button.classList.contains('copy-button')) {
        button.remove();
      }
    });

    // ç§»é™¤æ‰€æœ‰ä¸å¯è§å…ƒç´ 
    clone.querySelectorAll('*').forEach(el => {
      const style = window.getComputedStyle(el);
      if (style.display === 'none' || style.visibility === 'hidden') {
        el.remove();
      }
    });

    // è·å–æ–‡æœ¬å†…å®¹
    let content = clone.textContent.trim();

    // å¦‚æœå†…å®¹ä¸ºç©ºï¼Œå°è¯•è·å–innerHTML
    if (!content && node.innerHTML) {
      // åˆ›å»ºä¸´æ—¶å…ƒç´ æ¥è§£æHTML
      const temp = document.createElement('div');
      temp.innerHTML = node.innerHTML;

      // ç§»é™¤æ‰€æœ‰è„šæœ¬å’Œæ ·å¼æ ‡ç­¾
      temp.querySelectorAll('script, style').forEach(el => el.remove());

      content = temp.textContent.trim();
    }

    return content;
  } catch (error) {
    console.error('Error extracting message content:', error);
    return '';
  }
}

/**
 * Generate a unique ID for a message
 * @returns {string} - A unique ID
 */
function generateUniqueId() {
  return 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
}

/**
 * Detect and extract DeepSeek code blocks
 * @param {Element} element - The element to check for code blocks
 * @returns {Object|null} - Code block object with language and content, or null if not a code block
 */
function detectDeepSeekCodeBlock(element) {
  if (!element) return null;

  try {
    // Check for md-code-block class (new DeepSeek format)
    if (element.classList.contains('md-code-block')) {
      let language = '';
      const infoStringElement = element.querySelector('.md-code-block-infostring');
      if (infoStringElement) {
        language = infoStringElement.textContent.trim();
      }

      // Find the code content in pre tag
      let codeContent = '';
      const preElement = element.querySelector('pre');
      if (preElement) {
        // Get the HTML content to preserve formatting
        let preHtml = preElement.innerHTML;

        // é€’å½’å¤„ç†åµŒå¥—çš„token spans
        // è¿™ä¸ªå‡½æ•°ä¼šå¤„ç†åµŒå¥—çš„token spanå…ƒç´ ï¼Œä¿ç•™å…¶ä¸­çš„æ–‡æœ¬å†…å®¹
        const processNestedTokens = (html) => {
          // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…æœ€å†…å±‚çš„token spans (æ²¡æœ‰åµŒå¥—å…¶ä»–spansçš„spans)
          const innerTokenRegex = /<span class="token [^"]*">([^<]*)<\/span>/g;
          let result = html;

          // å¦‚æœæ‰¾åˆ°äº†åŒ¹é…é¡¹ï¼Œæ›¿æ¢å®ƒä»¬
          if (innerTokenRegex.test(html)) {
            result = html.replace(innerTokenRegex, '$1');
            // é€’å½’å¤„ç†ï¼Œç›´åˆ°æ²¡æœ‰æ›´å¤šçš„å†…å±‚token spans
            return processNestedTokens(result);
          }

          return result;
        };

        // å¤„ç†åµŒå¥—çš„token spans
        preHtml = processNestedTokens(preHtml);

        // Remove any remaining HTML tags
        codeContent = preHtml.replace(/<[^>]*>/g, '');

        // Clean HTML entities
        codeContent = codeContent
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&amp;/g, '&')
          .replace(/&quot;/g, '"')
          .replace(/&#39;/g, "'")
          .replace(/&nbsp;/g, ' ');

        // å¤„ç†å¤šä½™çš„ç¼©è¿› - ç‰¹åˆ«æ˜¯åœ¨DeepSeekä»£ç å—ä¸­å¸¸è§çš„æƒ…å†µ
        const contentLines = codeContent.split('\n');
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰éç©ºè¡Œéƒ½æœ‰ç›¸åŒçš„å‰å¯¼ç©ºæ ¼
        const nonEmptyLines = contentLines.filter(line => line.trim().length > 0);
        if (nonEmptyLines.length > 0) {
          // æ‰¾å‡ºå…±åŒçš„ç¼©è¿›
          const commonIndent = nonEmptyLines.reduce((indent, line) => {
            const lineIndent = line.match(/^\s*/)[0].length;
            return Math.min(indent, lineIndent);
          }, Infinity);

          // å¦‚æœæœ‰å…±åŒçš„ç¼©è¿›ï¼Œç§»é™¤å®ƒ
          if (commonIndent > 0 && commonIndent !== Infinity) {
            codeContent = contentLines.map(line =>
              line.length >= commonIndent ? line.substring(commonIndent) : line
            ).join('\n');
          }
        }

        // æ£€æŸ¥å†…éƒ¨åµŒå¥—çš„ä»£ç å—
        const nestedCodeBlockStart = codeContent.match(/```([a-zA-Z0-9_+-]*)[\s\n]/);
        if (nestedCodeBlockStart) {
          // æ£€æŸ¥æ˜¯å¦æœ‰å¯¹åº”çš„ç»“æŸæ ‡è®°
          const nestedCodeBlockEnd = codeContent.indexOf("```", nestedCodeBlockStart.index + nestedCodeBlockStart[0].length);

          // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ç»“æŸæ ‡è®°ï¼Œæˆ–è€…ç»“æŸæ ‡è®°åœ¨æœ€åä¸€è¡Œï¼Œæˆ‘ä»¬éœ€è¦æ·»åŠ ä¸€ä¸ª
          if (nestedCodeBlockEnd === -1) {
            // æ·»åŠ ç»“æŸæ ‡è®°åˆ°å†…å®¹çš„æœ«å°¾
            codeContent = codeContent.trim() + "\n```";
          }
        }
      } else {
        // If no pre element, get the text content and clean it
        codeContent = element.textContent;

        // Remove language info and UI elements text
        if (infoStringElement) {
          codeContent = codeContent.replace(infoStringElement.textContent, '');
        }

        // Remove "å¤åˆ¶" button text
        const copyButton = element.querySelector('.ds-markdown-code-copy-button');
        if (copyButton) {
          codeContent = codeContent.replace(copyButton.textContent, '');
        }

        // Remove footer text like "è¿è¡Œ HTML"
        const footer = element.querySelector('.md-code-block-footer');
        if (footer) {
          codeContent = codeContent.replace(footer.textContent, '');
        }
      }

      return {
        language,
        content: codeContent.trim()
      };
    }

    // Check for DeepSeek specific code block classes
    if (element.classList.contains('ds-code-block') ||
        element.classList.contains('code-block') ||
        element.querySelector('.ds-code-block, .code-block')) {

      // Find the target element (either this element or a child)
      const targetElement = element.classList.contains('ds-code-block') || element.classList.contains('code-block')
        ? element
        : element.querySelector('.ds-code-block, .code-block');

      if (!targetElement) return null;

      // Try to find the language
      let language = '';

      // Check data-language attribute
      if (targetElement.hasAttribute('data-language')) {
        language = targetElement.getAttribute('data-language');
      }

      // Check for language in class names
      if (!language) {
        const classMatch = Array.from(targetElement.classList).find(cls => cls.startsWith('language-'));
        if (classMatch) {
          language = classMatch.replace('language-', '');
        }
      }

      // Find the code content
      let codeContent = '';

      // First try to find a specific code content container
      const codeContentElement = targetElement.querySelector('.ds-code-content, .code-content');
      if (codeContentElement) {
        codeContent = codeContentElement.textContent;
      } else {
        // Otherwise use the element's text content, excluding any buttons or headers
        const clone = targetElement.cloneNode(true);

        // Remove copy buttons and headers
        clone.querySelectorAll('button, .ds-code-header, .code-header').forEach(el => el.remove());

        codeContent = clone.textContent;
      }

      return {
        language,
        content: codeContent.trim()
      };
    }

    // Check for pre/code elements
    const preElement = element.tagName === 'PRE' ? element : element.querySelector('pre');
    if (preElement) {
      const codeElement = preElement.querySelector('code');
      if (codeElement) {
        // Check for language class
        let language = '';
        const classMatch = Array.from(codeElement.classList).find(cls => cls.startsWith('language-'));
        if (classMatch) {
          language = classMatch.replace('language-', '');
        }

        return {
          language,
          content: codeElement.textContent.trim()
        };
      }
    }

    return null;
  } catch (error) {
    console.error('Error detecting code block:', error);
    return null;
  }
}

/**
 * Extract code blocks from a message element
 * @param {Element} messageElement - The message element to process
 * @returns {Array} - Array of code block objects with language and content
 */
function extractCodeBlocks(messageElement) {
  if (!messageElement) return [];

  const codeBlocks = [];

  try {
    // Find all potential code block elements
    const potentialCodeBlocks = [
      // First check for the new md-code-block format
      ...messageElement.querySelectorAll('.md-code-block'),
      // Also check for ds-markdown--block elements that might contain code blocks
      ...messageElement.querySelectorAll('.ds-markdown--block .md-code-block'),
      // Then check for other code block formats
      ...messageElement.querySelectorAll('.ds-code-block, .code-block, pre, [class*="code"]'),
      ...Array.from(messageElement.querySelectorAll('div')).filter(div => {
        const text = div.textContent;
        // Look for indented blocks with code-like content
        return text.split('\n').filter(line =>
          /^\s{4,}/.test(line) && /[=(){}\[\];]/.test(line)
        ).length > 2;
      })
    ];

    // Process each potential code block
    potentialCodeBlocks.forEach(element => {
      // Skip if already processed
      if (element.dataset.processed === 'true') {
        return;
      }

      // æ£€æŸ¥æ˜¯å¦æ˜¯åµŒå¥—åœ¨ds-markdownä¸­çš„ä»£ç å—
      const isInMarkdown = element.closest('.ds-markdown, .ds-markdown--block');

      const codeBlock = detectDeepSeekCodeBlock(element);
      if (codeBlock) {
        // å¦‚æœæ˜¯åœ¨markdownä¸­çš„ä»£ç å—ï¼Œæ·»åŠ æ ‡è®°
        if (isInMarkdown) {
          codeBlock.isInMarkdown = true;
        }

        codeBlocks.push(codeBlock);

        // Mark this element as processed to avoid duplicate processing
        element.dataset.processed = 'true';
      }
    });

    return codeBlocks;
  } catch (error) {
    console.error('Error extracting code blocks:', error);
    return [];
  }
}

/**
 * Convert chat data to HTML format
 * @param {Object} data - The chat data to convert
 * @returns {string} - The HTML content
 */
function convertToHTML(data) {
  // åˆ›å»ºåŸºæœ¬çš„HTMLç»“æ„
  let html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${data.title}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f9f9f9;
    }
    .chat-header {
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 1px solid #eaeaea;
    }
    .chat-title {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    .chat-metadata {
      font-size: 14px;
      color: #666;
      margin-bottom: 5px;
    }
    .message-container {
      margin-bottom: 25px;
      padding-bottom: 25px;
      border-bottom: 1px solid #eaeaea;
    }
    .message-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .user-message .message-header {
      color: #2962FF;
    }
    .ai-message .message-header {
      color: #00796B;
    }
    .message-role {
      font-weight: bold;
      font-size: 16px;
      margin-left: 8px;
    }
    .message-content {
      background-color: #fff;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .user-message .message-content {
      background-color: #E3F2FD;
    }
    .ai-message .message-content {
      background-color: #E0F2F1;
    }
    .chain-of-thought {
      margin-top: 15px;
      padding: 12px;
      background-color: #FFF8E1;
      border-radius: 6px;
      border-left: 3px solid #FFB300;
    }
    .chain-of-thought-header {
      font-weight: bold;
      margin-bottom: 8px;
      color: #F57C00;
    }
    pre {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
    }
    code {
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
    }
    .code-block {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
      margin: 15px 0;
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
      white-space: pre-wrap;
    }
    .language-header {
      font-size: 12px;
      color: #666;
      margin-bottom: 5px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="chat-header">
    <div class="chat-title">${data.title}</div>
    <div class="chat-metadata">URL: ${data.url}</div>
    <div class="chat-metadata">Date: ${new Date(data.date).toLocaleString()}</div>
  </div>
`;

  // å¤„ç†æ¯æ¡æ¶ˆæ¯
  data.messages.forEach(msg => {
    const roleClass = msg.role === 'user' ? 'user-message' : 'ai-message';
    const roleIcon = msg.role === 'user' ? 'ğŸ§‘' : 'ğŸ¤–';
    const roleName = msg.role === 'user' ? 'User' : 'DeepSeek AI';

    // å¤„ç†æ¶ˆæ¯å†…å®¹ï¼Œå¦‚æœæ˜¯ Markdown æ ¼å¼ï¼Œè½¬æ¢ä¸º HTML
    let processedContent = msg.content;
    if (msg.format === 'markdown') {
      processedContent = convertMarkdownToHTML(msg.content);
    }

    html += `  <div class="message-container ${roleClass}">
    <div class="message-header">
      <span>${roleIcon}</span>
      <span class="message-role">${roleName}</span>
    </div>
    <div class="message-content">
      ${processedContent}
    </div>`;

    // æ·»åŠ æ€è€ƒè¿‡ç¨‹ï¼ˆå¦‚æœæœ‰ï¼‰
    if (msg.chain_of_thought) {
      // å¤„ç†æ€è€ƒè¿‡ç¨‹å†…å®¹ï¼Œå¦‚æœæ˜¯ Markdown æ ¼å¼ï¼Œè½¬æ¢ä¸º HTML
      let processedCOT = msg.chain_of_thought;
      if (msg.format === 'markdown') {
        processedCOT = convertMarkdownToHTML(msg.chain_of_thought);
      }

      html += `    <div class="chain-of-thought">
      <div class="chain-of-thought-header">Thinking Process:</div>
      ${processedCOT}
    </div>`;
    }

    html += `  </div>\n`;
  });

  // å…³é—­HTMLç»“æ„
  html += `</body>
</html>`;

  return html;
}

/**
 * å°† Markdown æ ¼å¼çš„æ–‡æœ¬è½¬æ¢ä¸º HTML
 * @param {string} markdown - Markdown æ–‡æœ¬
 * @returns {string} - HTML æ–‡æœ¬
 */
function convertMarkdownToHTML(markdown) {
  if (!markdown) return '';

  // é¦–å…ˆç¡®ä¿æ‰€æœ‰ä»£ç å—éƒ½æœ‰æ­£ç¡®çš„ç»“æŸæ ‡è®°
  markdown = validateCodeBlocks(markdown);

  // å¤„ç†ä»£ç å—
  let html = markdown.replace(/```([\s\S]*?)```/g, (match, codeContent) => {
    // æå–è¯­è¨€ï¼ˆå¦‚æœæœ‰ï¼‰
    const firstLine = codeContent.trim().split('\n')[0];
    let language = '';
    let code = codeContent;

    if (firstLine && !firstLine.includes('=') && !firstLine.includes('{') && !firstLine.includes(';')) {
      language = firstLine.trim();
      code = codeContent.substring(firstLine.length).trim();
    }

    return `<div class="code-block">
      ${language ? `<div class="language-header">${language}</div>` : ''}
      <pre><code>${escapeHTML(code)}</code></pre>
    </div>`;
  });

  // å¤„ç†æ ‡é¢˜
  html = html.replace(/^# (.*?)$/gm, '<h1>$1</h1>');
  html = html.replace(/^## (.*?)$/gm, '<h2>$1</h2>');
  html = html.replace(/^### (.*?)$/gm, '<h3>$1</h3>');
  html = html.replace(/^#### (.*?)$/gm, '<h4>$1</h4>');
  html = html.replace(/^##### (.*?)$/gm, '<h5>$1</h5>');
  html = html.replace(/^###### (.*?)$/gm, '<h6>$1</h6>');

  // å¤„ç†ç²—ä½“å’Œæ–œä½“
  html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');

  // å¤„ç†é“¾æ¥
  html = html.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank">$1</a>');

  // å¤„ç†æ— åºåˆ—è¡¨
  html = html.replace(/^- (.*?)$/gm, '<li>$1</li>');
  html = html.replace(/(<li>.*?<\/li>\n)+/g, '<ul>$&</ul>');

  // å¤„ç†æœ‰åºåˆ—è¡¨
  html = html.replace(/^\d+\. (.*?)$/gm, '<li>$1</li>');
  html = html.replace(/(<li>.*?<\/li>\n)+/g, (match) => {
    // é¿å…é‡å¤å¤„ç†å·²ç»åŒ…è£…åœ¨ <ul> ä¸­çš„åˆ—è¡¨
    return match.includes('<ul>') ? match : `<ol>${match}</ol>`;
  });

  // å¤„ç†å¼•ç”¨
  html = html.replace(/^> (.*?)$/gm, '<blockquote>$1</blockquote>');

  // å¤„ç†åˆ†éš”çº¿
  html = html.replace(/^---$/gm, '<hr>');

  // å¤„ç†è¡¨æ ¼
  // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„è¡¨æ ¼å¤„ç†ï¼Œå¯èƒ½éœ€è¦æ›´å¤æ‚çš„é€»è¾‘æ¥å¤„ç†æ‰€æœ‰æƒ…å†µ
  html = html.replace(/^\|(.*)\|$/gm, (match, content) => {
    const cells = content.split('|').map(cell => cell.trim());
    return `<tr>${cells.map(cell => `<td>${cell}</td>`).join('')}</tr>`;
  });

  // å°†è¡¨æ ¼è¡Œç»„åˆæˆè¡¨æ ¼
  html = html.replace(/(<tr>.*?<\/tr>\n)+/g, '<table>$&</table>');

  // å¤„ç†æ®µè½
  html = html.replace(/^([^<].*?)$/gm, (match, content) => {
    // é¿å…å¤„ç†å·²ç»åŒ…å«åœ¨HTMLæ ‡ç­¾ä¸­çš„å†…å®¹
    if (
      content.trim() === '' ||
      content.startsWith('<') ||
      match.startsWith('<')
    ) {
      return match;
    }
    return `<p>${content}</p>`;
  });

  return html;
}

/**
 * è½¬ä¹‰ HTML ç‰¹æ®Šå­—ç¬¦
 * @param {string} text - è¦è½¬ä¹‰çš„æ–‡æœ¬
 * @returns {string} - è½¬ä¹‰åçš„æ–‡æœ¬
 */
function escapeHTML(text) {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

// æ·»åŠ æ¶ˆæ¯ç›‘å¬å™¨ï¼Œå¤„ç†æ¥è‡ªå¼¹å‡ºçª—å£çš„è¯·æ±‚
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'export') {
    try {
      const format = request.format || 'json';

      // ç›´æ¥ä»é¡µé¢æå–æœ€æ–°æ¶ˆæ¯
      const latestMessages = extractAllMessagesFromPage();

      if (latestMessages.length === 0) {
        sendResponse({ success: false, message: chrome.i18n.getMessage('noMessagesFound') });
        return true;
      }

      // å‡†å¤‡å¯¼å‡ºæ•°æ®
      const exportData = {
        title: `DeepSeek Chat - ${new Date().toLocaleString()}`,
        url: window.location.href,
        date: new Date().toISOString(),
        messages: latestMessages
      };

      // ä½¿ç”¨å¯¼å‡ºå‡½æ•°ä¸‹è½½èŠå¤©æ•°æ®
      downloadChat(exportData, format);

      // å‘é€æˆåŠŸå“åº”
      sendResponse({ success: true });
    } catch (error) {
      console.error('Error during export:', error);
      sendResponse({
        success: false,
        message: chrome.i18n.getMessage('exportError'),
        error: error.message
      });
    }
    return true;
  }
});

// ä½¿ç”¨DOMContentLoadedäº‹ä»¶æ›´æ—©åœ°åˆå§‹åŒ–æ’ä»¶
document.addEventListener('DOMContentLoaded', function() {
  init();
});

// å¦‚æœDOMContentLoadedå·²ç»è§¦å‘ï¼Œåˆ™ç«‹å³åˆå§‹åŒ–
if (document.readyState === 'interactive' || document.readyState === 'complete') {
  init();
}
